<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>GLES</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso-iso-8859-1">
<STYLE TYPE="text/css"><!--
BODY { font-family: serif }
H1 { font-family: sans-serif }
H2 { font-family: sans-serif }
H3 { font-family: sans-serif }
H4 { font-family: sans-serif }
H5 { font-family: sans-serif }
H6 { font-family: sans-serif }
SUB { font-size: smaller }
SUP { font-size: smaller }
PRE { font-family: monospace }
--></STYLE>
</HEAD>
<BODY>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" title="glActiveTexture"><A id="glActiveTexture"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2644">Name</A></H2>
<P>glActiveTexture -- select active texture unit</P>
</DIV><DIV class="refsynopsisdiv" title="C Specification">
<H2><A NAME="0_2645">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glActiveTexture</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> texture</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
title="Parameters"><A id="parameters"></A>
<H2><A NAME="0_2646">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>texture</CODE></EM></DT>
<DD>
<P> Specifies which texture unit to make active. The number of texture
 units is implementation dependent, but must be at least 8.<EM class="parameter">
 <CODE>texture</CODE></EM> must be one of <CODE class="constant">
GL_TEXTURE</CODE>
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
i, where i ranges from 0 to (<CODE class="constant">
GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</CODE> - 1). The initial value is <CODE
class="constant">GL_TEXTURE0</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  title="Description"><A id="description">
</A>
<H2><A NAME="0_2647">Description</A></H2>
<P> <CODE class="function">glActiveTexture</CODE> selects which texture
 unit subsequent texture state calls will affect. The number of texture
 units an implementation supports is implementation dependent, but must
 be at least 8.</P>
</DIV><DIV class="refsect1"  title="Errors"><A id="errors"></A>
<H2><A NAME="0_2648">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>texture</CODE></EM> is not one of <CODE class="constant">
GL_TEXTURE</CODE>
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
i, where i ranges from 0 to (<CODE class="constant">
GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</CODE> - 1).</P>
</DIV><DIV class="refsect1"  title="Associated Gets"><A id="associatedgets">
</A>
<H2><A NAME="0_2649">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_ACTIVE_TEXTURE</CODE>
 or <CODE class="constant">GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</CODE></P>
</DIV><DIV class="refsect1"  title="See Also"><A id="seealso"></A>
<H2><A NAME="0_2650">See Also</A></H2>
<P> <A class="citerefentry" href="#glTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glAttachShader"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2652">Name</A></H2>
<P>glAttachShader -- attach a shader object to a program object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2653">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glAttachShader</B>(</CODE>
</TD><TD>GLuint<VAR class="pdparam"> program</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> shader</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2654">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the program object to which a shader object will be
 attached.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shader</CODE></EM></DT>
<DD>
<P>Specifies the shader object that is to be attached.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2655">Description</A></H2>
<P>In order to create an executable, there must be a way to specify the
 list of things that will be linked together. Program objects provide
 this mechanism. Shaders that are to be linked together in a program
 object must first be attached to that program object. <CODE class="function">
glAttachShader</CODE> attaches the shader object specified by<EM class="parameter">
 <CODE>shader</CODE></EM> to the program object specified by<EM class="parameter">
 <CODE>program</CODE></EM>. This indicates that<EM class="parameter"> <CODE>
shader</CODE></EM> will be included in link operations that will be
 performed on<EM class="parameter"> <CODE>program</CODE></EM>.</P>
<P>All operations that can be performed on a shader object are valid
 whether or not the shader object is attached to a program object. It is
 permissible to attach a shader object to a program object before source
 code has been loaded into the shader object or before the shader object
 has been compiled. Multiple shader objects of the same type may not be
 attached to a single program object. However, a single shader object
 may be attached to more than one program object. If a shader object is
 deleted while it is attached to a program object, it will be flagged
 for deletion, and deletion will not occur until <A class="citerefentry" href="#glDetachShader">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDetachShader</A> is called to detach it from all program objects to
 which it is attached.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2656">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if either<EM
class="parameter"> <CODE>program</CODE></EM> or<EM class="parameter"> <CODE>
shader</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not a shader object.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is already attached to<EM class="parameter"> <CODE>
program</CODE></EM>, or if another shader object of the same type as<EM class="parameter">
 <CODE>shader</CODE></EM> is already attached to<EM class="parameter"> <CODE>
program</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2657">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetAttachedShaders">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttachedShaders</A> with the handle of a valid program object</P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
<P><A class="citerefentry" href="#glIsShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsShader</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2658">See Also</A></H2>
<P><A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glDetachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDetachShader</A>, <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A>, <A class="citerefentry" href="#glShaderBinary">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderBinary</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glBindAttribLocation">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2660">Name</A></H2>
<P>glBindAttribLocation -- associate a generic vertex attribute index
 with a named attribute variable</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2661">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glBindAttribLocation</B>(</CODE></TD><TD>GLuint<VAR class="pdparam">
 program</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLchar *<VAR class="pdparam">name</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2662">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the handle of the program object in which the association
 is to be made.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>index</CODE></EM></DT>
<DD>
<P>Specifies the index of the generic vertex attribute to be bound.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>name</CODE></EM></DT>
<DD>
<P>Specifies a null terminated string containing the name of the vertex
 shader attribute variable to which<EM class="parameter"> <CODE>index</CODE>
</EM> is to be bound.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2663">Description</A></H2>
<P><CODE class="function">glBindAttribLocation</CODE> is used to
 associate a user-defined attribute variable in the program object
 specified by<EM class="parameter"> <CODE>program</CODE></EM> with a
 generic vertex attribute index. The name of the user-defined attribute
 variable is passed as a null terminated string in<EM class="parameter">
 <CODE>name</CODE></EM>. The generic vertex attribute index to be bound
 to this variable is specified by<EM class="parameter"> <CODE>index</CODE>
</EM>. When<EM class="parameter"> <CODE>program</CODE></EM> is made part
 of current state, values provided via the generic vertex attribute<EM class="parameter">
 <CODE>index</CODE></EM> will modify the value of the user-defined
 attribute variable specified by<EM class="parameter"> <CODE>name</CODE></EM>
.</P>
<P>If<EM class="parameter"> <CODE>name</CODE></EM> refers to a matrix
 attribute variable,<EM class="parameter"> <CODE>index</CODE></EM>
 refers to the first column of the matrix. Other matrix columns are then
 automatically bound to locations<EM class="parameter"> <CODE>index+1</CODE>
</EM> for a matrix of type mat2;<EM class="parameter"> <CODE>index+1</CODE>
</EM> and<EM class="parameter"> <CODE>index+2</CODE></EM> for a matrix
 of type mat3; and<EM class="parameter"> <CODE>index+1</CODE></EM>,<EM class="parameter">
 <CODE>index+2</CODE></EM>, and<EM class="parameter"> <CODE>index+3</CODE>
</EM> for a matrix of type mat4.</P>
<P>This command makes it possible for vertex shaders to use descriptive
 names for attribute variables rather than generic variables that are
 numbered from 0 to <CODE class="constant">GL_MAX_VERTEX_ATTRIBS</CODE>
 -1. The values sent to each generic attribute index are part of current
 state, just like standard vertex attributes such as color, normal, and
 vertex position. If a different program object is made current by
 calling <A class="citerefentry" href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A>, the generic vertex attributes are tracked in such a
 way that the same values will be observed by attributes in the new
 program object that are also bound to<EM class="parameter"> <CODE>index</CODE>
</EM>.</P>
<P>Attribute variable name-to-generic attribute index bindings for a
 program object can be explicitly assigned at any time by calling <CODE class="function">
glBindAttribLocation</CODE>. Attribute bindings do not go into effect
 until <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A> is called. After a program object has been linked
 successfully, the index values for generic attributes remain fixed (and
 their values can be queried) until the next link command occurs.</P>
<P>Applications are not allowed to bind any of the standard OpenGL
 vertex attributes using this command, as they are bound automatically
 when needed. Any attribute binding that occurs after the program object
 has been linked will not take effect until the next time the program
 object is linked.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2664">Notes</A></H2>
<P><CODE class="function">glBindAttribLocation</CODE> can be called
 before any vertex shader objects are bound to the specified program
 object. It is also permissible to bind a generic attribute index to an
 attribute variable name that is never used in a vertex shader.</P>
<P>If<EM class="parameter"> <CODE>name</CODE></EM> was bound previously,
 that information is lost. Thus you cannot bind one user-defined
 attribute variable to multiple indices, but you can bind multiple
 user-defined attribute variables to the same index.</P>
<P>Applications are allowed to bind more than one user-defined attribute
 variable to the same generic vertex attribute index. This is called
<!--span class=&quot;emphasis&quot;-->
<EM> aliasing</EM>, and it is allowed only if just one of the aliased
 attributes is active in the executable program, or if no path through
 the shader consumes more than one attribute of a set of attributes
 aliased to the same location. The compiler and linker are allowed to
 assume that no aliasing is done and are free to employ optimizations
 that work only in the absence of aliasing. OpenGL implementations are
 not required to do error checking to detect aliasing. Because there is
 no way to bind standard attributes, it is not possible to alias generic
 attributes with conventional ones (except for generic attribute 0).</P>
<P>Active attributes that are not explicitly bound will be bound by the
 linker when <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A> is called. The locations assigned can be queried by
 calling <A class="citerefentry" href="#glGetAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttribLocation</A>.</P>
<P>OpenGL copies the<EM class="parameter"> <CODE>name</CODE></EM> string
 when <CODE class="function">glBindAttribLocation</CODE> is called, so
 an application may free its copy of the<EM class="parameter"> <CODE>
name</CODE></EM> string immediately after the function returns.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2665">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>index</CODE></EM> is greater than or equal to <CODE class="constant">
GL_MAX_VERTEX_ATTRIBS</CODE>.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>name</CODE></EM> starts with the reserved prefix &quot;gl_&quot;.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2666">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_VERTEX_ATTRIBS</CODE>
</P>
<P><A class="citerefentry" href="#glGetActiveAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveAttrib</A> with argument<EM class="parameter"> <CODE>program</CODE>
</EM></P>
<P><A class="citerefentry" href="#glGetAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttribLocation</A> with arguments<EM class="parameter"> <CODE>
program</CODE></EM> and<EM class="parameter"> <CODE>name</CODE></EM></P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2667">See Also</A></H2>
<P><A class="citerefentry" href="#glEnableVertexAttribArray">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisableVertexAttribArray</A>, <A class="citerefentry" href="#glEnableVertexAttribArray">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnableVertexAttribArray</A>, <A class="citerefentry" href="#glUseProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A>, <A class="citerefentry" href="#glVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttrib</A>, <A class="citerefentry" href="#glVertexAttribPointer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttribPointer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glBindBuffer"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2669">Name</A></H2>
<P>glBindBuffer -- bind a named buffer object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2670">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glBindBuffer</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> buffer</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2671">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target to which the buffer object is bound. The
 symbolic constant must be <CODE class="constant">GL_ARRAY_BUFFER</CODE>
 or <CODE class="constant">GL_ELEMENT_ARRAY_BUFFER</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>buffer</CODE></EM></DT>
<DD>
<P> Specifies the name of a buffer object.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2672">Description</A></H2>
<P> <CODE class="function">glBindBuffer</CODE> lets you create or use a
 named buffer object. Calling <CODE class="function">glBindBuffer</CODE>
 with<EM class="parameter"> <CODE>target</CODE></EM> set to <CODE class="constant">
GL_ARRAY_BUFFER</CODE> or <CODE class="constant">GL_ELEMENT_ARRAY_BUFFER</CODE>
 and<EM class="parameter"> <CODE>buffer</CODE></EM> set to the name of
 the new buffer object binds the buffer object name to the target. When
 a buffer object is bound to a target, the previous binding for that
 target is automatically broken.</P>
<P> Buffer object names are unsigned integers. The value zero is
 reserved, but there is no default buffer object for each buffer object
 target. Instead,<EM class="parameter"> <CODE>buffer</CODE></EM> set to
 zero effectively unbinds any buffer object previously bound, and
 restores client memory usage for that buffer object target. Buffer
 object names and the corresponding buffer object contents are local to
 the shared object space of the current GL rendering context.</P>
<P> You may use <A class="citerefentry" href="#glGenBuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenBuffers</A> to generate a set of new buffer object names.</P>
<P> The state of a buffer object immediately after it is first bound is
 a zero-sized memory buffer with <CODE class="constant">GL_STATIC_DRAW</CODE>
 usage.</P>
<P> While a non-zero buffer object name is bound, GL operations on the
 target to which it is bound affect the bound buffer object, and queries
 of the target to which it is bound return state from the bound buffer
 object. While buffer object name zero is bound, as in the initial
 state, attempts to modify or query state on the target to which it is
 bound generates an <CODE class="constant">GL_INVALID_OPERATION</CODE>
 error.</P>
<P> When vertex array pointer state is changed by a call to <A class="citerefentry"
href="#glVertexAttribPointer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttribPointer</A>, the current buffer object binding (<CODE class="constant">
GL_ARRAY_BUFFER_BINDING</CODE>) is copied into the corresponding client
 state for the vertex attrib array being changed, one of the indexed <CODE
class="constant">GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</CODE>s. While a
 non-zero buffer object is bound to the <CODE class="constant">
GL_ARRAY_BUFFER</CODE> target, the vertex array pointer parameter that
 is traditionally interpreted as a pointer to client-side memory is
 instead interpreted as an offset within the buffer object measured in
 basic machine units.</P>
<P> While a non-zero buffer object is bound to the <CODE class="constant">
GL_ELEMENT_ARRAY_BUFFER</CODE> target, the indices parameter of <A class="citerefentry"
href="#glDrawElements">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawElements</A> that is traditionally interpreted as a pointer to
 client-side memory is instead interpreted as an offset within the
 buffer object measured in basic machine units.</P>
<P> A buffer object binding created with <CODE class="function">
glBindBuffer</CODE> remains active until a different buffer object name
 is bound to the same target, or until the bound buffer object is
 deleted with <A class="citerefentry" href="#glDeleteBuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteBuffers</A>.</P>
<P> Once created, a named buffer object may be re-bound to any target as
 often as needed. However, the GL implementation may make choices about
 how to optimize the storage of a buffer object based on its initial
 binding target.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2673">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not one of the allowable values.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2674">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_ARRAY_BUFFER_BINDING</CODE>
</P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">
GL_ELEMENT_ARRAY_BUFFER_BINDING</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2675">See Also</A></H2>
<P> <A class="citerefentry" href="#glDeleteBuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteBuffers</A>, <A class="citerefentry" href="#glGenBuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenBuffers</A>, <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A>, <A class="citerefentry" href="#glIsBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsBuffer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glBindFramebuffer"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2677">Name</A></H2>
<P>glBindFramebuffer -- bind a named framebuffer object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2678">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glBindFramebuffer</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> framebuffer</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2679">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target to which the framebuffer object is bound. The
 symbolic constant must be <CODE class="constant">GL_FRAMEBUFFER</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>framebuffer</CODE></EM></DT>
<DD>
<P> Specifies the name of a framebuffer object.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2680">Description</A></H2>
<P> <CODE class="function">glBindFramebuffer</CODE> lets you create or
 use a named framebuffer object. Calling <CODE class="function">
glBindFramebuffer</CODE> with<EM class="parameter"> <CODE>target</CODE></EM>
 set to <CODE class="constant">GL_FRAMEBUFFER</CODE> and<EM class="parameter">
 <CODE>framebuffer</CODE></EM> set to the name of the new framebuffer
 object binds the framebuffer object name. When a framebuffer object is
 bound, the previous binding is automatically broken.</P>
<P> Framebuffer object names are unsigned integers. The value zero is
 reserved to represent the default framebuffer provided by the windowing
 system. Framebuffer object names and the corresponding framebuffer
 object contents are local to the shared object space of the current GL
 rendering context.</P>
<P> You may use <A class="citerefentry" href="#glGenFramebuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenFramebuffers</A> to generate a set of new framebuffer object names.</P>
<P> The state of a framebuffer object immediately after it is first
 bound is three attachment points (<CODE class="constant">
GL_COLOR_ATTACHMENT0</CODE>, <CODE class="constant">GL_DEPTH_ATTACHMENT</CODE>
, and <CODE class="constant">GL_STENCIL_ATTACHMENT</CODE>) each with <CODE
class="constant">GL_NONE</CODE> as the object type.</P>
<P> While a non-zero framebuffer object name is bound, GL operations on
 target <CODE class="constant">GL_FRAMEBUFFER</CODE> affect the bound
 framebuffer object, and queries of target <CODE class="constant">
GL_FRAMEBUFFER</CODE> or of framebuffer details such as <CODE class="constant">
GL_DEPTH_BITS</CODE> return state from the bound framebuffer object.
 While framebuffer object name zero is bound, as in the initial state,
 attempts to modify or query state on target <CODE class="constant">
GL_FRAMEBUFFER</CODE> generates an <CODE class="constant">
GL_INVALID_OPERATION</CODE> error.</P>
<P> While a non-zero framebuffer object name is bound, all rendering to
 the framebuffer (with <A class="citerefentry" href="#glDrawArrays">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawArrays</A> and <A class="citerefentry" href="#glDrawElements">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawElements</A>) and reading from the framebuffer (with <A class="citerefentry"
href="#glReadPixels">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReadPixels</A>, <A class="citerefentry" href="#glCopyTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A>, or <A class="citerefentry" href="#glCopyTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexSubImage2D</A>) use the images attached to the
 application-created framebuffer object rather than the default
 window-system-provided framebuffer.</P>
<P> Application created framebuffer objects (i.e. those with a non-zero
 name) differ from the default window-system-provided framebuffer in a
 few important ways. First, they have modifiable attachment points for a
 color buffer, a depth buffer, and a stencil buffer to which framebuffer
 attachable images may be attached and detached. Second, the size and
 format of the attached images are controlled entirely within the GL and
 are not affected by window-system events, such as pixel format
 selection, window resizes, and display mode changes. Third, when
 rendering to or reading from an application created framebuffer object,
 the pixel ownership test always succeeds (i.e. they own all their
 pixels). Fourth, there are no visible color buffer bitplanes, only a
 single &quot;off-screen&quot; color image attachment, so there is no sense of
 front and back buffers or swapping. Finally, there is no multisample
 buffer, so the value of the implementation-dependent state variables <CODE
class="constant">GL_SAMPLES</CODE> and <CODE class="constant">
GL_SAMPLE_BUFFERS</CODE> are both zero for application created
 framebuffer objects.</P>
<P> A framebuffer object binding created with <CODE class="function">
glBindFramebuffer</CODE> remains active until a different framebuffer
 object name is bound, or until the bound framebuffer object is deleted
 with <A class="citerefentry" href="#glDeleteFramebuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteFramebuffers</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2681">Notes</A></H2>
<P> Queries of implementation-dependent pixel depths and related state
 are derived from the currently bound framebuffer object. These include <CODE
class="constant">GL_RED_BITS</CODE>, <CODE class="constant">
GL_GREEN_BITS</CODE>, <CODE class="constant">GL_BLUE_BITS</CODE>, <CODE class="constant">
GL_ALPHA_BITS</CODE>, <CODE class="constant">GL_DEPTH_BITS</CODE>, <CODE class="constant">
GL_STENCIL_BITS</CODE>, <CODE class="constant">
GL_IMPLEMENTATION_COLOR_READ_TYPE</CODE>, <CODE class="constant">
GL_IMPLEMENTATION_COLOR_READ_FORMAT</CODE>, <CODE class="constant">
GL_SAMPLES</CODE>, and <CODE class="constant">GL_SAMPLE_BUFFERS</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2682">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_FRAMEBUFFER</CODE>
.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2683">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_FRAMEBUFFER_BINDING</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2684">See Also</A></H2>
<P> <A class="citerefentry" href="#glDeleteFramebuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteFramebuffers</A>, <A class="citerefentry" href="#glFramebufferRenderbuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFramebufferRenderbuffer</A>, <A class="citerefentry" href="#glFramebufferTexture2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFramebufferTexture2D</A>, <A class="citerefentry" href="#glGenFramebuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenFramebuffers</A>, <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A>, <A class="citerefentry" href="#glGetFramebufferAttachmentParameteriv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetFramebufferAttachmentParameteriv</A>, <A class="citerefentry" href="#glIsFramebuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsFramebuffer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glBindRenderbuffer">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2686">Name</A></H2>
<P>glBindRenderbuffer -- bind a named renderbuffer object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2687">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glBindRenderbuffer</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> renderbuffer</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2688">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target to which the renderbuffer object is bound. The
 symbolic constant must be <CODE class="constant">GL_RENDERBUFFER</CODE>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>renderbuffer</CODE></EM></DT>
<DD>
<P> Specifies the name of a renderbuffer object.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2689">Description</A></H2>
<P> A renderbuffer is a data storage object containing a single image of
 a renderable internal format. A renderbuffer's image may be attached to
 a framebuffer object to use as a destination for rendering and as a
 source for reading.</P>
<P> <CODE class="function">glBindRenderbuffer</CODE> lets you create or
 use a named renderbuffer object. Calling <CODE class="function">
glBindRenderbuffer</CODE> with<EM class="parameter"> <CODE>target</CODE></EM>
 set to <CODE class="constant">GL_RENDERBUFFER</CODE> and<EM class="parameter">
 <CODE>renderbuffer</CODE></EM> set to the name of the new renderbuffer
 object binds the renderbuffer object name. When a renderbuffer object
 is bound, the previous binding is automatically broken.</P>
<P> Renderbuffer object names are unsigned integers. The value zero is
 reserved, but there is no default renderbuffer object. Instead,<EM class="parameter">
 <CODE>renderbuffer</CODE></EM> set to zero effectively unbinds any
 renderbuffer object previously bound. Renderbuffer object names and the
 corresponding renderbuffer object contents are local to the shared
 object space of the current GL rendering context.</P>
<P> You may use <A class="citerefentry" href="#glGenRenderbuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenRenderbuffers</A> to generate a set of new renderbuffer object
 names.</P>
<P> The state of a renderbuffer object immediately after it is first
 bound is a zero-sized memory buffer with format <CODE class="constant">
GL_RGBA4</CODE> and zero-sized red, green, blue, alpha, depth, and
 stencil pixel depths.</P>
<P> While a non-zero renderbuffer object name is bound, GL operations on
 target <CODE class="constant">GL_RENDERBUFFER</CODE> affect the bound
 renderbuffer object, and queries of target <CODE class="constant">
GL_RENDERBUFFER</CODE> return state from the bound renderbuffer object.
 While renderbuffer object name zero is bound, as in the initial state,
 attempts to modify or query state on target <CODE class="constant">
GL_RENDERBUFFER</CODE> generates an <CODE class="constant">
GL_INVALID_OPERATION</CODE> error.</P>
<P> A renderbuffer object binding created with <CODE class="function">
glBindRenderbuffer</CODE> remains active until a different renderbuffer
 object name is bound, or until the bound renderbuffer object is deleted
 with <A class="citerefentry" href="#glDeleteRenderbuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteRenderbuffers</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2690">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_RENDERBUFFER</CODE>
.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2691">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_RENDERBUFFER_BINDING</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2692">See Also</A></H2>
<P> <A class="citerefentry" href="#glDeleteRenderbuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteRenderbuffers</A>, <A class="citerefentry" href="#glFramebufferRenderbuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFramebufferRenderbuffer</A>, <A class="citerefentry" href="#glGenRenderbuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenRenderbuffers</A>, <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A>, <A class="citerefentry" href="#glGetRenderbufferParameteriv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetRenderbufferParameteriv</A>, <A class="citerefentry" href="#glIsRenderbuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsRenderbuffer</A>, <A class="citerefentry" href="#glRenderbufferStorage">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glRenderbufferStorage</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" title="glBindTexture"><A id="glBindTexture"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2694">Name</A></H2>
<P>glBindTexture -- bind a named texture to a texturing target</P>
</DIV><DIV class="refsynopsisdiv" title="C Specification">
<H2><A NAME="0_2695">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glBindTexture</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> texture</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
title="Parameters"><A id="parameters"></A>
<H2><A NAME="0_2696">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target of the active texture unit to which the texture
 is bound. Must be either <CODE class="constant">GL_TEXTURE_2D</CODE> or
 <CODE class="constant">GL_TEXTURE_CUBE_MAP</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>texture</CODE></EM></DT>
<DD>
<P> Specifies the name of a texture.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  title="Description"><A id="description">
</A>
<H2><A NAME="0_2697">Description</A></H2>
<P> <CODE class="function">glBindTexture</CODE> lets you create or use a
 named texture. Calling <CODE class="function">glBindTexture</CODE> with<EM
class="parameter"> <CODE>target</CODE></EM> set to <CODE class="constant">
GL_TEXTURE_2D</CODE> or <CODE class="constant">GL_TEXTURE_CUBE_MAP</CODE>
 and<EM class="parameter"> <CODE>texture</CODE></EM> set to the name of
 the new texture binds the texture name to the target of the current
 active texture unit. When a texture is bound to a target, the previous
 binding for that target is automatically broken.</P>
<P> Texture names are unsigned integers. The value zero is reserved to
 represent the default texture for each texture target. Texture names
 and the corresponding texture contents are local to the shared object
 space of the current GL rendering context.</P>
<P> You may use <A class="citerefentry" href="#glGenTextures">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenTextures</A> to generate a set of new texture names.</P>
<P> When a texture is first bound, it assumes the specified target: A
 texture first bound to <CODE class="constant">GL_TEXTURE_2D</CODE>
 becomes a two-dimensional texture and a texture first bound to <CODE class="constant">
GL_TEXTURE_CUBE_MAP</CODE> becomes a cube-mapped texture. The state of a
 two-dimensional texture immediately after it is first bound is
 equivalent to the state of the default <CODE class="constant">
GL_TEXTURE_2D</CODE> at GL initialization, and similarly for cube-mapped
 textures.</P>
<P> While a texture is bound, GL operations on the target to which it is
 bound affect the bound texture, and queries of the target to which it
 is bound return state from the bound texture. In effect, the texture
 targets become aliases for the textures currently bound to them, and
 the texture name zero refers to the default textures that were bound to
 them at initialization.</P>
<P> A texture binding created with <CODE class="function">glBindTexture</CODE>
 remains active until a different texture is bound to the same target,
 or until the bound texture is deleted with <A class="citerefentry" href="#glDeleteTextures">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteTextures</A>.</P>
<P> Once created, a named texture may be re-bound to its same original
 target as often as needed. It is usually much faster to use <CODE class="function">
glBindTexture</CODE> to bind an existing named texture to one of the
 texture targets than it is to reload the texture image using <A class="citerefentry"
href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>.</P>
</DIV><DIV class="refsect1"  title="Errors"><A id="errors"></A>
<H2><A NAME="0_2698">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not one of the allowable values.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM
class="parameter"> <CODE>texture</CODE></EM> was previously created with
 a target that doesn't match that of<EM class="parameter"> <CODE>target</CODE>
</EM>.</P>
</DIV><DIV class="refsect1"  title="Associated Gets"><A id="associatedgets">
</A>
<H2><A NAME="0_2699">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_TEXTURE_BINDING_2D</CODE>
 or <CODE class="constant">GL_TEXTURE_BINDING_CUBE_MAP</CODE></P>
</DIV><DIV class="refsect1"  title="See Also"><A id="seealso"></A>
<H2><A NAME="0_2700">See Also</A></H2>
<P> <A class="citerefentry" href="#glDeleteTextures">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteTextures</A>, <A class="citerefentry" href="#glGenTextures">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenTextures</A>, <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A>, <A class="citerefentry" href="#glGetTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetTexParameter</A>, <A class="citerefentry" href="#glIsTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsTexture</A>, <A class="citerefentry" href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glBlendColor"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2702">Name</A></H2>
<P>glBlendColor -- set the blend color</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2703">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glBlendColor</B>(</CODE>
</TD><TD>GLclampf<VAR class="pdparam"> red</VAR>,</TD></TR>
<TR><TD></TD><TD>GLclampf<VAR class="pdparam"> green</VAR>,</TD></TR>
<TR><TD></TD><TD>GLclampf<VAR class="pdparam"> blue</VAR>,</TD></TR>
<TR><TD></TD><TD>GLclampf<VAR class="pdparam"> alpha</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2704">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>red</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>green</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>blue</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>alpha</CODE></EM></DT>
<DD>
<P> specify the components of <CODE class="constant">GL_BLEND_COLOR</CODE>
</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2705">Description</A></H2>
<P> The <CODE class="constant">GL_BLEND_COLOR</CODE> may be used to
 calculate the source and destination blending factors. The color
 components are clamped to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 before being stored. See <A class="citerefentry" href="#glBlendFunc">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A> for a complete description of the blending operations.
 Initially the <CODE class="constant">GL_BLEND_COLOR</CODE> is set to
 (0, 0, 0, 0).</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2706">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with an argument of <CODE class="constant">GL_BLEND_COLOR</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2707">See Also</A></H2>
<P> <A class="citerefentry" href="#glBlendEquation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquation</A>, <A class="citerefentry" href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A>, <A class="citerefentry" href="#glGetString">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetString</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glBlendEquation"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2709">Name</A></H2>
<P>glBlendEquation -- specify the equation used for both the RGB blend
 equation and the Alpha blend equation</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2710">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glBlendEquation</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> mode</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2711">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>mode</CODE></EM></DT>
<DD>
<P> specifies how source and destination colors are combined. It must be
 <CODE class="constant">GL_FUNC_ADD</CODE>, <CODE class="constant">
GL_FUNC_SUBTRACT</CODE>, or <CODE class="constant">
GL_FUNC_REVERSE_SUBTRACT</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2712">Description</A></H2>
<P> The blend equations determine how a new pixel (the ''source'' color)
 is combined with a pixel already in the framebuffer (the
 ''destination'' color). This function sets both the RGB blend equation
 and the alpha blend equation to a single equation.</P>
<P> These equations use the source and destination blend factors
 specified by either <A class="citerefentry" href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A> or <A class="citerefentry" href="#glBlendFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFuncSeparate</A>. See <A class="citerefentry" href="#glBlendFunc">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A> or <A class="citerefentry" href="#glBlendFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFuncSeparate</A> for a description of the various blend factors.</P>
<P> In the equations that follow, source and destination color
 components are referred to as
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d , respectively. The result color is referred to as
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 r
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 r
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 r
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 r . The source and destination blend factors are denoted
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A , respectively. For these equations all color components are
 understood to have values in the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 .</P>
<DIV class="informaltable">
<TABLE border="1"><COLGROUP><COL align="left"></COL><COL align="left"></COL><COL
align="left"></COL></COLGROUP><THEAD></THEAD>
<TR><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG> Mode</STRONG></TH><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG> RGB Components</STRONG></TH><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG> Alpha Component</STRONG></TH></TR>
<TBODY></TBODY>
<TR><TD align="left"> <CODE class="constant">GL_FUNC_ADD</CODE></TD><TD align="left">
<DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Rr
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mo-->
 +
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R</DIV><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Gr
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mo-->
 +
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G</DIV><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Br
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mo-->
 +
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B</DIV></TD><TD align="left"><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Ar
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mo-->
 +
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</DIV></TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_FUNC_SUBTRACT</CODE></TD><TD
align="left"><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Rr
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R</DIV><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Gr
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G</DIV><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Br
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B</DIV></TD><TD align="left"><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Ar
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</DIV></TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_FUNC_REVERSE_SUBTRACT</CODE>
</TD><TD align="left"><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Rr
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R</DIV><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Gr
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G</DIV><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Br
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B</DIV></TD><TD align="left"><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Ar
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</DIV></TD></TR>
</TABLE>
</DIV>
<P></P>
<P> The results of these equations are clamped to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 .</P>
<P> The <CODE class="constant">GL_FUNC_ADD</CODE> equation is useful for
 antialiasing and transparency, among other things.</P>
<P> Initially, both the RGB blend equation and the alpha blend equation
 are set to <CODE class="constant">GL_FUNC_ADD</CODE>.</P>
<P></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2713">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>mode</CODE></EM> is not one of <CODE class="constant">GL_FUNC_ADD</CODE>
, <CODE class="constant">GL_FUNC_SUBTRACT</CODE>, or <CODE class="constant">
GL_FUNC_REVERSE_SUBTRACT</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2714">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with an argument of <CODE class="constant">
GL_BLEND_EQUATION_RGB</CODE></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with an argument of <CODE class="constant">
GL_BLEND_EQUATION_ALPHA</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2715">See Also</A></H2>
<P> <A class="citerefentry" href="#glGetString">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetString</A>, <A class="citerefentry" href="#glBlendColor">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendColor</A>, <A class="citerefentry" href="#glBlendEquationSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquationSeparate</A>, <A class="citerefentry" href="#glBlendFunc">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A> <A class="citerefentry" href="#glBlendFuncSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFuncSeparate</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glBlendEquationSeparate">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2717">Name</A></H2>
<P>glBlendEquationSeparate -- set the RGB blend equation and the alpha
 blend equation separately</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2718">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glBlendEquationSeparate</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 modeRGB</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> modeAlpha</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2719">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>modeRGB</CODE></EM></DT>
<DD>
<P> specifies the RGB blend equation, how the red, green, and blue
 components of the source and destination colors are combined. It must
 be <CODE class="constant">GL_FUNC_ADD</CODE>, <CODE class="constant">
GL_FUNC_SUBTRACT</CODE>, or <CODE class="constant">
GL_FUNC_REVERSE_SUBTRACT</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>modeAlpha</CODE></EM></DT>
<DD>
<P> specifies the alpha blend equation, how the alpha component of the
 source and destination colors are combined. It must be <CODE class="constant">
GL_FUNC_ADD</CODE>, <CODE class="constant">GL_FUNC_SUBTRACT</CODE>, or <CODE
class="constant">GL_FUNC_REVERSE_SUBTRACT</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2720">Description</A></H2>
<P> The blend equations determines how a new pixel (the ''source''
 color) is combined with a pixel already in the framebuffer (the
 ''destination'' color). This function specifies one blend equation for
 the RGB-color components and one blend equation for the alpha
 component.</P>
<P> The blend equations use the source and destination blend factors
 specified by either <A class="citerefentry" href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A> or <A class="citerefentry" href="#glBlendFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFuncSeparate</A>. See <A class="citerefentry" href="#glBlendFunc">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A> or <A class="citerefentry" href="#glBlendFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFuncSeparate</A> for a description of the various blend factors.</P>
<P> In the equations that follow, source and destination color
 components are referred to as
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d , respectively. The result color is referred to as
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 r
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 r
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 r
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 r . The source and destination blend factors are denoted
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A , respectively. For these equations all color components are
 understood to have values in the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 .</P>
<DIV class="informaltable">
<TABLE border="1"><COLGROUP><COL align="left"></COL><COL align="left"></COL><COL
align="left"></COL></COLGROUP><THEAD></THEAD>
<TR><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG> Mode</STRONG></TH><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG> RGB Components</STRONG></TH><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG> Alpha Component</STRONG></TH></TR>
<TBODY></TBODY>
<TR><TD align="left"> <CODE class="constant">GL_FUNC_ADD</CODE></TD><TD align="left">
<DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Rr
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mo-->
 +
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R</DIV><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Gr
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mo-->
 +
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G</DIV><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Br
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mo-->
 +
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B</DIV></TD><TD align="left"><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Ar
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mo-->
 +
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</DIV></TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_FUNC_SUBTRACT</CODE></TD><TD
align="left"><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Rr
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R</DIV><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Gr
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G</DIV><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Br
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B</DIV></TD><TD align="left"><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Ar
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</DIV></TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_FUNC_REVERSE_SUBTRACT</CODE>
</TD><TD align="left"><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Rr
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R</DIV><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Gr
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G</DIV><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Br
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B</DIV></TD><TD align="left"><DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 Ar
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mo-->
 &acirc;&cent;
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</DIV></TD></TR>
</TABLE>
</DIV>
<P></P>
<P> The results of these equations are clamped to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 .</P>
<P> The <CODE class="constant">GL_FUNC_ADD</CODE> equation is useful for
 antialiasing and transparency, among other things.</P>
<P> Initially, both the RGB blend equation and the alpha blend equation
 are set to <CODE class="constant">GL_FUNC_ADD</CODE>.</P>
<P></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2721">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if either<EM
class="parameter"> <CODE>modeRGB</CODE></EM> or<EM class="parameter"> <CODE>
modeAlpha</CODE></EM> is not one of <CODE class="constant">GL_FUNC_ADD</CODE>
, <CODE class="constant">GL_FUNC_SUBTRACT</CODE>, or <CODE class="constant">
GL_FUNC_REVERSE_SUBTRACT</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2722">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with an argument of <CODE class="constant">
GL_BLEND_EQUATION_RGB</CODE></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with an argument of <CODE class="constant">
GL_BLEND_EQUATION_ALPHA</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2723">See Also</A></H2>
<P> <A class="citerefentry" href="#glGetString">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetString</A>, <A class="citerefentry" href="#glBlendColor">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendColor</A>, <A class="citerefentry" href="#glBlendEquation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquation</A>, <A class="citerefentry" href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A>, <A class="citerefentry" href="#glBlendFuncSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFuncSeparate</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glBlendFunc"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2725">Name</A></H2>
<P>glBlendFunc -- specify pixel arithmetic</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2726">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glBlendFunc</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> sfactor</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> dfactor</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2727">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>sfactor</CODE></EM></DT>
<DD>
<P> Specifies how the red, green, blue, and alpha source blending
 factors are computed. The following symbolic constants are accepted: <CODE
class="constant">GL_ZERO</CODE>, <CODE class="constant">GL_ONE</CODE>, <CODE
class="constant">GL_SRC_COLOR</CODE>, <CODE class="constant">
GL_ONE_MINUS_SRC_COLOR</CODE>, <CODE class="constant">GL_DST_COLOR</CODE>
, <CODE class="constant">GL_ONE_MINUS_DST_COLOR</CODE>, <CODE class="constant">
GL_SRC_ALPHA</CODE>, <CODE class="constant">GL_ONE_MINUS_SRC_ALPHA</CODE>
, <CODE class="constant">GL_DST_ALPHA</CODE>, <CODE class="constant">
GL_ONE_MINUS_DST_ALPHA</CODE>, <CODE class="constant">GL_CONSTANT_COLOR</CODE>
, <CODE class="constant">GL_ONE_MINUS_CONSTANT_COLOR</CODE>, <CODE class="constant">
GL_CONSTANT_ALPHA</CODE>, <CODE class="constant">
GL_ONE_MINUS_CONSTANT_ALPHA</CODE>, and <CODE class="constant">
GL_SRC_ALPHA_SATURATE</CODE>. The initial value is <CODE class="constant">
GL_ONE</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>dfactor</CODE></EM></DT>
<DD>
<P> Specifies how the red, green, blue, and alpha destination blending
 factors are computed. The following symbolic constants are accepted: <CODE
class="constant">GL_ZERO</CODE>, <CODE class="constant">GL_ONE</CODE>, <CODE
class="constant">GL_SRC_COLOR</CODE>, <CODE class="constant">
GL_ONE_MINUS_SRC_COLOR</CODE>, <CODE class="constant">GL_DST_COLOR</CODE>
, <CODE class="constant">GL_ONE_MINUS_DST_COLOR</CODE>, <CODE class="constant">
GL_SRC_ALPHA</CODE>, <CODE class="constant">GL_ONE_MINUS_SRC_ALPHA</CODE>
, <CODE class="constant">GL_DST_ALPHA</CODE>, <CODE class="constant">
GL_ONE_MINUS_DST_ALPHA</CODE>. <CODE class="constant">GL_CONSTANT_COLOR</CODE>
, <CODE class="constant">GL_ONE_MINUS_CONSTANT_COLOR</CODE>, <CODE class="constant">
GL_CONSTANT_ALPHA</CODE>, and <CODE class="constant">
GL_ONE_MINUS_CONSTANT_ALPHA</CODE>. The initial value is <CODE class="constant">
GL_ZERO</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2728">Description</A></H2>
<P> Pixels can be drawn using a function that blends the incoming
 (source) RGBA values with the RGBA values that are already in the frame
 buffer (the destination values). Blending is initially disabled. Use <A class="citerefentry"
href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A> and <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisable</A> with argument <CODE class="constant">GL_BLEND</CODE> to
 enable and disable blending.</P>
<P> <CODE class="function">glBlendFunc</CODE> defines the operation of
 blending when it is enabled.<EM class="parameter"> <CODE>sfactor</CODE></EM>
 specifies which method is used to scale the source color components.<EM class="parameter">
 <CODE>dfactor</CODE></EM> specifies which method is used to scale the
 destination color components. The possible methods are described in the
 following table. Each method defines four scale factors, one each for
 red, green, blue, and alpha. In the table and in subsequent equations,
 source and destination color components are referred to as
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d . The color specified by <A class="citerefentry" href="#glBlendColor">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendColor</A> is referred to as
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c . They are understood to have integer values between 0 and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A , where</P>
<P></P>
<P>
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mfenced open=&quot;&quot; close=&quot;&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 m
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:mo-->
 -
<!--mml:mn-->
 1</P>
<P></P>
<P> and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 m
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 m
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 m
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 m
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A is the number of red, green, blue, and alpha bitplanes.</P>
<P> Source and destination scale factors are referred to as
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A . The scale factors described in the table, denoted
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 f
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 f
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 f
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 f
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A , represent either source or destination factors. All scale factors
 have range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 .</P>
<P></P>
<DIV class="informaltable">
<TABLE border="1"><COLGROUP><COL align="left"></COL><COL align="left"></COL>
</COLGROUP><THEAD></THEAD>
<TR><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG> Parameter</STRONG></TH><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG>
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 f
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 f
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 f
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 f
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</STRONG></TH></TR>
<TBODY></TBODY>
<TR><TD align="left"> <CODE class="constant">GL_ZERO</CODE></TD><TD align="left">

<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 0
<!--mml:mn-->
 0
<!--mml:mn-->
 0</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE</CODE></TD><TD align="left">

<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_SRC_COLOR</CODE></TD><TD align="left">

<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE_MINUS_SRC_COLOR</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_DST_COLOR</CODE></TD><TD align="left">

<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE_MINUS_DST_COLOR</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_SRC_ALPHA</CODE></TD><TD align="left">

<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE_MINUS_SRC_ALPHA</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_DST_ALPHA</CODE></TD><TD align="left">

<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE_MINUS_DST_ALPHA</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_CONSTANT_COLOR</CODE></TD><TD
align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE_MINUS_CONSTANT_COLOR</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_CONSTANT_ALPHA</CODE></TD><TD
align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE_MINUS_CONSTANT_ALPHA</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_SRC_ALPHA_SATURATE</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 i
<!--mml:mi mathvariant=&quot;italic&quot;-->
 i
<!--mml:mi mathvariant=&quot;italic&quot;-->
 i
<!--mml:mn-->
 1</TD></TR>
</TABLE>
</DIV>
<P> In the table,</P>
<P></P>
<P>
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 i
<!--mml:mo-->
 =
<!--mml:mfrac-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 min
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</P>
<P></P>
<P> To determine the blended RGBA values of a pixel, the system uses one
 of the equations set by <A class="citerefentry" href="#glBlendEquation">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquation</A> or <A class="citerefentry" href="#glBlendEquationSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquationSeparate</A>.</P>
<P> Blending arithmetic is not exactly specified, because blending
 operates with imprecise integer color values. However, a blend factor
 that should be equal to 1 is guaranteed not to modify its multiplicand,
 and a blend factor equal to 0 reduces its multiplicand to 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2729">Notes</A></H2>
<P> Incoming (source) alpha is correctly thought of as a material
 opacity, ranging from 1.0 (
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 K
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A ), representing complete opacity, to 0.0 (0), representing complete
 transparency.</P>
<P> Transparency is best implemented using blend function (<CODE class="constant">
GL_SRC_ALPHA</CODE>, <CODE class="constant">GL_ONE_MINUS_SRC_ALPHA</CODE>
) with primitives sorted from farthest to nearest. Note that this
 transparency calculation does not require the presence of alpha
 bitplanes in the frame buffer.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2730">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if either<EM
class="parameter"> <CODE>sfactor</CODE></EM> or<EM class="parameter"> <CODE>
dfactor</CODE></EM> is not an accepted value.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2731">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_BLEND_SRC_RGB</CODE>
 or <CODE class="constant">GL_BLEND_SRC_ALPHA</CODE></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_BLEND_DST_RGB</CODE>
 or <CODE class="constant">GL_BLEND_DST_ALPHA</CODE></P>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> with argument <CODE class="constant">GL_BLEND</CODE></P>
<P></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2732">See Also</A></H2>
<P> <A class="citerefentry" href="#glBlendColor">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendColor</A>, <A class="citerefentry" href="#glBlendEquation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquation</A>, <A class="citerefentry" href="#glBlendEquationSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquationSeparate</A>, <A class="citerefentry" href="#glBlendFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFuncSeparate</A>, <A class="citerefentry" href="#glClear">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClear</A>, <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A>, <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glBlendFuncSeparate">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2734">Name</A></H2>
<P>glBlendFuncSeparate -- specify pixel arithmetic for RGB and alpha
 components separately</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2735">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glBlendFuncSeparate</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> srcRGB</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> dstRGB</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> srcAlpha</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> dstAlpha</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2736">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>srcRGB</CODE></EM></DT>
<DD>
<P> Specifies how the red, green, and blue blending factors are
 computed. The following symbolic constants are accepted: <CODE class="constant">
GL_ZERO</CODE>, <CODE class="constant">GL_ONE</CODE>, <CODE class="constant">
GL_SRC_COLOR</CODE>, <CODE class="constant">GL_ONE_MINUS_SRC_COLOR</CODE>
, <CODE class="constant">GL_DST_COLOR</CODE>, <CODE class="constant">
GL_ONE_MINUS_DST_COLOR</CODE>, <CODE class="constant">GL_SRC_ALPHA</CODE>
, <CODE class="constant">GL_ONE_MINUS_SRC_ALPHA</CODE>, <CODE class="constant">
GL_DST_ALPHA</CODE>, <CODE class="constant">GL_ONE_MINUS_DST_ALPHA</CODE>
, <CODE class="constant">GL_CONSTANT_COLOR</CODE>, <CODE class="constant">
GL_ONE_MINUS_CONSTANT_COLOR</CODE>, <CODE class="constant">
GL_CONSTANT_ALPHA</CODE>, <CODE class="constant">
GL_ONE_MINUS_CONSTANT_ALPHA</CODE>, and <CODE class="constant">
GL_SRC_ALPHA_SATURATE</CODE>. The initial value is <CODE class="constant">
GL_ONE</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>dstRGB</CODE></EM></DT>
<DD>
<P> Specifies how the red, green, and blue destination blending factors
 are computed. The following symbolic constants are accepted: <CODE class="constant">
GL_ZERO</CODE>, <CODE class="constant">GL_ONE</CODE>, <CODE class="constant">
GL_SRC_COLOR</CODE>, <CODE class="constant">GL_ONE_MINUS_SRC_COLOR</CODE>
, <CODE class="constant">GL_DST_COLOR</CODE>, <CODE class="constant">
GL_ONE_MINUS_DST_COLOR</CODE>, <CODE class="constant">GL_SRC_ALPHA</CODE>
, <CODE class="constant">GL_ONE_MINUS_SRC_ALPHA</CODE>, <CODE class="constant">
GL_DST_ALPHA</CODE>, <CODE class="constant">GL_ONE_MINUS_DST_ALPHA</CODE>
. <CODE class="constant">GL_CONSTANT_COLOR</CODE>, <CODE class="constant">
GL_ONE_MINUS_CONSTANT_COLOR</CODE>, <CODE class="constant">
GL_CONSTANT_ALPHA</CODE>, and <CODE class="constant">
GL_ONE_MINUS_CONSTANT_ALPHA</CODE>. The initial value is <CODE class="constant">
GL_ZERO</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>srcAlpha</CODE></EM></DT>
<DD>
<P> Specified how the alpha source blending factor is computed. The same
 symbolic constants are accepted as for<EM class="parameter"> <CODE>
srcRGB</CODE></EM>. The initial value is <CODE class="constant">GL_ONE</CODE>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>dstAlpha</CODE></EM></DT>
<DD>
<P> Specified how the alpha destination blending factor is computed. The
 same symbolic constants are accepted as for<EM class="parameter"> <CODE>
dstRGB</CODE></EM>. The initial value is <CODE class="constant">GL_ZERO</CODE>
.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2737">Description</A></H2>
<P> Pixels can be drawn using a function that blends the incoming
 (source) RGBA values with the RGBA values that are already in the frame
 buffer (the destination values). Blending is initially disabled. Use <A class="citerefentry"
href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A> and <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisable</A> with argument <CODE class="constant">GL_BLEND</CODE> to
 enable and disable blending.</P>
<P> <CODE class="function">glBlendFuncSeparate</CODE> defines the
 operation of blending when it is enabled.<EM class="parameter"> <CODE>
srcRGB</CODE></EM> specifies which method is used to scale the source
 RGB-color components.<EM class="parameter"> <CODE>dstRGB</CODE></EM>
 specifies which method is used to scale the destination RGB-color
 components. Likewise,<EM class="parameter"> <CODE>srcAlpha</CODE></EM>
 specifies which method is used to scale the source alpha color
 component, and<EM class="parameter"> <CODE>dstAlpha</CODE></EM>
 specifies which method is used to scale the destination alpha
 component. The possible methods are described in the following table.
 Each method defines four scale factors, one each for red, green, blue,
 and alpha.</P>
<P> In the table and in subsequent equations, source and destination
 color components are referred to as
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d . The color specified by <A class="citerefentry" href="#glBlendColor">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendColor</A> is referred to as
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c . They are understood to have integer values between 0 and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A , where</P>
<P></P>
<P>
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mfenced open=&quot;&quot; close=&quot;&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 m
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:mo-->
 -
<!--mml:mn-->
 1</P>
<P></P>
<P> and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 m
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 m
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 m
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 m
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A is the number of red, green, blue, and alpha bitplanes.</P>
<P> Source and destination scale factors are referred to as
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A . All scale factors have range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 .</P>
<P></P>
<DIV class="informaltable">
<TABLE border="1"><COLGROUP><COL align="left"></COL><COL align="left"></COL><COL
align="left"></COL></COLGROUP><THEAD></THEAD>
<TR><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG> Parameter</STRONG></TH><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG> RGB Factor</STRONG></TH><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG> Alpha Factor</STRONG></TH></TR>
<TBODY></TBODY>
<TR><TD align="left"> <CODE class="constant">GL_ZERO</CODE></TD><TD align="left">

<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 0
<!--mml:mn-->
 0</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mn-->
 0</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE</CODE></TD><TD align="left">

<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mn-->
 1</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_SRC_COLOR</CODE></TD><TD align="left">

<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE_MINUS_SRC_COLOR</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_DST_COLOR</CODE></TD><TD align="left">

<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE_MINUS_DST_COLOR</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 B</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_SRC_ALPHA</CODE></TD><TD align="left">

<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE_MINUS_SRC_ALPHA</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_DST_ALPHA</CODE></TD><TD align="left">

<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE_MINUS_DST_ALPHA</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfrac-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 k
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_CONSTANT_COLOR</CODE></TD><TD
align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE_MINUS_CONSTANT_COLOR</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 R
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 G
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 B
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_CONSTANT_ALPHA</CODE></TD><TD
align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_ONE_MINUS_CONSTANT_ALPHA</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 c</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_SRC_ALPHA_SATURATE</CODE>
</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 i
<!--mml:mi mathvariant=&quot;italic&quot;-->
 i
<!--mml:mi mathvariant=&quot;italic&quot;-->
 i</TD><TD align="left">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mn-->
 1</TD></TR>
</TABLE>
</DIV>
<P> In the table,</P>
<P></P>
<P>
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 i
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 min
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 s
<!--mml:mrow-->

<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;&quot; close=&quot;&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 A
<!--mml:mi mathvariant=&quot;italic&quot;-->
 d</P>
<P></P>
<P> To determine the blended RGBA values of a pixel, the system uses one
 of the equations set by <A class="citerefentry" href="#glBlendEquation">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquation</A> or <A class="citerefentry" href="#glBlendEquationSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquationSeparate</A>.</P>
<P> Despite the apparent precision of the above equations, blending
 arithmetic is not exactly specified, because blending operates with
 imprecise integer color values. However, a blend factor that should be
 equal to 1 is guaranteed not to modify its multiplicand, and a blend
 factor equal to 0 reduces its multiplicand to 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2738">Notes</A></H2>
<P> Incoming (source) alpha is correctly thought of as a material
 opacity, ranging from 1.0 (
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 K
<!--mml:mi mathvariant=&quot;italic&quot;-->
 A ), representing complete opacity, to 0.0 (0), representing complete
 transparency.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2739">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>srcRGB</CODE></EM>,<EM class="parameter"> <CODE>dstRGB</CODE></EM>
,<EM class="parameter"> <CODE>srcAlpha</CODE></EM>, or<EM class="parameter">
 <CODE>dstAlpha</CODE></EM> is not an accepted value.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2740">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_BLEND_SRC_RGB</CODE></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_BLEND_SRC_ALPHA</CODE></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_BLEND_DST_RGB</CODE></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_BLEND_DST_ALPHA</CODE></P>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> with argument <CODE class="constant">GL_BLEND</CODE></P>
<P></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2741">See Also</A></H2>
<P> <A class="citerefentry" href="#glBlendColor">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendColor</A>, <A class="citerefentry" href="#glBlendEquation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquation</A>, <A class="citerefentry" href="#glBlendEquationSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquationSeparate</A>, <A class="citerefentry" href="#glBlendFunc">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A>, <A class="citerefentry" href="#glClear">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClear</A>, <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A>, <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glBufferData"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2743">Name</A></H2>
<P>glBufferData -- create and initialize a buffer object's data store</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2744">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glBufferData</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizeiptr<VAR class="pdparam"> size</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLvoid *<VAR class="pdparam"> data</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> usage</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2745">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target buffer object. The symbolic constant must be <CODE
class="constant">GL_ARRAY_BUFFER</CODE> or <CODE class="constant">
GL_ELEMENT_ARRAY_BUFFER</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>size</CODE></EM></DT>
<DD>
<P> Specifies the size in bytes of the buffer object's new data store.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>data</CODE></EM></DT>
<DD>
<P> Specifies a pointer to data that will be copied into the data store
 for initialization, or <CODE class="constant">NULL</CODE> if no data is
 to be copied.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>usage</CODE></EM></DT>
<DD>
<P> Specifies the expected usage pattern of the data store. The symbolic
 constant must be <CODE class="constant">GL_STREAM_DRAW</CODE>, <CODE class="constant">
GL_STATIC_DRAW</CODE>, or <CODE class="constant">GL_DYNAMIC_DRAW</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2746">Description</A></H2>
<P> <CODE class="function">glBufferData</CODE> creates a new data store
 for the buffer object currently bound to<EM class="parameter"> <CODE>
target</CODE></EM>. Any pre-existing data store is deleted. The new data
 store is created with the specified<EM class="parameter"> <CODE>size</CODE>
</EM> in bytes and<EM class="parameter"> <CODE>usage</CODE></EM>. If<EM class="parameter">
 <CODE>data</CODE></EM> is not <CODE class="constant">NULL</CODE>, the
 data store is initialized with data from this pointer.</P>
<P><EM class="parameter"> <CODE>usage</CODE></EM> is a hint to the GL
 implementation as to how a buffer object's data store will be accessed.
 This enables the GL implementation to make more intelligent decisions
 that may significantly impact buffer object performance. It does not,
 however, constrain the actual usage of the data store.<EM class="parameter">
 <CODE>usage</CODE></EM> can be broken down into two parts: first, the
 frequency of access (modification and usage), and second, the nature of
 that access. The frequency of access may be one of these:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
STREAM</DT>
<DD>
<P> The data store contents will be modified once and used at most a few
 times.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
STATIC</DT>
<DD>
<P> The data store contents will be modified once and used many times.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
DYNAMIC</DT>
<DD>
<P> The data store contents will be modified repeatedly and used many
 times.</P>
</DD>
</DL>
</DIV>
<P> The nature of access must be:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
DRAW</DT>
<DD>
<P> The data store contents are modified by the application, and used as
 the source for GL drawing and image specification commands.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2747">Notes</A></H2>
<P> If<EM class="parameter"> <CODE>data</CODE></EM> is <CODE class="constant">
NULL</CODE>, a data store of the specified size is still created, but
 its contents remain uninitialized and thus undefined.</P>
<P> Clients must align data elements consistent with the requirements of
 the client platform, with an additional base-level requirement that an
 offset within a buffer to a datum comprising
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 N be a multiple of
<!--mml:mi mathvariant=&quot;italic&quot;-->
 N.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2748">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_ARRAY_BUFFER</CODE>
 or <CODE class="constant">GL_ELEMENT_ARRAY_BUFFER</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>usage</CODE></EM> is not <CODE class="constant">GL_STREAM_DRAW</CODE>
, <CODE class="constant">GL_STATIC_DRAW</CODE>, or <CODE class="constant">
GL_DYNAMIC_DRAW</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>size</CODE></EM> is negative.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the reserved buffer object name 0 is bound to<EM class="parameter"> <CODE>
target</CODE></EM>.</P>
<P> <CODE class="constant">GL_OUT_OF_MEMORY</CODE> is generated if the
 GL is unable to create a data store with the specified<EM class="parameter">
 <CODE>size</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2749">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGetBufferParameteriv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetBufferParameteriv</A> with argument <CODE class="constant">
GL_BUFFER_SIZE</CODE> or <CODE class="constant">GL_BUFFER_USAGE</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2750">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>, <A class="citerefentry" href="#glBufferSubData">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBufferSubData</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glBufferSubData"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2752">Name</A></H2>
<P>glBufferSubData -- update a subset of a buffer object's data store</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2753">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glBufferSubData</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLintptr<VAR class="pdparam"> offset</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizeiptr<VAR class="pdparam"> size</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLvoid *<VAR class="pdparam"> data</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2754">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target buffer object. The symbolic constant must be <CODE
class="constant">GL_ARRAY_BUFFER</CODE> or <CODE class="constant">
GL_ELEMENT_ARRAY_BUFFER</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>offset</CODE></EM></DT>
<DD>
<P> Specifies the offset into the buffer object's data store where data
 replacement will begin, measured in bytes.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>size</CODE></EM></DT>
<DD>
<P> Specifies the size in bytes of the data store region being replaced.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>data</CODE></EM></DT>
<DD>
<P> Specifies a pointer to the new data that will be copied into the
 data store.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2755">Description</A></H2>
<P> <CODE class="function">glBufferSubData</CODE> redefines some or all
 of the data store for the buffer object currently bound to<EM class="parameter">
 <CODE>target</CODE></EM>. Data starting at byte offset<EM class="parameter">
 <CODE>offset</CODE></EM> and extending for<EM class="parameter"> <CODE>
size</CODE></EM> bytes is copied to the data store from the memory
 pointed to by<EM class="parameter"> <CODE>data</CODE></EM>. An error is
 thrown if<EM class="parameter"> <CODE>offset</CODE></EM> and<EM class="parameter">
 <CODE>size</CODE></EM> together define a range beyond the bounds of the
 buffer object's data store.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2756">Notes</A></H2>
<P> When replacing the entire data store, consider using <CODE class="function">
glBufferSubData</CODE> rather than completely recreating the data store
 with <CODE class="function">glBufferData</CODE>. This avoids the cost
 of reallocating the data store.</P>
<P> Consider using multiple buffer objects to avoid stalling the
 rendering pipeline during data store updates. If any rendering in the
 pipeline makes reference to data in the buffer object being updated by <CODE
class="function">glBufferSubData</CODE>, especially from the specific
 region being updated, that rendering must drain from the pipeline
 before the data store can be updated.</P>
<P> Clients must align data elements consistent with the requirements of
 the client platform, with an additional base-level requirement that an
 offset within a buffer to a datum comprising
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 N be a multiple of
<!--mml:mi mathvariant=&quot;italic&quot;-->
 N.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2757">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_ARRAY_BUFFER</CODE>
 or <CODE class="constant">GL_ELEMENT_ARRAY_BUFFER</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>offset</CODE></EM> or<EM class="parameter"> <CODE>size</CODE></EM>
 is negative, or if together they define a region of memory that extends
 beyond the buffer object's allocated data store.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the reserved buffer object name 0 is bound to<EM class="parameter"> <CODE>
target</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2758">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>, <A class="citerefentry" href="#glBufferData">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBufferData</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" title="glCheckFramebufferStatus"><A id="glCheckFramebufferStatus">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2760">Name</A></H2>
<P>glCheckFramebufferStatus -- return the framebuffer completeness
 status of a framebuffer object</P>
</DIV><DIV class="refsynopsisdiv" title="C Specification">
<H2><A NAME="0_2761">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLenum<B class="fsfunc">
 glCheckFramebufferStatus</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 target</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
title="Parameters"><A id="parameters"></A>
<H2><A NAME="0_2762">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target framebuffer object. The symbolic constant must
 be <CODE class="constant">GL_FRAMEBUFFER</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  title="Description"><A id="description">
</A>
<H2><A NAME="0_2763">Description</A></H2>
<P> <CODE class="function">glCheckFramebufferStatus</CODE> returns a
 symbolic constant that identifies whether or not the currently bound
 framebuffer is framebuffer complete, and if not, which of the rules of
 framebuffer completeness is violated.</P>
<P> If the framebuffer is complete, then <CODE class="constant">
GL_FRAMEBUFFER_COMPLETE</CODE> is returned. If the framebuffer is not
 complete, the return values are as follows:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT</CODE></DT>
<DD>
<P> Not all framebuffer attachment points are framebuffer attachment
 complete. This means that at least one attachment point with a
 renderbuffer or texture attached has its attached object no longer in
 existence or has an attached image with a width or height of zero, or
 the color attachment point has a non-color-renderable image attached,
 or the depth attachment point has a non-depth-renderable image
 attached, or the stencil attachment point has a non-stencil-renderable
 image attached.</P>
<P> Color-renderable formats include <CODE class="constant">GL_RGBA4</CODE>
, <CODE class="constant">GL_RGB5_A1</CODE>, and <CODE class="constant">
GL_RGB565</CODE>. <CODE class="constant">GL_DEPTH_COMPONENT16</CODE> is
 the only depth-renderable format. <CODE class="constant">
GL_STENCIL_INDEX8</CODE> is the only stencil-renderable format.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS</CODE></DT>
<DD>
<P> Not all attached images have the same width and height.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT</CODE>
</DT>
<DD>
<P> No images are attached to the framebuffer.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_FRAMEBUFFER_UNSUPPORTED</CODE></DT>
<DD>
<P> The combination of internal formats of the attached images violates
 an implementation-dependent set of restrictions.</P>
</DD>
</DL>
</DIV>
<P> If the currently bound framebuffer is not framebuffer complete, then
 it is an error to attempt to use the framebuffer for writing or
 reading. This means that rendering commands (<A class="citerefentry" href="#glClear">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClear</A>, <A class="citerefentry" href="#glDrawArrays">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawArrays</A>, and <A class="citerefentry" href="#glDrawElements">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawElements</A>) as well as commands that read the framebuffer (<A class="citerefentry"
href="#glReadPixels">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReadPixels</A>, <A class="citerefentry" href="#glCopyTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A>, and <A class="citerefentry" href="#glCopyTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexSubImage2D</A>) will generate the error <CODE class="constant">
GL_INVALID_FRAMEBUFFER_OPERATION</CODE> if called while the framebuffer
 is not framebuffer complete.</P>
</DIV><DIV class="refsect1"  title="Notes"><A id="notes"></A>
<H2><A NAME="0_2764">Notes</A></H2>
<P> It is strongly advised, thought not required, that an application
 call <CODE class="function">glCheckFramebufferStatus</CODE> to see if
 the framebuffer is complete prior to rendering. This is because some
 implementations may not support rendering to particular combinations of
 internal formats. In this case, <CODE class="constant">
GL_FRAMEBUFFER_UNSUPPORTED</CODE> is returned.</P>
<P> The default window-system-provided framebuffer is always framebuffer
 complete, and thus <CODE class="constant">GL_FRAMEBUFFER_COMPLETE</CODE>
 is returned when <CODE class="constant">GL_FRAMEBUFFER_BINDING</CODE>
 is 0.</P>
<P> Additionally, if an error occurs, zero is returned.</P>
</DIV><DIV class="refsect1"  title="Errors"><A id="errors"></A>
<H2><A NAME="0_2765">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_FRAMEBUFFER</CODE>
.</P>
</DIV><DIV class="refsect1"  title="See Also"><A id="seealso"></A>
<H2><A NAME="0_2766">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindRenderbuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindRenderbuffer</A>, <A class="citerefentry" href="#glCopyTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A>, <A class="citerefentry" href="#glCopyTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexSubImage2D</A>, <A class="citerefentry" href="#glDrawArrays">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawArrays</A>, <A class="citerefentry" href="#glDrawElements">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawElements</A>, <A class="citerefentry" href="#glReadPixels">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReadPixels</A>, <A class="citerefentry" href="#glRenderbufferStorage">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glRenderbufferStorage</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glClear"></A><DIV class="titlepage">
</DIV><DIV class="refnamediv">
<H2><A NAME="0_2768">Name</A></H2>
<P>glClear -- clear buffers to preset values</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2769">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glClear</B>(</CODE></TD><TD>
GLbitfield<VAR class="pdparam"> mask</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2770">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>mask</CODE></EM></DT>
<DD>
<P> Bitwise OR of masks that indicate the buffers to be cleared. The
 three masks are <CODE class="constant">GL_COLOR_BUFFER_BIT</CODE>, <CODE
class="constant">GL_DEPTH_BUFFER_BIT</CODE>, and <CODE class="constant">
GL_STENCIL_BUFFER_BIT</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2771">Description</A></H2>
<P> <CODE class="function">glClear</CODE> sets the bitplane area of the
 window to values previously selected by <A class="citerefentry" href="#glClearColor">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClearColor</A>, <A class="citerefentry" href="#glClearDepthf">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClearDepthf</A>, and <A class="citerefentry" href="#glClearStencil">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClearStencil</A>.</P>
<P> The pixel ownership test, the scissor test, dithering, and the
 buffer writemasks affect the operation of <CODE class="function">
glClear</CODE>. The scissor box bounds the cleared region. Blend
 function, stenciling, fragment shading, and depth-buffering are ignored
 by <CODE class="function">glClear</CODE>.</P>
<P> <CODE class="function">glClear</CODE> takes a single argument that
 is the bitwise OR of several values indicating which buffer is to be
 cleared.</P>
<P> The values are as follows:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_COLOR_BUFFER_BIT</CODE></DT>
<DD>
<P> Indicates the buffers currently enabled for color writing.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DEPTH_BUFFER_BIT</CODE></DT>
<DD>
<P> Indicates the depth buffer.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_BUFFER_BIT</CODE></DT>
<DD>
<P> Indicates the stencil buffer.</P>
</DD>
</DL>
</DIV>
<P> The value to which each buffer is cleared depends on the setting of
 the clear value for that buffer.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2772">Notes</A></H2>
<P> If a buffer is not present, then a <CODE class="function">glClear</CODE>
 directed at that buffer has no effect.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2773">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if any
 bit other than the three defined bits is set in<EM class="parameter"> <CODE>
mask</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2774">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_DEPTH_CLEAR_VALUE</CODE>
</P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_COLOR_CLEAR_VALUE</CODE>
</P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_STENCIL_CLEAR_VALUE</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2775">See Also</A></H2>
<P> <A class="citerefentry" href="#glClearColor">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClearColor</A>, <A class="citerefentry" href="#glClearDepthf">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClearDepthf</A>, <A class="citerefentry" href="#glClearStencil">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClearStencil</A>, <A class="citerefentry" href="#glColorMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glColorMask</A>, <A class="citerefentry" href="#glDepthMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthMask</A>, <A class="citerefentry" href="#glScissor">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glScissor</A>, <A class="citerefentry" href="#glStencilMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glClearColor"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2777">Name</A></H2>
<P>glClearColor -- specify clear values for the color buffers</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2778">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glClearColor</B>(</CODE>
</TD><TD>GLclampf<VAR class="pdparam"> red</VAR>,</TD></TR>
<TR><TD></TD><TD>GLclampf<VAR class="pdparam"> green</VAR>,</TD></TR>
<TR><TD></TD><TD>GLclampf<VAR class="pdparam"> blue</VAR>,</TD></TR>
<TR><TD></TD><TD>GLclampf<VAR class="pdparam"> alpha</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2779">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>red</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>green</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>blue</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>alpha</CODE></EM></DT>
<DD>
<P> Specify the red, green, blue, and alpha values used when the color
 buffers are cleared. The initial values are all 0.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2780">Description</A></H2>
<P> <CODE class="function">glClearColor</CODE> specifies the red, green,
 blue, and alpha values used by <A class="citerefentry" href="#glClear">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClear</A> to clear the color buffers. Values specified by <CODE class="function">
glClearColor</CODE> are clamped to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 .</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2781">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_COLOR_CLEAR_VALUE</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2782">See Also</A></H2>
<P> <A class="citerefentry" href="#glClear">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClear</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glClearDepthf"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2784">Name</A></H2>
<P>glClearDepthf -- specify the clear value for the depth buffer</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2785">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glClearDepthf</B>(</CODE>
</TD><TD>GLclampf<VAR class="pdparam"> depth</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2786">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>depth</CODE></EM></DT>
<DD>
<P> Specifies the depth value used when the depth buffer is cleared. The
 initial value is 1.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2787">Description</A></H2>
<P> <CODE class="function">glClearDepthf</CODE> specifies the depth
 value used by <A class="citerefentry" href="#glClear">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClear</A> to clear the depth buffer. Values specified by <CODE class="function">
glClearDepthf</CODE> are clamped to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 .</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2788">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_DEPTH_CLEAR_VALUE</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2789">See Also</A></H2>
<P> <A class="citerefentry" href="#glClear">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClear</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glClearStencil"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2791">Name</A></H2>
<P>glClearStencil -- specify the clear value for the stencil buffer</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2792">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glClearStencil</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> s</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2793">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>s</CODE></EM></DT>
<DD>
<P> Specifies the index used when the stencil buffer is cleared. The
 initial value is 0.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2794">Description</A></H2>
<P> <CODE class="function">glClearStencil</CODE> specifies the index
 used by <A class="citerefentry" href="#glClear">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClear</A> to clear the stencil buffer.<EM class="parameter"> <CODE>s</CODE>
</EM> is masked with
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
 m
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 m is the number of bits in the stencil buffer.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2795">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_STENCIL_CLEAR_VALUE</CODE>
</P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_STENCIL_BITS</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2796">See Also</A></H2>
<P> <A class="citerefentry" href="#glClear">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClear</A>, <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A>, <A class="citerefentry" href="#glStencilFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>, <A class="citerefentry" href="#glStencilMask">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A>, <A class="citerefentry" href="#glStencilMaskSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMaskSeparate</A>, <A class="citerefentry" href="#glStencilOp">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A>, <A class="citerefentry" href="#glStencilOpSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glColorMask"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2798">Name</A></H2>
<P>glColorMask -- enable and disable writing of frame buffer color
 components</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2799">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glColorMask</B>(</CODE>
</TD><TD>GLboolean<VAR class="pdparam"> red</VAR>,</TD></TR>
<TR><TD></TD><TD>GLboolean<VAR class="pdparam"> green</VAR>,</TD></TR>
<TR><TD></TD><TD>GLboolean<VAR class="pdparam"> blue</VAR>,</TD></TR>
<TR><TD></TD><TD>GLboolean<VAR class="pdparam"> alpha</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2800">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>red</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>green</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>blue</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>alpha</CODE></EM></DT>
<DD>
<P> Specify whether red, green, blue, and alpha can or cannot be written
 into the frame buffer. The initial values are all <CODE class="constant">
GL_TRUE</CODE>, indicating that the color components can be written.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2801">Description</A></H2>
<P> <CODE class="function">glColorMask</CODE> specifies whether the
 individual color components in the frame buffer can or cannot be
 written. If<EM class="parameter"> <CODE>red</CODE></EM> is <CODE class="constant">
GL_FALSE</CODE>, for example, no change is made to the red component of
 any pixel in any of the color buffers, regardless of the drawing
 operation attempted.</P>
<P> Changes to individual bits of components cannot be controlled.
 Rather, changes are either enabled or disabled for entire color
 components.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2802">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_COLOR_WRITEMASK</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2803">See Also</A></H2>
<P> <A class="citerefentry" href="#glClear">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClear</A>, <A class="citerefentry" href="#glDepthMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthMask</A>, <A class="citerefentry" href="#glStencilMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glCompileShader"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2805">Name</A></H2>
<P>glCompileShader -- compile a shader object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2806">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glCompileShader</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> shader</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2807">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shader</CODE></EM></DT>
<DD>
<P>Specifies the shader object to be compiled.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2808">Description</A></H2>
<P>For implementations that support a shader compiler, <CODE class="function">
glCompileShader</CODE> compiles the source code strings that have been
 stored in the shader object specified by<EM class="parameter"> <CODE>
shader</CODE></EM>.</P>
<P>The compilation status will be stored as part of the shader object's
 state. This value will be set to <CODE class="constant">GL_TRUE</CODE>
 if the shader was compiled without errors and is ready for use, and <CODE
class="constant">GL_FALSE</CODE> otherwise. It can be queried by calling
 <A class="citerefentry" href="#glGetShaderiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A> with arguments<EM class="parameter"> <CODE>shader</CODE>
</EM> and <CODE class="constant">GL_COMPILE_STATUS</CODE>.</P>
<P>Compilation of a shader can fail for a number of reasons as specified
 by the
<!--span class=&quot;emphasis&quot;-->
<EM> OpenGL ES Shading Language Specification</EM>. Whether or not the
 compilation was successful, information about the compilation can be
 obtained from the shader object's information log by calling <A class="citerefentry"
href="#glGetShaderInfoLog">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderInfoLog</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2809">Notes</A></H2>
<P>Shader compiler support is optional, and thus must be queried before
 use by calling <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SHADER_COMPILER</CODE>
. <A class="citerefentry" href="#glShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A>, <CODE class="function">glCompileShader</CODE>, <A class="citerefentry"
href="#glGetShaderPrecisionFormat">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderPrecisionFormat</A>, and <A class="citerefentry" href="#glReleaseShaderCompiler">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReleaseShaderCompiler</A> will each generate <CODE class="constant">
GL_INVALID_OPERATION</CODE> on implementations that do not support a
 shader compiler. Such implementations instead offer the <A class="citerefentry"
href="#glShaderBinary">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderBinary</A> alternative for supplying a pre-compiled shader
 binary.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2810">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if a
 shader compiler is not supported.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not a shader object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2811">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SHADER_COMPILER</CODE></P>
<P><A class="citerefentry" href="#glGetShaderInfoLog">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderInfoLog</A> with argument<EM class="parameter"> <CODE>shader</CODE>
</EM></P>
<P><A class="citerefentry" href="#glGetShaderiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A> with arguments<EM class="parameter"> <CODE>shader</CODE>
</EM> and <CODE class="constant">GL_COMPILE_STATUS</CODE></P>
<P><A class="citerefentry" href="#glIsShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsShader</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2812">See Also</A></H2>
<P><A class="citerefentry" href="#glCreateShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateShader</A>, <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glReleaseShaderCompiler">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReleaseShaderCompiler</A>, <A class="citerefentry" href="#glShaderSource">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A>, <A class="citerefentry" href="#glGetShaderPrecisionFormat">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderPrecisionFormat</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glCompressedTexImage2D">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2814">Name</A></H2>
<P>glCompressedTexImage2D -- specify a two-dimensional texture image in
 a compressed format</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2815">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glCompressedTexImage2D</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> level</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> internalformat</VAR>,</TD>
</TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> width</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> height</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> border</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> imageSize</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLvoid *<VAR class="pdparam"> data</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2816">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target texture of the active texture unit. Must be <CODE
class="constant">GL_TEXTURE_2D</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>level</CODE></EM></DT>
<DD>
<P> Specifies the level-of-detail number. Level 0 is the base image
 level. Level
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM> is the
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM>th mipmap reduction image.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>internalformat</CODE></EM></DT>
<DD>
<P> Specifies the format of the compressed image data stored at address<EM
class="parameter"> <CODE>data</CODE></EM>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>width</CODE></EM></DT>
<DD>
<P> Specifies the width of the texture image. All implementations
 support 2D texture images that are at least 64 texels wide and
 cube-mapped texture images that are at least 16 texels wide.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>height</CODE></EM></DT>
<DD>
<P> Specifies the height of the texture image. All implementations
 support 2D texture images that are at least 64 texels high and
 cube-mapped texture images that are at least 16 texels high.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>border</CODE></EM></DT>
<DD>
<P> Specifies the width of the border. Must be 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>imageSize</CODE></EM></DT>
<DD>
<P> Specifies the number of unsigned bytes of image data starting at the
 address specified by<EM class="parameter"> <CODE>data</CODE></EM>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>data</CODE></EM></DT>
<DD>
<P> Specifies a pointer to the compressed image data in memory.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2817">Description</A></H2>
<P> Texturing maps a portion of a specified texture image onto each
 graphical primitive for which texturing is active. Texturing is active
 when the current fragment shader or vertex shader makes use of built-in
 texture lookup functions.</P>
<P> <CODE class="function">glCompressedTexImage2D</CODE> defines a
 two-dimensional texture image or cube-map texture image using
 compressed image data from client memory. The texture image is decoded
 according to the extension specification defining the specified<EM class="parameter">
 <CODE>internalformat</CODE></EM>. OpenGL ES defines no specific
 compressed texture formats, but does provide a mechanism to obtain
 symbolic constants for such formats provided by extensions. The number
 of compressed texture formats supported can be obtained by querying the
 value of <CODE class="constant">GL_NUM_COMPRESSED_TEXTURE_FORMATS</CODE>
. The list of specific compressed texture formats supported can be
 obtained by querying the value of <CODE class="constant">
GL_COMPRESSED_TEXTURE_FORMATS</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2818">Notes</A></H2>
<P> A GL implementation may choose to store the texture array at any
 internal resolution it chooses.</P>
<P> <CODE class="function">glCompressedTexImage2D</CODE> specifies a
 two-dimensional or cube-map texture for the current texture unit,
 specified with <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2819">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>
, <CODE class="constant">GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>internalformat</CODE></EM> is not a supported format returned in <CODE
class="constant">GL_COMPRESSED_TEXTURE_FORMATS</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>level</CODE></EM> is less than 0.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> may be generated if<EM
class="parameter"> <CODE>level</CODE></EM> is greater than
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2
<!--mml:mo-->
 &acirc;&cent;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 max , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 max is the returned value of <CODE class="constant">GL_MAX_TEXTURE_SIZE</CODE>
 when<EM class="parameter"> <CODE>target</CODE></EM> is <CODE class="constant">
GL_TEXTURE_2D</CODE> or <CODE class="constant">
GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE> when<EM class="parameter"> <CODE>
target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>width</CODE></EM> or<EM class="parameter"> <CODE>height</CODE></EM>
 is less than 0 or greater than <CODE class="constant">
GL_MAX_TEXTURE_SIZE</CODE> when<EM class="parameter"> <CODE>target</CODE>
</EM> is <CODE class="constant">GL_TEXTURE_2D</CODE> or <CODE class="constant">
GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE> when<EM class="parameter"> <CODE>
target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>border</CODE></EM> is not 0.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>imageSize</CODE></EM> is not consistent with the format,
 dimensions, and contents of the specified compressed image data.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 parameter combinations are not supported by the specific compressed
 internal format as specified in the specific texture compression
 extension.</P>
<P> Undefined results, including abnormal program termination, are
 generated if<EM class="parameter"> <CODE>data</CODE></EM> is not
 encoded in a manner consistent with the extension specification
 defining the internal compression format.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2820">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with arguments <CODE class="constant">
GL_NUM_COMPRESSED_TEXTURE_FORMATS</CODE> and <CODE class="constant">
GL_COMPRESSED_TEXTURE_FORMATS</CODE></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_TEXTURE_SIZE</CODE>
 or <CODE class="constant">GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2821">See Also</A></H2>
<P> <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>, <A class="citerefentry" href="#glCompressedTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexSubImage2D</A>, <A class="citerefentry" href="#glCopyTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A>, <A class="citerefentry" href="#glCopyTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexSubImage2D</A>, <A class="citerefentry" href="#glTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glTexSubImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexSubImage2D</A>, <A class="citerefentry" href="#glTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glCompressedTexSubImage2D">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2823">Name</A></H2>
<P>glCompressedTexSubImage2D -- specify a two-dimensional texture
 subimage in a compressed format</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2824">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glCompressedTexSubImage2D</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> level</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> xoffset</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> yoffset</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> width</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> height</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> format</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> imageSize</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLvoid *<VAR class="pdparam"> data</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2825">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target texture of the active texture unit. Must be <CODE
class="constant">GL_TEXTURE_2D</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>level</CODE></EM></DT>
<DD>
<P> Specifies the level-of-detail number. Level 0 is the base image
 level. Level
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM> is the
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM>th mipmap reduction image.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>xoffset</CODE></EM></DT>
<DD>
<P> Specifies a texel offset in the x direction within the texture
 array.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>yoffset</CODE></EM></DT>
<DD>
<P> Specifies a texel offset in the y direction within the texture
 array.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>width</CODE></EM></DT>
<DD>
<P> Specifies the width of the texture subimage.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>height</CODE></EM></DT>
<DD>
<P> Specifies the height of the texture subimage.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>format</CODE></EM></DT>
<DD>
<P> Specifies the format of the compressed image data stored at address<EM
class="parameter"> <CODE>data</CODE></EM>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>imageSize</CODE></EM></DT>
<DD>
<P> Specifies the number of unsigned bytes of image data starting at the
 address specified by<EM class="parameter"> <CODE>data</CODE></EM>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>data</CODE></EM></DT>
<DD>
<P> Specifies a pointer to the compressed image data in memory.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2826">Description</A></H2>
<P> Texturing maps a portion of a specified texture image onto each
 graphical primitive for which texturing is active. Texturing is active
 when the current fragment shader or vertex shader makes use of built-in
 texture lookup functions.</P>
<P> <CODE class="function">glCompressedTexSubImage2D</CODE> redefines a
 contiguous subregion of an existing two-dimensional texture image. The
 texels referenced by<EM class="parameter"> <CODE>data</CODE></EM>
 replace the portion of the existing texture array with x indices<EM class="parameter">
 <CODE>xoffset</CODE></EM> and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 xoffset
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 width
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , and the y indices<EM class="parameter"> <CODE>yoffset</CODE></EM>
 and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 yoffset
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 height
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , inclusive. This region may not include any texels outside the range
 of the texture array as it was originally specified. It is not an error
 to specify a subtexture with width of 0, but such a specification has
 no effect.</P>
<P><EM class="parameter"> <CODE>format</CODE></EM> must be the same
 extension-specified compressed-texture format previously specified by <A
class="citerefentry" href="#glCompressedTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexImage2D</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2827">Notes</A></H2>
<P> <CODE class="function">glCompressedTexSubImage2D</CODE> specifies a
 two-dimensional or cube-map texture for the current texture unit,
 specified with <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2828">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>
, <CODE class="constant">GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>format</CODE></EM> is not a supported format returned in <CODE class="constant">
GL_COMPRESSED_TEXTURE_FORMATS</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>level</CODE></EM> is less than 0.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> may be generated if<EM
class="parameter"> <CODE>level</CODE></EM> is greater than
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2
<!--mml:mo-->
 &acirc;&cent;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 max , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 max is the returned value of <CODE class="constant">GL_MAX_TEXTURE_SIZE</CODE>
 when<EM class="parameter"> <CODE>target</CODE></EM> is <CODE class="constant">
GL_TEXTURE_2D</CODE> or <CODE class="constant">
GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE> when<EM class="parameter"> <CODE>
target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 xoffset
<!--mml:mo-->
 &lt; 0 ,
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 xoffset
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 width
<!--mml:mo-->
 &gt;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 w ,
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 yoffset
<!--mml:mo-->
 &lt; 0 , or
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 yoffset
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 height
<!--mml:mo-->
 &gt;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 h , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 w is the width and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 h is the height of the texture image being modified.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>width</CODE></EM> or<EM class="parameter"> <CODE>height</CODE></EM>
 is less than 0.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>imageSize</CODE></EM> is not consistent with the format,
 dimensions, and contents of the specified compressed image data.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the texture array has not been defined by a previous <A class="citerefentry"
href="#glCompressedTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexImage2D</A> operation whose<EM class="parameter"> <CODE>
internalformat</CODE></EM> matches the<EM class="parameter"> <CODE>
format</CODE></EM> of <CODE class="function">glCompressedTexSubImage2D</CODE>
.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 parameter combinations are not supported by the specific compressed
 internal format as specified in the specific texture compression
 extension.</P>
<P> Undefined results, including abnormal program termination, are
 generated if<EM class="parameter"> <CODE>data</CODE></EM> is not
 encoded in a manner consistent with the extension specification
 defining the internal compression format.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2829">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with arguments <CODE class="constant">
GL_NUM_COMPRESSED_TEXTURE_FORMATS</CODE> and <CODE class="constant">
GL_COMPRESSED_TEXTURE_FORMATS</CODE></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_TEXTURE_SIZE</CODE>
 or <CODE class="constant">GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2830">See Also</A></H2>
<P> <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>, <A class="citerefentry" href="#glCompressedTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexImage2D</A>, <A class="citerefentry" href="#glCopyTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A>, <A class="citerefentry" href="#glCopyTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexSubImage2D</A>, <A class="citerefentry" href="#glTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glTexSubImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexSubImage2D</A>, <A class="citerefentry" href="#glTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glCopyTexImage2D"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2832">Name</A></H2>
<P>glCopyTexImage2D -- copy pixels into a 2D texture image</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2833">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glCopyTexImage2D</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> level</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> internalformat</VAR>,</TD>
</TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> x</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> y</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> width</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> height</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> border</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2834">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target texture of the active texture unit. Must be <CODE
class="constant">GL_TEXTURE_2D</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>level</CODE></EM></DT>
<DD>
<P> Specifies the level-of-detail number. Level 0 is the base image
 level. Level
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM> is the
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM>th mipmap reduction image.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>internalformat</CODE></EM></DT>
<DD>
<P> Specifies the internal format of the texture. Must be one of the
 following symbolic constants: <CODE class="constant">GL_ALPHA</CODE>, <CODE
class="constant">GL_LUMINANCE</CODE>, <CODE class="constant">
GL_LUMINANCE_ALPHA</CODE>, <CODE class="constant">GL_RGB</CODE>, or <CODE
class="constant">GL_RGBA</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>x</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>y</CODE></EM></DT>
<DD>
<P> Specify the window coordinates of the lower left corner of the
 rectangular region of pixels to be copied.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>width</CODE></EM></DT>
<DD>
<P> Specifies the width of the texture image. All implementations
 support 2D texture images that are at least 64 texels wide and
 cube-mapped texture images that are at least 16 texels wide.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>height</CODE></EM></DT>
<DD>
<P> Specifies the height of the texture image. All implementations
 support 2D texture images that are at least 64 texels high and
 cube-mapped texture images that are at least 16 texels high.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>border</CODE></EM></DT>
<DD>
<P> Specifies the width of the border. Must be 0.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2835">Description</A></H2>
<P> Texturing maps a portion of a specified texture image onto each
 graphical primitive for which texturing is active. Texturing is active
 when the current fragment shader or vertex shader makes use of built-in
 texture lookup functions.</P>
<P> <CODE class="function">glCopyTexImage2D</CODE> defines a
 two-dimensional texture image or cube-map texture image with pixels
 from the current framebuffer (rather than from client memory, as is the
 case for <A class="citerefentry" href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>).</P>
<P> The screen-aligned pixel rectangle with lower left corner at (<EM class="parameter">
<CODE>x</CODE></EM>,<EM class="parameter"> <CODE>y</CODE></EM>) and with
 a width of<EM class="parameter"> <CODE>width</CODE></EM> and a height
 of<EM class="parameter"> <CODE>height</CODE></EM> defines the texture
 array at the mipmap level specified by<EM class="parameter"> <CODE>
level</CODE></EM>.<EM class="parameter"> <CODE>internalformat</CODE></EM>
 specifies the internal format of the texture array.</P>
<P> The pixels in the rectangle are processed exactly as if <A class="citerefentry"
href="#glReadPixels">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReadPixels</A> had been called with<EM class="parameter"> <CODE>format</CODE>
</EM> set to <CODE class="constant">GL_RGBA</CODE>, but the process
 stops just after conversion of RGBA values. Subsequent processing is
 identical to that described for <A class="citerefentry" href="#glTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, beginning with the clamping of the R, G, B, and A
 values to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 and then conversion to the texture's internal format for storage in
 the texel array.</P>
<P> The components required for<EM class="parameter"> <CODE>
internalformat</CODE></EM> must be a subset of those present in the
 framebuffer's format. For example, a <CODE class="constant">GL_RGBA</CODE>
 framebuffer can be used to supply components for any<EM class="parameter">
 <CODE>internalformat</CODE></EM>. However, a <CODE class="constant">
GL_RGB</CODE> framebuffer can only be used to supply components for <CODE
class="constant">GL_RGB</CODE> or <CODE class="constant">GL_LUMINANCE</CODE>
 base internal format textures, not <CODE class="constant">GL_ALPHA</CODE>
, <CODE class="constant">GL_LUMINANCE_ALPHA</CODE>, or <CODE class="constant">
GL_RGBA</CODE> textures.</P>
<P> Pixel ordering is such that lower
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 x and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 y screen coordinates correspond to lower
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 t texture coordinates.</P>
<P> If any of the pixels within the specified rectangle are outside the
 framebuffer associated with the current rendering context, then the
 values obtained for those pixels are undefined.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2836">Notes</A></H2>
<P> A GL implementation may choose to store the texture array at any
 internal resolution it chooses.</P>
<P> An image with height or width of 0 indicates a NULL texture.</P>
<P> <CODE class="function">glCopyTexImage2D</CODE> specifies a
 two-dimensional or cube-map texture for the current texture unit,
 specified with <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2837">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>
, <CODE class="constant">GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>internalformat</CODE></EM> is not an accepted format.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is one of the six cube map 2D image targets
 and the width and height parameters are not equal.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>level</CODE></EM> is less than 0.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> may be generated if<EM
class="parameter"> <CODE>level</CODE></EM> is greater than
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2
<!--mml:mo-->
 &acirc;&cent;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 max , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 max is the returned value of <CODE class="constant">GL_MAX_TEXTURE_SIZE</CODE>
 when<EM class="parameter"> <CODE>target</CODE></EM> is <CODE class="constant">
GL_TEXTURE_2D</CODE> or <CODE class="constant">
GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE> when<EM class="parameter"> <CODE>
target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>width</CODE></EM> or<EM class="parameter"> <CODE>height</CODE></EM>
 is less than 0 or greater than <CODE class="constant">
GL_MAX_TEXTURE_SIZE</CODE> when<EM class="parameter"> <CODE>target</CODE>
</EM> is <CODE class="constant">GL_TEXTURE_2D</CODE> or <CODE class="constant">
GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE> when<EM class="parameter"> <CODE>
target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>border</CODE></EM> is not 0.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the currently bound framebuffer's format does not contain a superset of
 the components required by the base format of<EM class="parameter"> <CODE>
internalformat</CODE></EM>.</P>
<P> <CODE class="constant">GL_INVALID_FRAMEBUFFER_OPERATION</CODE> is
 generated if the currently bound framebuffer is not framebuffer
 complete (i.e. the return value from <A class="citerefentry" href="#glCheckFramebufferStatus">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A> is not <CODE class="constant">
GL_FRAMEBUFFER_COMPLETE</CODE>).</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2838">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_TEXTURE_SIZE</CODE>
 or <CODE class="constant">GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2839">See Also</A></H2>
<P> <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>, <A class="citerefentry" href="#glCheckFramebufferStatus">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A>, <A class="citerefentry" href="#glCompressedTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexImage2D</A>, <A class="citerefentry" href="#glCompressedTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexSubImage2D</A>, <A class="citerefentry" href="#glCopyTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexSubImage2D</A>, <A class="citerefentry" href="#glTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A>, <A class="citerefentry" href="#glTexSubImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexSubImage2D</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glCopyTexSubImage2D">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2841">Name</A></H2>
<P>glCopyTexSubImage2D -- copy a two-dimensional texture subimage</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2842">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glCopyTexSubImage2D</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> level</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> xoffset</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> yoffset</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> x</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> y</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> width</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> height</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV>
<P></P>
<DIV class="refsect1"  lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2843">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target texture of the active texture unit. Must be <CODE
class="constant">GL_TEXTURE_2D</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>level</CODE></EM></DT>
<DD>
<P> Specifies the level-of-detail number. Level 0 is the base image
 level. Level
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM> is the
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM>th mipmap reduction image.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>xoffset</CODE></EM></DT>
<DD>
<P> Specifies a texel offset in the x direction within the texture
 array.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>yoffset</CODE></EM></DT>
<DD>
<P> Specifies a texel offset in the y direction within the texture
 array.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>x</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>y</CODE></EM></DT>
<DD>
<P> Specify the window coordinates of the lower left corner of the
 rectangular region of pixels to be copied.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>width</CODE></EM></DT>
<DD>
<P> Specifies the width of the texture subimage.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>height</CODE></EM></DT>
<DD>
<P> Specifies the height of the texture subimage.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2844">Description</A></H2>
<P> Texturing maps a portion of a specified texture image onto each
 graphical primitive for which texturing is active. Texturing is active
 when the current fragment shader or vertex shader makes use of built-in
 texture lookup functions.</P>
<P> <CODE class="function">glCopyTexSubImage2D</CODE> replaces a
 rectangular portion of a two-dimensional texture image or cube-map
 texture image with pixels from the current framebuffer (rather than
 from client memory, as is the case for <A class="citerefentry" href="#glTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexSubImage2D</A>).</P>
<P> The screen-aligned pixel rectangle with lower left corner at
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 x
<!--mml:mi mathvariant=&quot;italic&quot;-->
 y and with width<EM class="parameter"> <CODE>width</CODE></EM> and
 height<EM class="parameter"> <CODE>height</CODE></EM> replaces the
 portion of the texture array with x indices<EM class="parameter"> <CODE>
xoffset</CODE></EM> through
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 xoffset
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 width
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , inclusive, and y indices<EM class="parameter"> <CODE>yoffset</CODE></EM>
 through
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 yoffset
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 height
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , inclusive, at the mipmap level specified by<EM class="parameter"> <CODE>
level</CODE></EM>.</P>
<P> The pixels in the rectangle are processed exactly as if <A class="citerefentry"
href="#glReadPixels">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReadPixels</A> had been called with<EM class="parameter"> <CODE>format</CODE>
</EM> set to <CODE class="constant">GL_RGBA</CODE>, but the process
 stops just after conversion of RGBA values. Subsequent processing is
 identical to that described for <A class="citerefentry" href="#glTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexSubImage2D</A>, beginning with the clamping of the R, G, B, and A
 values to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 and then conversion to the texture's internal format for storage in
 the texel array.</P>
<P> The destination rectangle in the texture array may not include any
 texels outside the texture array as it was originally specified. It is
 not an error to specify a subtexture with zero width or height, but
 such a specification has no effect.</P>
<P> If any of the pixels within the specified rectangle are outside the
 framebuffer associated with the current rendering context, then the
 values obtained for those pixels are undefined.</P>
<P> No change is made to the
<!--span class=&quot;emphasis&quot;-->
<EM> internalformat</EM>,
<!--span class=&quot;emphasis&quot;-->
<EM> width</EM>, or
<!--span class=&quot;emphasis&quot;-->
<EM> height</EM> parameters of the specified texture array or to texel
 values outside the specified subregion.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2845">Notes</A></H2>
<P> <CODE class="function">glCopyTexSubImage2D</CODE> specifies the
 two-dimensional or cube-map texture for the current texture unit,
 specified with <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2846">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>
, <CODE class="constant">GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>level</CODE></EM> is less than 0.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> may be generated if
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 level
<!--mml:mo-->
 &gt;
<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 max , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 max is the returned value of <CODE class="constant">GL_MAX_TEXTURE_SIZE</CODE>
.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 xoffset
<!--mml:mo-->
 &lt; 0 ,
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 xoffset
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 width
<!--mml:mo-->
 &gt;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 w ,
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 yoffset
<!--mml:mo-->
 &lt; 0 , or
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 yoffset
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 height
<!--mml:mo-->
 &gt;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 h , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 w is the width and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 h is the height of the texture image being modified.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>width</CODE></EM> or<EM class="parameter"> <CODE>height</CODE></EM>
 is less than 0.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the texture array has not been defined by a previous <A class="citerefentry"
href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A> or <A class="citerefentry" href="#glCopyTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A> operation.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the currently bound framebuffer's format does not contain a superset of
 the components required by the texture's base internal format.</P>
<P> <CODE class="constant">GL_INVALID_FRAMEBUFFER_OPERATION</CODE> is
 generated if the currently bound framebuffer is not framebuffer
 complete (i.e. the return value from <A class="citerefentry" href="#glCheckFramebufferStatus">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A> is not <CODE class="constant">
GL_FRAMEBUFFER_COMPLETE</CODE>).</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2847">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_TEXTURE_SIZE</CODE>
 or <CODE class="constant">GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2848">See Also</A></H2>
<P> <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>, <A class="citerefentry" href="#glCheckFramebufferStatus">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A>, <A class="citerefentry" href="#glCopyTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A>, <A class="citerefentry" href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A>, <A class="citerefentry" href="#glTexSubImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexSubImage2D</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glCreateProgram"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2850">Name</A></H2>
<P>glCreateProgram -- create a program object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2851">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLuint<B class="fsfunc"> glCreateProgram</B>
(</CODE></TD><TD><VAR class="pdparam">void</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="description"></A>
<H2><A NAME="0_2852">Description</A></H2>
<P><CODE class="function">glCreateProgram</CODE> creates an empty
 program object and returns a non-zero value by which it can be
 referenced. A program object is an object to which shader objects can
 be attached. This provides a mechanism to specify the shader objects
 that will be linked to create a program. It also provides a means for
 checking the compatibility of the shaders that will be used to create a
 program (for instance, checking the compatibility between a vertex
 shader and a fragment shader). When no longer needed as part of a
 program object, shader objects can be detached.</P>
<P>One or more executables are created in a program object by
 successfully attaching shader objects to it with <A class="citerefentry"
href="#glAttachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glAttachShader</A>, successfully compiling the shader objects with <A class="citerefentry"
href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, and successfully linking the program object with <A class="citerefentry"
href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>. These executables are made part of current state when
 <A class="citerefentry" href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A> is called. Program objects can be deleted by calling <A class="citerefentry"
href="#glDeleteProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteProgram</A>. The memory associated with the program object will
 be deleted when it is no longer part of current rendering state for any
 context.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2853">Notes</A></H2>
<P>Like texture objects, the name space for program objects may be
 shared across a set of contexts, as long as the server sides of the
 contexts share the same address space. If the name space is shared
 across contexts, any attached objects and the data associated with
 those attached objects are shared as well.</P>
<P>Applications are responsible for providing the synchronization across
 API calls when objects are accessed from different execution threads.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2854">Errors</A></H2>
<P>This function returns 0 if an error occurs creating the program
 object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2855">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with the argument <CODE class="constant">GL_CURRENT_PROGRAM</CODE>
</P>
<P><A class="citerefentry" href="#glGetActiveAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveAttrib</A> with a valid program object and the index of an
 active attribute variable</P>
<P><A class="citerefentry" href="#glGetActiveUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveUniform</A> with a valid program object and the index of an
 active uniform variable</P>
<P><A class="citerefentry" href="#glGetAttachedShaders">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttachedShaders</A> with a valid program object</P>
<P><A class="citerefentry" href="#glGetAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttribLocation</A> with a valid program object and the name of an
 attribute variable</P>
<P><A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with a valid program object and the parameter to be
 queried</P>
<P><A class="citerefentry" href="#glGetProgramInfoLog">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramInfoLog</A> with a valid program object</P>
<P><A class="citerefentry" href="#glGetUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniform</A> with a valid program object and the location of a
 uniform variable</P>
<P><A class="citerefentry" href="#glGetUniformLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniformLocation</A> with a valid program object and the name of a
 uniform variable</P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2856">See Also</A></H2>
<P><A class="citerefentry" href="#glAttachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glAttachShader</A>, <A class="citerefentry" href="#glBindAttribLocation">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindAttribLocation</A>, <A class="citerefentry" href="#glCreateShader">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateShader</A>, <A class="citerefentry" href="#glDeleteProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteProgram</A>, <A class="citerefentry" href="#glDetachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDetachShader</A>, <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUniform</A>, <A class="citerefentry" href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A>, <A class="citerefentry" href="#glValidateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glValidateProgram</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glCreateShader"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2858">Name</A></H2>
<P>glCreateShader -- create a shader object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2859">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLuint<B class="fsfunc"> glCreateShader</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> shaderType</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2860">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shaderType</CODE></EM></DT>
<DD>
<P>Specifies the type of shader to be created. Must be either <CODE class="constant">
GL_VERTEX_SHADER</CODE> or <CODE class="constant">GL_FRAGMENT_SHADER</CODE>
.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2861">Description</A></H2>
<P><CODE class="function">glCreateShader</CODE> creates an empty shader
 object and returns a non-zero value by which it can be referenced. A
 shader object is used to maintain the source code strings that define a
 shader.<EM class="parameter"> <CODE>shaderType</CODE></EM> indicates
 the type of shader to be created. Two types of shaders are supported. A
 shader of type <CODE class="constant">GL_VERTEX_SHADER</CODE> is a
 shader that is intended to run on the programmable vertex processor. A
 shader of type <CODE class="constant">GL_FRAGMENT_SHADER</CODE> is a
 shader that is intended to run on the programmable fragment processor.</P>
<P>When created, a shader object's <CODE class="constant">GL_SHADER_TYPE</CODE>
 parameter is set to either <CODE class="constant">GL_VERTEX_SHADER</CODE>
 or <CODE class="constant">GL_FRAGMENT_SHADER</CODE>, depending on the
 value of<EM class="parameter"> <CODE>shaderType</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2862">Notes</A></H2>
<P>Like texture objects, the name space for shader objects may be shared
 across a set of contexts, as long as the server sides of the contexts
 share the same address space. If the name space is shared across
 contexts, any attached objects and the data associated with those
 attached objects are shared as well.</P>
<P>Applications are responsible for providing the synchronization across
 API calls when objects are accessed from different execution threads.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2863">Errors</A></H2>
<P>This function returns 0 if an error occurs creating the shader
 object.</P>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>shaderType</CODE></EM> is not an accepted value.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2864">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetShaderiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A> with a valid shader object and the parameter to be
 queried</P>
<P><A class="citerefentry" href="#glGetShaderInfoLog">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderInfoLog</A> with a valid shader object</P>
<P><A class="citerefentry" href="#glGetShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderSource</A> with a valid shader object</P>
<P><A class="citerefentry" href="#glIsShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsShader</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2865">See Also</A></H2>
<P><A class="citerefentry" href="#glAttachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glAttachShader</A>, <A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glDeleteShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteShader</A>, <A class="citerefentry" href="#glDetachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDetachShader</A>, <A class="citerefentry" href="#glShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A>, <A class="citerefentry" href="#glShaderBinary">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderBinary</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glCullFace"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2867">Name</A></H2>
<P>glCullFace -- specify whether front- or back-facing facets can be
 culled</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2868">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glCullFace</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> mode</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2869">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>mode</CODE></EM></DT>
<DD>
<P> Specifies whether front- or back-facing facets are candidates for
 culling. Symbolic constants <CODE class="constant">GL_FRONT</CODE>, <CODE
class="constant">GL_BACK</CODE>, and <CODE class="constant">
GL_FRONT_AND_BACK</CODE> are accepted. The initial value is <CODE class="constant">
GL_BACK</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2870">Description</A></H2>
<P> <CODE class="function">glCullFace</CODE> specifies whether front- or
 back-facing facets are culled (as specified by
<!--span class=&quot;emphasis&quot;-->
<EM> mode</EM>) when facet culling is enabled. Facet culling is
 initially disabled. To enable and disable facet culling, call the <A class="citerefentry"
href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A> and <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisable</A> commands with the argument <CODE class="constant">
GL_CULL_FACE</CODE>. Facets include triangles, quadrilaterals, polygons,
 and rectangles.</P>
<P> <A class="citerefentry" href="#glFrontFace">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFrontFace</A> specifies which of the clockwise and counterclockwise
 facets are front-facing and back-facing. See <A class="citerefentry" href="#glFrontFace">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFrontFace</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2871">Notes</A></H2>
<P> If<EM class="parameter"> <CODE>mode</CODE></EM> is <CODE class="constant">
GL_FRONT_AND_BACK</CODE>, no facets are drawn, but other primitives such
 as points and lines are drawn.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2872">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>mode</CODE></EM> is not an accepted value.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2873">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> with argument <CODE class="constant">GL_CULL_FACE</CODE></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_CULL_FACE_MODE</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2874">See Also</A></H2>
<P> <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A>, <A class="citerefentry" href="#glFrontFace">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFrontFace</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glDeleteBuffers"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2876">Name</A></H2>
<P>glDeleteBuffers -- delete named buffer objects</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2877">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glDeleteBuffers</B>
(</CODE></TD><TD>GLsizei<VAR class="pdparam"> n</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLuint *<VAR class="pdparam"> buffers</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2878">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>n</CODE></EM></DT>
<DD>
<P> Specifies the number of buffer objects to be deleted.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>buffers</CODE></EM></DT>
<DD>
<P> Specifies an array of buffer objects to be deleted.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2879">Description</A></H2>
<P> <CODE class="function">glDeleteBuffers</CODE> deletes<EM class="parameter">
 <CODE>n</CODE></EM> buffer objects named by the elements of the array<EM
class="parameter"> <CODE>buffers</CODE></EM>. After a buffer object is
 deleted, it has no contents, and its name is free for reuse (for
 example by <A class="citerefentry" href="#glGenBuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenBuffers</A>). If a buffer object that is currently bound is
 deleted, the binding reverts to 0 (the absence of any buffer object,
 which reverts to client memory usage).</P>
<P> <CODE class="function">glDeleteBuffers</CODE> silently ignores 0's
 and names that do not correspond to existing buffer objects.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2880">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>n</CODE></EM> is negative.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2881">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glIsBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsBuffer</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2882">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>, <A class="citerefentry" href="#glGenBuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenBuffers</A>, <A class="citerefentry" href="#glIsBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsBuffer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glDeleteFramebuffers">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2884">Name</A></H2>
<P>glDeleteFramebuffers -- delete named framebuffer objects</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2885">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glDeleteFramebuffers</B>(</CODE></TD><TD>GLsizei<VAR class="pdparam"> n</VAR>
,</TD></TR>
<TR><TD></TD><TD>const GLuint *<VAR class="pdparam"> framebuffers</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2886">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>n</CODE></EM></DT>
<DD>
<P> Specifies the number of framebuffer objects to be deleted.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>framebuffers</CODE></EM></DT>
<DD>
<P> Specifies an array of framebuffer objects to be deleted.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2887">Description</A></H2>
<P> <CODE class="function">glDeleteFramebuffers</CODE> deletes<EM class="parameter">
 <CODE>n</CODE></EM> framebuffer objects named by the elements of the
 array<EM class="parameter"> <CODE>framebuffers</CODE></EM>. After a
 framebuffer object is deleted, it has no attachments, and its name is
 free for reuse (for example by <A class="citerefentry" href="#glGenFramebuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenFramebuffers</A>). If a framebuffer object that is currently bound
 is deleted, the binding reverts to 0 (the window-system-provided
 framebuffer).</P>
<P> <CODE class="function">glDeleteFramebuffers</CODE> silently ignores
 0's and names that do not correspond to existing framebuffer objects.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2888">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>n</CODE></EM> is negative.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2889">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glIsFramebuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsFramebuffer</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2890">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindFramebuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindFramebuffer</A>, <A class="citerefentry" href="#glGenFramebuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenFramebuffers</A>, <A class="citerefentry" href="#glIsFramebuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsFramebuffer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glDeleteProgram"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2892">Name</A></H2>
<P>glDeleteProgram -- delete a program object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2893">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glDeleteProgram</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> program</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2894">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the program object to be deleted.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2895">Description</A></H2>
<P><CODE class="function">glDeleteProgram</CODE> frees the memory and
 invalidates the name associated with the program object specified by<EM class="parameter">
 <CODE>program.</CODE></EM> This command effectively undoes the effects
 of a call to <A class="citerefentry" href="#glCreateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateProgram</A>.</P>
<P>If a program object is in use as part of current rendering state, it
 will be flagged for deletion, but it will not be deleted until it is no
 longer part of current state for any rendering context. If a program
 object to be deleted has shader objects attached to it, those shader
 objects will be automatically detached but not deleted unless they have
 already been flagged for deletion by a previous call to <A class="citerefentry"
href="#glDeleteShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteShader</A>. A value of 0 for<EM class="parameter"> <CODE>program</CODE>
</EM> will be silently ignored.</P>
<P>To determine whether a program object has been flagged for deletion,
 call <A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with arguments<EM class="parameter"> <CODE>program</CODE>
</EM> and <CODE class="constant">GL_DELETE_STATUS</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2896">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a value generated by OpenGL.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2897">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_CURRENT_PROGRAM</CODE></P>
<P><A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with arguments<EM class="parameter"> <CODE>program</CODE>
</EM> and <CODE class="constant">GL_DELETE_STATUS</CODE></P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2898">See Also</A></H2>
<P><A class="citerefentry" href="#glCreateShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateShader</A>, <A class="citerefentry" href="#glDetachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDetachShader</A>, <A class="citerefentry" href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glDeleteRenderbuffers">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2900">Name</A></H2>
<P>glDeleteRenderbuffers -- delete named renderbuffer objects</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2901">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glDeleteRenderbuffers</B>(</CODE></TD><TD>GLsizei<VAR class="pdparam">
 n</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLuint *<VAR class="pdparam"> renderbuffers</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2902">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>n</CODE></EM></DT>
<DD>
<P> Specifies the number of renderbuffer objects to be deleted.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>renderbuffers</CODE></EM></DT>
<DD>
<P> Specifies an array of renderbuffer objects to be deleted.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2903">Description</A></H2>
<P> <CODE class="function">glDeleteRenderbuffers</CODE> deletes<EM class="parameter">
 <CODE>n</CODE></EM> renderbuffer objects named by the elements of the
 array<EM class="parameter"> <CODE>renderbuffers</CODE></EM>. After a
 renderbuffer object is deleted, it has no contents, and its name is
 free for reuse (for example by <A class="citerefentry" href="#glGenRenderbuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenRenderbuffers</A>).</P>
<P> If a renderbuffer object that is currently bound is deleted, the
 binding reverts to 0 (the absence of any renderbuffer object).
 Additionally, special care must be taken when deleting a renderbuffer
 object if the image of the renderbuffer is attached to a framebuffer
 object. In this case, if the deleted renderbuffer object is attached to
 the currently bound framebuffer object, it is automatically detached.
 However, attachments to any other framebuffer objects are the
 responsibility of the application.</P>
<P> <CODE class="function">glDeleteRenderbuffers</CODE> silently ignores
 0's and names that do not correspond to existing renderbuffer objects.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2904">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>n</CODE></EM> is negative.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2905">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glIsRenderbuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsRenderbuffer</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2906">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindRenderbuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindRenderbuffer</A>, <A class="citerefentry" href="#glGenRenderbuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenRenderbuffers</A>, <A class="citerefentry" href="#glIsRenderbuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsRenderbuffer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glDeleteShader"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2908">Name</A></H2>
<P>glDeleteShader -- delete a shader object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2909">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glDeleteShader</B>(</CODE>
</TD><TD>GLuint<VAR class="pdparam"> shader</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2910">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shader</CODE></EM></DT>
<DD>
<P>Specifies the shader object to be deleted.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2911">Description</A></H2>
<P><CODE class="function">glDeleteShader</CODE> frees the memory and
 invalidates the name associated with the shader object specified by<EM class="parameter">
 <CODE>shader</CODE></EM>. This command effectively undoes the effects
 of a call to <A class="citerefentry" href="#glCreateShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateShader</A>.</P>
<P>If a shader object to be deleted is attached to a program object, it
 will be flagged for deletion, but it will not be deleted until it is no
 longer attached to any program object, for any rendering context (i.e.,
 it must be detached from wherever it was attached before it will be
 deleted). A value of 0 for<EM class="parameter"> <CODE>shader</CODE></EM>
 will be silently ignored.</P>
<P>To determine whether an object has been flagged for deletion, call <A class="citerefentry"
href="#glGetShaderiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A> with arguments<EM class="parameter"> <CODE>shader</CODE>
</EM> and <CODE class="constant">GL_DELETE_STATUS</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2912">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not a value generated by OpenGL.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2913">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetAttachedShaders">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttachedShaders</A> with the program object to be queried</P>
<P><A class="citerefentry" href="#glGetShaderiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A> with arguments<EM class="parameter"> <CODE>shader</CODE>
</EM> and <CODE class="constant">GL_DELETE_STATUS</CODE></P>
<P><A class="citerefentry" href="#glIsShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsShader</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2914">See Also</A></H2>
<P><A class="citerefentry" href="#glCreateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateProgram</A>, <A class="citerefentry" href="#glCreateShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateShader</A>, <A class="citerefentry" href="#glDetachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDetachShader</A>, <A class="citerefentry" href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glDeleteTextures"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2916">Name</A></H2>
<P>glDeleteTextures -- delete named textures</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2917">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glDeleteTextures</B>
(</CODE></TD><TD>GLsizei<VAR class="pdparam"> n</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLuint *<VAR class="pdparam"> textures</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2918">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>n</CODE></EM></DT>
<DD>
<P> Specifies the number of textures to be deleted.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>textures</CODE></EM></DT>
<DD>
<P> Specifies an array of textures to be deleted.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2919">Description</A></H2>
<P> <CODE class="function">glDeleteTextures</CODE> deletes<EM class="parameter">
 <CODE>n</CODE></EM> textures named by the elements of the array<EM class="parameter">
 <CODE>textures</CODE></EM>. After a texture is deleted, it has no
 contents or dimensionality, and its name is free for reuse (for example
 by <A class="citerefentry" href="#glGenTextures">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenTextures</A>). If a texture that is currently bound is deleted, the
 binding reverts to 0 (the default texture).</P>
<P> <CODE class="function">glDeleteTextures</CODE> silently ignores 0's
 and names that do not correspond to existing textures.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2920">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>n</CODE></EM> is negative.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2921">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glIsTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsTexture</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2922">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindTexture</A>, <A class="citerefentry" href="#glGenTextures">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenTextures</A>, <A class="citerefentry" href="#glIsTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsTexture</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glDepthFunc"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2924">Name</A></H2>
<P>glDepthFunc -- specify the value used for depth buffer comparisons</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2925">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glDepthFunc</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> func</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2926">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>func</CODE></EM></DT>
<DD>
<P> Specifies the depth comparison function. Symbolic constants <CODE class="constant">
GL_NEVER</CODE>, <CODE class="constant">GL_LESS</CODE>, <CODE class="constant">
GL_EQUAL</CODE>, <CODE class="constant">GL_LEQUAL</CODE>, <CODE class="constant">
GL_GREATER</CODE>, <CODE class="constant">GL_NOTEQUAL</CODE>, <CODE class="constant">
GL_GEQUAL</CODE>, and <CODE class="constant">GL_ALWAYS</CODE> are
 accepted. The initial value is <CODE class="constant">GL_LESS</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2927">Description</A></H2>
<P> <CODE class="function">glDepthFunc</CODE> specifies the function
 used to compare each incoming pixel depth value with the depth value
 present in the depth buffer. The comparison is performed only if depth
 testing is enabled. (See <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A> and <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisable</A> of <CODE class="constant">GL_DEPTH_TEST</CODE>.)</P>
<P><EM class="parameter"> <CODE>func</CODE></EM> specifies the
 conditions under which the pixel will be drawn. The comparison
 functions are as follows:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NEVER</CODE></DT>
<DD>
<P> Never passes.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LESS</CODE></DT>
<DD>
<P> Passes if the incoming depth value is less than the stored depth
 value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_EQUAL</CODE></DT>
<DD>
<P> Passes if the incoming depth value is equal to the stored depth
 value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LEQUAL</CODE></DT>
<DD>
<P> Passes if the incoming depth value is less than or equal to the
 stored depth value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_GREATER</CODE></DT>
<DD>
<P> Passes if the incoming depth value is greater than the stored depth
 value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NOTEQUAL</CODE></DT>
<DD>
<P> Passes if the incoming depth value is not equal to the stored depth
 value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_GEQUAL</CODE></DT>
<DD>
<P> Passes if the incoming depth value is greater than or equal to the
 stored depth value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ALWAYS</CODE></DT>
<DD>
<P> Always passes.</P>
</DD>
</DL>
</DIV>
<P> The initial value of<EM class="parameter"> <CODE>func</CODE></EM> is
 <CODE class="constant">GL_LESS</CODE>. Initially, depth testing is
 disabled. If depth testing is disabled or no depth buffer exists, it is
 as if the depth test always passes.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2928">Notes</A></H2>
<P> Even if the depth buffer exists and the depth mask is non-zero, the
 depth buffer is not updated if the depth test is disabled.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2929">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>func</CODE></EM> is not an accepted value.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2930">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_DEPTH_FUNC</CODE></P>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> with argument <CODE class="constant">GL_DEPTH_TEST</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2931">See Also</A></H2>
<P> <A class="citerefentry" href="#glDepthRangef">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthRangef</A>, <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A>, <A class="citerefentry" href="#glPolygonOffset">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPolygonOffset</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glDepthMask"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2933">Name</A></H2>
<P>glDepthMask -- enable or disable writing into the depth buffer</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2934">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glDepthMask</B>(</CODE>
</TD><TD>GLboolean<VAR class="pdparam"> flag</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2935">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>flag</CODE></EM></DT>
<DD>
<P> Specifies whether the depth buffer is enabled for writing. If<EM class="parameter">
 <CODE>flag</CODE></EM> is <CODE class="constant">GL_FALSE</CODE>, depth
 buffer writing is disabled. Otherwise, it is enabled. Initially, depth
 buffer writing is enabled.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2936">Description</A></H2>
<P> <CODE class="function">glDepthMask</CODE> specifies whether the
 depth buffer is enabled for writing. If<EM class="parameter"> <CODE>
flag</CODE></EM> is <CODE class="constant">GL_FALSE</CODE>, depth buffer
 writing is disabled. Otherwise, it is enabled. Initially, depth buffer
 writing is enabled.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2937">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_DEPTH_WRITEMASK</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2938">See Also</A></H2>
<P> <A class="citerefentry" href="#glColorMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glColorMask</A>, <A class="citerefentry" href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A>, <A class="citerefentry" href="#glDepthRangef">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthRangef</A>, <A class="citerefentry" href="#glStencilMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glDepthRangef"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2940">Name</A></H2>
<P>glDepthRangef -- specify mapping of depth values from normalized
 device coordinates to window coordinates</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2941">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glDepthRangef</B>(</CODE>
</TD><TD>GLclampf<VAR class="pdparam"> nearVal</VAR>,</TD></TR>
<TR><TD></TD><TD>GLclampf<VAR class="pdparam"> farVal</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2942">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>nearVal</CODE></EM></DT>
<DD>
<P> Specifies the mapping of the near clipping plane to window
 coordinates. The initial value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>farVal</CODE></EM></DT>
<DD>
<P> Specifies the mapping of the far clipping plane to window
 coordinates. The initial value is 1.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2943">Description</A></H2>
<P> After clipping and division by
<!--span class=&quot;emphasis&quot;-->
<EM> w</EM>, depth coordinates range from
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mn-->
 -1 to 1, corresponding to the near and far clipping planes. <CODE class="function">
glDepthRangef</CODE> specifies a linear mapping of the normalized depth
 coordinates in this range to window depth coordinates. Regardless of
 the actual depth buffer implementation, window coordinate depth values
 are treated as though they range from 0 through 1 (like color
 components). Thus, the values accepted by <CODE class="function">
glDepthRangef</CODE> are both clamped to this range before they are
 accepted.</P>
<P> The setting of (0,1) maps the near plane to 0 and the far plane to
 1. With this mapping, the depth buffer range is fully utilized.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2944">Notes</A></H2>
<P> It is not necessary that<EM class="parameter"> <CODE>nearVal</CODE></EM>
 be less than<EM class="parameter"> <CODE>farVal</CODE></EM>. Reverse
 mappings such as
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 nearVal
<!--mml:mo-->
 =
<!--mml:mn-->
 1 , and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 farVal
<!--mml:mo-->
 =
<!--mml:mn-->
 0 are acceptable.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2945">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_DEPTH_RANGE</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2946">See Also</A></H2>
<P> <A class="citerefentry" href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A>, <A class="citerefentry" href="#glPolygonOffset">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPolygonOffset</A>, <A class="citerefentry" href="#glViewport">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glViewport</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glDetachShader"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2948">Name</A></H2>
<P>glDetachShader -- detach a shader object from a program object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2949">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glDetachShader</B>(</CODE>
</TD><TD>GLuint<VAR class="pdparam"> program</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> shader</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2950">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the program object from which to detach the shader object.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shader</CODE></EM></DT>
<DD>
<P>Specifies the shader object to be detached.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2951">Description</A></H2>
<P><CODE class="function">glDetachShader</CODE> detaches the shader
 object specified by<EM class="parameter"> <CODE>shader</CODE></EM> from
 the program object specified by<EM class="parameter"> <CODE>program</CODE>
</EM>. This command can be used to undo the effect of the command <A class="citerefentry"
href="#glAttachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glAttachShader</A>.</P>
<P>If<EM class="parameter"> <CODE>shader</CODE></EM> has already been
 flagged for deletion by a call to <A class="citerefentry" href="#glDeleteShader">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteShader</A> and it is not attached to any other program object,
 it will be deleted after it has been detached.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2952">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if either<EM
class="parameter"> <CODE>program</CODE></EM> or<EM class="parameter"> <CODE>
shader</CODE></EM> is a value that was not generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not a shader object.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not attached to<EM class="parameter"> <CODE>
program</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2953">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetAttachedShaders">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttachedShaders</A> with the handle of a valid program object</P>
<P><A class="citerefentry" href="#glGetShaderiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A> with arguments<EM class="parameter"> <CODE>shader</CODE>
</EM> and <CODE class="constant">GL_DELETE_STATUS</CODE></P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
<P><A class="citerefentry" href="#glIsShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsShader</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2954">See Also</A></H2>
<P><A class="citerefentry" href="#glAttachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glAttachShader</A></P>
</DIV></DIV>
<HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glDrawArrays"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2956">Name</A></H2>
<P>glDrawArrays -- render primitives from array data</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2957">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glDrawArrays</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> mode</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> first</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2958">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>mode</CODE></EM></DT>
<DD>
<P> Specifies what kind of primitives to render. Symbolic constants <CODE
class="constant">GL_POINTS</CODE>, <CODE class="constant">GL_LINE_STRIP</CODE>
, <CODE class="constant">GL_LINE_LOOP</CODE>, <CODE class="constant">
GL_LINES</CODE>, <CODE class="constant">GL_TRIANGLE_STRIP</CODE>, <CODE class="constant">
GL_TRIANGLE_FAN</CODE>, and <CODE class="constant">GL_TRIANGLES</CODE>
 are accepted.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>first</CODE></EM></DT>
<DD>
<P> Specifies the starting index in the enabled arrays.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>count</CODE></EM></DT>
<DD>
<P> Specifies the number of indices to be rendered.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2959">Description</A></H2>
<P> <CODE class="function">glDrawArrays</CODE> specifies multiple
 geometric primitives with very few subroutine calls. Instead of calling
 a GL procedure to pass each individual vertex attribute, you can use <A class="citerefentry"
href="#glVertexAttribPointer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttribPointer</A> to prespecify separate arrays of vertices,
 normals, and colors and use them to construct a sequence of primitives
 with a single call to <CODE class="function">glDrawArrays</CODE>.</P>
<P> When <CODE class="function">glDrawArrays</CODE> is called, it uses<EM
class="parameter"> <CODE>count</CODE></EM> sequential elements from each
 enabled array to construct a sequence of geometric primitives,
 beginning with element<EM class="parameter"> <CODE>first</CODE></EM>.<EM
class="parameter"> <CODE>mode</CODE></EM> specifies what kind of
 primitives are constructed and how the array elements construct those
 primitives.</P>
<P> To enable and disable a generic vertex attribute array, call <A class="citerefentry"
href="#glEnableVertexAttribArray">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnableVertexAttribArray</A> and <A class="citerefentry" href="#glEnableVertexAttribArray">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisableVertexAttribArray</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2960">Notes</A></H2>
<P> If the current program object, as set by <A class="citerefentry" href="#glUseProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A>, is invalid, rendering results are undefined. However,
 no error is generated for this case.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2961">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>mode</CODE></EM> is not an accepted value.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>count</CODE></EM> is negative.</P>
<P> <CODE class="constant">GL_INVALID_FRAMEBUFFER_OPERATION</CODE> is
 generated if the currently bound framebuffer is not framebuffer
 complete (i.e. the return value from <A class="citerefentry" href="#glCheckFramebufferStatus">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A> is not <CODE class="constant">
GL_FRAMEBUFFER_COMPLETE</CODE>).</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2962">See Also</A></H2>
<P> <A class="citerefentry" href="#glCheckFramebufferStatus">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A>, <A class="citerefentry" href="#glEnableVertexAttribArray">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisableVertexAttribArray</A>, <A class="citerefentry" href="#glDrawElements">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawElements</A>, <A class="citerefentry" href="#glEnableVertexAttribArray">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnableVertexAttribArray</A>, <A class="citerefentry" href="#glUseProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A>, <A class="citerefentry" href="#glVertexAttribPointer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttribPointer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glDrawElements"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2964">Name</A></H2>
<P>glDrawElements -- render primitives from array data</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2965">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glDrawElements</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> mode</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> type</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLvoid *<VAR class="pdparam"> indices</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2966">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>mode</CODE></EM></DT>
<DD>
<P> Specifies what kind of primitives to render. Symbolic constants <CODE
class="constant">GL_POINTS</CODE>, <CODE class="constant">GL_LINE_STRIP</CODE>
, <CODE class="constant">GL_LINE_LOOP</CODE>, <CODE class="constant">
GL_LINES</CODE>, <CODE class="constant">GL_TRIANGLE_STRIP</CODE>, <CODE class="constant">
GL_TRIANGLE_FAN</CODE>, and <CODE class="constant">GL_TRIANGLES</CODE>
 are accepted.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>count</CODE></EM></DT>
<DD>
<P> Specifies the number of elements to be rendered.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>type</CODE></EM></DT>
<DD>
<P> Specifies the type of the values in<EM class="parameter"> <CODE>
indices</CODE></EM>. Must be <CODE class="constant">GL_UNSIGNED_BYTE</CODE>
 or <CODE class="constant">GL_UNSIGNED_SHORT</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>indices</CODE></EM></DT>
<DD>
<P> Specifies a pointer to the location where the indices are stored.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2967">Description</A></H2>
<P> <CODE class="function">glDrawElements</CODE> specifies multiple
 geometric primitives with very few subroutine calls. Instead of calling
 a GL function to pass each vertex attribute, you can use <A class="citerefentry"
href="#glVertexAttribPointer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttribPointer</A> to prespecify separate arrays of vertex
 attributes and use them to construct a sequence of primitives with a
 single call to <CODE class="function">glDrawElements</CODE>.</P>
<P> When <CODE class="function">glDrawElements</CODE> is called, it uses<EM
class="parameter"> <CODE>count</CODE></EM> sequential elements from an
 enabled array, starting at<EM class="parameter"> <CODE>indices</CODE></EM>
 to construct a sequence of geometric primitives.<EM class="parameter"> <CODE>
mode</CODE></EM> specifies what kind of primitives are constructed and
 how the array elements construct these primitives. If more than one
 array is enabled, each is used.</P>
<P> To enable and disable a generic vertex attribute array, call <A class="citerefentry"
href="#glEnableVertexAttribArray">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnableVertexAttribArray</A> and <A class="citerefentry" href="#glEnableVertexAttribArray">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisableVertexAttribArray</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2968">Notes</A></H2>
<P> If the current program object, as set by <A class="citerefentry" href="#glUseProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A>, is invalid, rendering results are undefined. However,
 no error is generated for this case.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2969">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>mode</CODE></EM> is not an accepted value.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>type</CODE></EM> is not <CODE class="constant">GL_UNSIGNED_BYTE</CODE>
 or <CODE class="constant">GL_UNSIGNED_SHORT</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>count</CODE></EM> is negative.</P>
<P> <CODE class="constant">GL_INVALID_FRAMEBUFFER_OPERATION</CODE> is
 generated if the currently bound framebuffer is not framebuffer
 complete (i.e. the return value from <A class="citerefentry" href="#glCheckFramebufferStatus">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A> is not <CODE class="constant">
GL_FRAMEBUFFER_COMPLETE</CODE>).</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2970">See Also</A></H2>
<P> <A class="citerefentry" href="#glCheckFramebufferStatus">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A>, <A class="citerefentry" href="#glEnableVertexAttribArray">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisableVertexAttribArray</A>, <A class="citerefentry" href="#glDrawArrays">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawArrays</A>, <A class="citerefentry" href="#glEnableVertexAttribArray">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnableVertexAttribArray</A>, <A class="citerefentry" href="#glUseProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A>, <A class="citerefentry" href="#glVertexAttribPointer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttribPointer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glEnable"></A><DIV class="titlepage">
</DIV><DIV class="refnamediv">
<H2><A NAME="0_2972">Name</A></H2>
<P>glEnable -- enable or disable server-side GL capabilities</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2973">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glEnable</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> cap</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2974">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>cap</CODE></EM></DT>
<DD>
<P> Specifies a symbolic constant indicating a GL capability.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2975">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glDisable</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> cap</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters2"></A>
<H2><A NAME="0_2976">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>cap</CODE></EM></DT>
<DD>
<P> Specifies a symbolic constant indicating a GL capability.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2977">Description</A></H2>
<P> <CODE class="function">glEnable</CODE> and <A class="citerefentry" href="#glEnable">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisable</A> enable and disable various capabilities. Use <A class="citerefentry"
href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> or <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> to determine the current setting of any capability. The
 initial value for each capability with the exception of <CODE class="constant">
GL_DITHER</CODE> is <CODE class="constant">GL_FALSE</CODE>. The initial
 value for <CODE class="constant">GL_DITHER</CODE> is <CODE class="constant">
GL_TRUE</CODE>.</P>
<P> Both <CODE class="function">glEnable</CODE> and <A class="citerefentry"
href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisable</A> take a single argument,<EM class="parameter"> <CODE>cap</CODE>
</EM>, which can assume one of the following values:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_BLEND</CODE></DT>
<DD>
<P> If enabled, blend the computed fragment color values with the values
 in the color buffers. See <A class="citerefentry" href="#glBlendFunc">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_CULL_FACE</CODE></DT>
<DD>
<P> If enabled, cull polygons based on their winding in window
 coordinates. See <A class="citerefentry" href="#glCullFace">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCullFace</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DEPTH_TEST</CODE></DT>
<DD>
<P> If enabled, do depth comparisons and update the depth buffer. Note
 that even if the depth buffer exists and the depth mask is non-zero,
 the depth buffer is not updated if the depth test is disabled. See <A class="citerefentry"
href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A> and <A class="citerefentry" href="#glDepthRangef">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthRangef</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DITHER</CODE></DT>
<DD>
<P> If enabled, dither color components or indices before they are
 written to the color buffer.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_POLYGON_OFFSET_FILL</CODE></DT>
<DD>
<P> If enabled, an offset is added to depth values of a polygon's
 fragments produced by rasterization. See <A class="citerefentry" href="#glPolygonOffset">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPolygonOffset</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SAMPLE_ALPHA_TO_COVERAGE</CODE></DT>
<DD>
<P> If enabled, compute a temporary coverage value where each bit is
 determined by the alpha value at the corresponding sample location. The
 temporary coverage value is then ANDed with the fragment coverage
 value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SAMPLE_COVERAGE</CODE></DT>
<DD>
<P> If enabled, the fragment's coverage is ANDed with the temporary
 coverage value. If <CODE class="constant">GL_SAMPLE_COVERAGE_INVERT</CODE>
 is set to <CODE class="constant">GL_TRUE</CODE>, invert the coverage
 value. See <A class="citerefentry" href="#glSampleCoverage">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glSampleCoverage</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SCISSOR_TEST</CODE></DT>
<DD>
<P> If enabled, discard fragments that are outside the scissor
 rectangle. See <A class="citerefentry" href="#glScissor">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glScissor</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_TEST</CODE></DT>
<DD>
<P> If enabled, do stencil testing and update the stencil buffer. See <A class="citerefentry"
href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A> and <A class="citerefentry" href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors">
</A>
<H2><A NAME="0_2978">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>cap</CODE></EM> is not one of the values listed previously.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2979">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2980">See Also</A></H2>
<P> <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>, <A class="citerefentry" href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A>, <A class="citerefentry" href="#glCullFace">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCullFace</A>, <A class="citerefentry" href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A>, <A class="citerefentry" href="#glDepthRangef">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthRangef</A>, <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A>, <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A>, <A class="citerefentry" href="#glLineWidth">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLineWidth</A>, <A class="citerefentry" href="#glPolygonOffset">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPolygonOffset</A>, <A class="citerefentry" href="#glScissor">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glScissor</A>, <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A>, <A class="citerefentry" href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A>, <A class="citerefentry" href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glEnableVertexAttribArray">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_2982">Name</A></H2>
<P>glEnableVertexAttribArray -- enable or disable a generic vertex
 attribute array</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2983">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glEnableVertexAttribArray</B>(</CODE></TD><TD>GLuint<VAR class="pdparam">
 index</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glDisableVertexAttribArray</B>(</CODE></TD><TD>GLuint<VAR class="pdparam">
 index</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_2984">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>index</CODE></EM></DT>
<DD>
<P>Specifies the index of the generic vertex attribute to be enabled or
 disabled.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_2985">Description</A></H2>
<P><CODE class="function">glEnableVertexAttribArray</CODE> enables the
 generic vertex attribute array specified by<EM class="parameter"> <CODE>
index</CODE></EM>. <CODE class="function">glDisableVertexAttribArray</CODE>
 disables the generic vertex attribute array specified by<EM class="parameter">
 <CODE>index</CODE></EM>. By default, all client-side capabilities are
 disabled, including all generic vertex attribute arrays. If enabled,
 the values in the generic vertex attribute array will be accessed and
 used for rendering when calls are made to vertex array commands such as
 <A class="citerefentry" href="#glDrawArrays">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawArrays</A> or <A class="citerefentry" href="#glDrawElements">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawElements</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_2986">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>index</CODE></EM> is greater than or equal to <CODE class="constant">
GL_MAX_VERTEX_ATTRIBS</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_2987">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_VERTEX_ATTRIBS</CODE>
</P>
<P><A class="citerefentry" href="#glGetVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttrib</A> with arguments<EM class="parameter"> <CODE>index</CODE>
</EM> and <CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_ENABLED</CODE><EM
class="parameter"> <CODE></CODE></EM></P>
<P><A class="citerefentry" href="#glGetVertexAttribPointerv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttribPointerv</A> with arguments<EM class="parameter"> <CODE>
index</CODE></EM> and <CODE class="constant">
GL_VERTEX_ATTRIB_ARRAY_POINTER</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2988">See Also</A></H2>
<A class="citerefentry" href="#glBindAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindAttribLocation</A>, <A class="citerefentry" href="#glDrawArrays">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawArrays</A>, <A class="citerefentry" href="#glDrawElements">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawElements</A>, <A class="citerefentry" href="#glVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttrib</A>, <A class="citerefentry" href="#glVertexAttribPointer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttribPointer</A></DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glFinish"></A><DIV class="titlepage">
</DIV><DIV class="refnamediv">
<H2><A NAME="0_2990">Name</A></H2>
<P>glFinish -- block until all GL execution is complete</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2991">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glFinish</B>(</CODE>
</TD><TD><VAR class="pdparam"> void</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="description"></A>
<H2><A NAME="0_2992">Description</A></H2>
<P> <CODE class="function">glFinish</CODE> does not return until the
 effects of all previously called GL commands are complete. Such effects
 include all changes to GL state, all changes to connection state, and
 all changes to the frame buffer contents.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2993">Notes</A></H2>
<P> <CODE class="function">glFinish</CODE> requires a round trip to the
 server.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_2994">See Also</A></H2>
<P> <A class="citerefentry" href="#glFlush">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFlush</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glFlush"></A><DIV class="titlepage">
</DIV><DIV class="refnamediv">
<H2><A NAME="0_2996">Name</A></H2>
<P>glFlush -- force execution of GL commands in finite time</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_2997">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glFlush</B>(</CODE></TD><TD>
<VAR class="pdparam"> void</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="description"></A>
<H2><A NAME="0_2998">Description</A></H2>
<P> Different GL implementations buffer commands in several different
 locations, including network buffers and the graphics accelerator
 itself. <CODE class="function">glFlush</CODE> empties all of these
 buffers, causing all issued commands to be executed as quickly as they
 are accepted by the actual rendering engine. Though this execution may
 not be completed in any particular time period, it does complete in
 finite time.</P>
<P> Because any GL program might be executed over a network, or on an
 accelerator that buffers commands, all programs should call <CODE class="function">
glFlush</CODE> whenever they count on having all of their previously
 issued commands completed. For example, call <CODE class="function">
glFlush</CODE> before waiting for user input that depends on the
 generated image.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_2999">Notes</A></H2>
<P> <CODE class="function">glFlush</CODE> can return at any time. It
 does not wait until the execution of all previously issued GL commands
 is complete.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3000">See Also</A></H2>
<P> <A class="citerefentry" href="#glFinish">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFinish</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glFramebufferRenderbuffer">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3002">Name</A></H2>
<P>glFramebufferRenderbuffer -- attach a renderbuffer object to a
 framebuffer object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3003">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glFramebufferRenderbuffer</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> attachment</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> renderbuffertarget</VAR>,</TD>
</TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> renderbuffer</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3004">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P>Specifies the framebuffer target. The symbolic constant must be <CODE class="constant">
GL_FRAMEBUFFER</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>attachment</CODE></EM></DT>
<DD>
<P>Specifies the attachment point to which<EM class="parameter"> <CODE>
renderbuffer</CODE></EM> should be attached. Must be one of the
 following symbolic constants: <CODE class="constant">
GL_COLOR_ATTACHMENT0</CODE>, <CODE class="constant">GL_DEPTH_ATTACHMENT</CODE>
, or <CODE class="constant">GL_STENCIL_ATTACHMENT</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>renderbuffertarget</CODE></EM></DT>
<DD>
<P>Specifies the renderbuffer target. The symbolic constant must be <CODE
class="constant">GL_RENDERBUFFER</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>renderbuffer</CODE></EM></DT>
<DD>
<P>Specifies the renderbuffer object that is to be attached.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3005">Description</A></H2>
<P><CODE class="function">glFramebufferRenderbuffer</CODE> attaches the
 renderbuffer specified by<EM class="parameter"> <CODE>renderbuffer</CODE>
</EM> as one of the logical buffers of the currently bound framebuffer
 object.<EM class="parameter"> <CODE>attachment</CODE></EM> specifies
 whether the renderbuffer should be attached to the framebuffer object's
 color, depth, or stencil buffer. A renderbuffer may not be attached to
 the default framebuffer object name 0.</P>
<P>If<EM class="parameter"> <CODE>renderbuffer</CODE></EM> is not 0, the
 value of <CODE class="constant">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE>
 for the specified attachment point is set to <CODE class="constant">
GL_RENDERBUFFER</CODE> and the value of <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</CODE> is set to<EM class="parameter">
 <CODE>renderbuffer</CODE></EM>. <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</CODE> and <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</CODE> are set to the
 default values 0 and <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, respectively. Any previous
 attachment to the<EM class="parameter"> <CODE>attachment</CODE></EM>
 logical buffer of the currently bound framebuffer object is broken.</P>
<P>If<EM class="parameter"> <CODE>renderbuffer</CODE></EM> is 0, the
 current image, if any, attached to the<EM class="parameter"> <CODE>
attachment</CODE></EM> logical buffer of the currently bound framebuffer
 object is detached. The value of <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE> is set to <CODE class="constant">
GL_NONE</CODE>. The value of <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</CODE> is set to 0. <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</CODE> and <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</CODE> are set to the
 default values 0 and <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, respectively.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3006">Notes</A></H2>
<P> If a renderbuffer object is deleted while its image is attached to
 the currently bound framebuffer, then it is as if <CODE class="function">
glFramebufferRenderbuffer</CODE> had been called with a<EM class="parameter">
 <CODE>renderbuffer</CODE></EM> of 0 for the attachment point to which
 this image was attached in the currently bound framebuffer object. In
 other words, the renderbuffer image is detached from the currently
 bound framebuffer. Note that the renderbuffer image is specifically
<!--span class=&quot;emphasis&quot;-->
<EM> not</EM> detached from any non-bound framebuffers. Detaching the
 image from any non-bound framebuffers is the responsibility of the
 application.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3007">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_FRAMEBUFFER</CODE>
.</P>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>renderbuffertarget</CODE></EM> is not <CODE class="constant">
GL_RENDERBUFFER</CODE> and<EM class="parameter"> <CODE>renderbuffer</CODE>
</EM> is not 0.</P>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>attachment</CODE></EM> is not an accepted attachment point.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the default framebuffer object name 0 is bound.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>renderbuffer</CODE></EM> is neither 0 nor the name of an existing
 renderbuffer object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3008">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetFramebufferAttachmentParameteriv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetFramebufferAttachmentParameteriv</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3009">See Also</A></H2>
<P><A class="citerefentry" href="#glBindFramebuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindFramebuffer</A>, <A class="citerefentry" href="#glBindRenderbuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindRenderbuffer</A>, <A class="citerefentry" href="#glCheckFramebufferStatus">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A>, <A class="citerefentry" href="#glDeleteFramebuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteFramebuffers</A>, <A class="citerefentry" href="#glDeleteRenderbuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteRenderbuffers</A>, <A class="citerefentry" href="#glFramebufferTexture2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFramebufferTexture2D</A>, <A class="citerefentry" href="#glGetFramebufferAttachmentParameteriv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetFramebufferAttachmentParameteriv</A>, <A class="citerefentry" href="#glRenderbufferStorage">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glRenderbufferStorage</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glFramebufferTexture2D">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3011">Name</A></H2>
<P>glFramebufferTexture2D -- attach a texture image to a framebuffer
 object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3012">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glFramebufferTexture2D</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> attachment</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> textarget</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> texture</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> level</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3013">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P>Specifies the framebuffer target. The symbolic constant must be <CODE class="constant">
GL_FRAMEBUFFER</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>attachment</CODE></EM></DT>
<DD>
<P>Specifies the attachment point to which an image from<EM class="parameter">
 <CODE>texture</CODE></EM> should be attached. Must be one of the
 following symbolic constants: <CODE class="constant">
GL_COLOR_ATTACHMENT0</CODE>, <CODE class="constant">GL_DEPTH_ATTACHMENT</CODE>
, or <CODE class="constant">GL_STENCIL_ATTACHMENT</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>textarget</CODE></EM></DT>
<DD>
<P>Specifies the texture target. Must be one of the following symbolic
 constants: <CODE class="constant">GL_TEXTURE_2D</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>texture</CODE></EM></DT>
<DD>
<P>Specifies the texture object whose image is to be attached.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>level</CODE></EM></DT>
<DD>
<P>Specifies the mipmap level of the texture image to be attached, which
 must be 0.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3014">Description</A></H2>
<P><CODE class="function">glFramebufferTexture2D</CODE> attaches the
 texture image specified by<EM class="parameter"> <CODE>texture</CODE></EM>
 and<EM class="parameter"> <CODE>level</CODE></EM> as one of the logical
 buffers of the currently bound framebuffer object.<EM class="parameter">
 <CODE>attachment</CODE></EM> specifies whether the texture image should
 be attached to the framebuffer object's color, depth, or stencil
 buffer. A texture image may not be attached to the default framebuffer
 object name 0.</P>
<P>If<EM class="parameter"> <CODE>texture</CODE></EM> is not 0, the
 value of <CODE class="constant">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE>
 for the specified attachment point is set to <CODE class="constant">
GL_TEXTURE</CODE>, the value of <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</CODE> is set to<EM class="parameter">
 <CODE>texture</CODE></EM>, and the value of <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</CODE> is set to<EM class="parameter">
 <CODE>level</CODE></EM>. If<EM class="parameter"> <CODE>texture</CODE></EM>
 is a cube map texture, the value of <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</CODE> is set to<EM class="parameter">
 <CODE>textarget</CODE></EM>; otherwise it is set to the default value <CODE
class="constant">GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>. Any previous
 attachment to the<EM class="parameter"> <CODE>attachment</CODE></EM>
 logical buffer of the currently bound framebuffer object is broken.</P>
<P>If<EM class="parameter"> <CODE>texture</CODE></EM> is 0, the current
 image, if any, attached to the<EM class="parameter"> <CODE>attachment</CODE>
</EM> logical buffer of the currently bound framebuffer object is
 detached. The value of <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE> is set to <CODE class="constant">
GL_NONE</CODE>. The value of <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</CODE> is set to 0. <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</CODE> and <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</CODE> are set to the
 default values 0 and <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, respectively.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3015">Notes</A></H2>
<P> Special precautions need to be taken to avoid attaching a texture
 image to the currently bound framebuffer while the texture object is
 currently bound and potentially sampled by the current vertex or
 fragment shader. Doing so could lead to the creation of a &quot;feedback
 loop&quot; between the writing of pixels by rendering operations and the
 simultaneous reading of those same pixels when used as texels in the
 currently bound texture. In this scenario, the framebuffer will be
 considered framebuffer complete, but the values of fragments rendered
 while in this state will be undefined. The values of texture samples
 may be undefined as well.</P>
<P> If a texture object is deleted while its image is attached to the
 currently bound framebuffer, then it is as if <CODE class="function">
glFramebufferTexture2D</CODE> had been called with a<EM class="parameter">
 <CODE>texture</CODE></EM> of 0 for the attachment point to which this
 image was attached in the currently bound framebuffer object. In other
 words, the texture image is detached from the currently bound
 framebuffer. Note that the texture image is specifically
<!--span class=&quot;emphasis&quot;-->
<EM> not</EM> detached from any non-bound framebuffers. Detaching the
 image from any non-bound framebuffers is the responsibility of the
 application.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3016">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_FRAMEBUFFER</CODE>
.</P>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>textarget</CODE></EM> is not an accepted texture target and<EM class="parameter">
 <CODE>texture</CODE></EM> is not 0.</P>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>attachment</CODE></EM> is not an accepted attachment point.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>level</CODE></EM> is not 0 and<EM class="parameter"> <CODE>
texture</CODE></EM> is not 0.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the default framebuffer object name 0 is bound.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>texture</CODE></EM> is neither 0 nor the name of an existing
 texture object.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>texture</CODE></EM> is the name of an existing two-dimensional
 texture object but<EM class="parameter"> <CODE>textarget</CODE></EM> is
 not <CODE class="constant">GL_TEXTURE_2D</CODE> or if<EM class="parameter">
 <CODE>texture</CODE></EM> is the name of an existing cube map texture
 object but<EM class="parameter"> <CODE>textarget</CODE></EM> is <CODE class="constant">
GL_TEXTURE_2D</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3017">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetFramebufferAttachmentParameteriv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetFramebufferAttachmentParameteriv</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3018">See Also</A></H2>
<P><A class="citerefentry" href="#glBindFramebuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindFramebuffer</A>, <A class="citerefentry" href="#glBindTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindTexture</A>, <A class="citerefentry" href="#glCheckFramebufferStatus">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A>, <A class="citerefentry" href="#glDeleteFramebuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteFramebuffers</A>, <A class="citerefentry" href="#glDeleteTextures">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteTextures</A>, <A class="citerefentry" href="#glFramebufferRenderbuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFramebufferRenderbuffer</A>, <A class="citerefentry" href="#glGenerateMipmap">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenerateMipmap</A>, <A class="citerefentry" href="#glGetFramebufferAttachmentParameteriv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetFramebufferAttachmentParameteriv</A>, <A class="citerefentry" href="#glTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glFrontFace"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3020">Name</A></H2>
<P>glFrontFace -- define front- and back-facing polygons</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3021">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glFrontFace</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> mode</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3022">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>mode</CODE></EM></DT>
<DD>
<P> Specifies the orientation of front-facing polygons. <CODE class="constant">
GL_CW</CODE> and <CODE class="constant">GL_CCW</CODE> are accepted. The
 initial value is <CODE class="constant">GL_CCW</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3023">Description</A></H2>
<P> In a scene composed entirely of opaque closed surfaces, back-facing
 polygons are never visible. Eliminating these invisible polygons has
 the obvious benefit of speeding up the rendering of the image. To
 enable and disable elimination of back-facing polygons, call <A class="citerefentry"
href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A> and <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisable</A> with argument <CODE class="constant">GL_CULL_FACE</CODE>.</P>
<P> The projection of a polygon to window coordinates is said to have
 clockwise winding if an imaginary object following the path from its
 first vertex, its second vertex, and so on, to its last vertex, and
 finally back to its first vertex, moves in a clockwise direction about
 the interior of the polygon. The polygon's winding is said to be
 counterclockwise if the imaginary object following the same path moves
 in a counterclockwise direction about the interior of the polygon. <CODE
class="function">glFrontFace</CODE> specifies whether polygons with
 clockwise winding in window coordinates, or counterclockwise winding in
 window coordinates, are taken to be front-facing. Passing <CODE class="constant">
GL_CCW</CODE> to<EM class="parameter"> <CODE>mode</CODE></EM> selects
 counterclockwise polygons as front-facing; <CODE class="constant">GL_CW</CODE>
 selects clockwise polygons as front-facing. By default,
 counterclockwise polygons are taken to be front-facing.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3024">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>mode</CODE></EM> is not an accepted value.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3025">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_FRONT_FACE</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3026">See Also</A></H2>
<P> <A class="citerefentry" href="#glCullFace">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCullFace</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGenBuffers"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3028">Name</A></H2>
<P>glGenBuffers -- generate buffer object names</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3029">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGenBuffers</B>(</CODE>
</TD><TD>GLsizei<VAR class="pdparam"> n</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint *<VAR class="pdparam"> buffers</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3030">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>n</CODE></EM></DT>
<DD>
<P> Specifies the number of buffer object names to be generated.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>buffers</CODE></EM></DT>
<DD>
<P> Specifies an array in which the generated buffer object names are
 stored.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3031">Description</A></H2>
<P> <CODE class="function">glGenBuffers</CODE> returns<EM class="parameter">
 <CODE>n</CODE></EM> buffer object names in<EM class="parameter"> <CODE>
buffers</CODE></EM>. There is no guarantee that the names form a
 contiguous set of integers; however, it is guaranteed that none of the
 returned names was in use immediately before the call to <CODE class="function">
glGenBuffers</CODE>.</P>
<P> Buffer object names returned by a call to <CODE class="function">
glGenBuffers</CODE> are not returned by subsequent calls, unless they
 are first deleted with <A class="citerefentry" href="#glDeleteBuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteBuffers</A>.</P>
<P> No buffer objects are associated with the returned buffer object
 names until they are first bound by calling <A class="citerefentry" href="#glBindBuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3032">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>n</CODE></EM> is negative.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3033">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glIsBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsBuffer</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3034">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>, <A class="citerefentry" href="#glDeleteBuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteBuffers</A>, <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGenFramebuffers"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3036">Name</A></H2>
<P>glGenFramebuffers -- generate framebuffer object names</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3037">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGenFramebuffers</B>
(</CODE></TD><TD>GLsizei<VAR class="pdparam"> n</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint *<VAR class="pdparam"> framebuffers</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3038">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>n</CODE></EM></DT>
<DD>
<P> Specifies the number of framebuffer object names to be generated.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>framebuffers</CODE></EM></DT>
<DD>
<P> Specifies an array in which the generated framebuffer object names
 are stored.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3039">Description</A></H2>
<P> <CODE class="function">glGenFramebuffers</CODE> returns<EM class="parameter">
 <CODE>n</CODE></EM> framebuffer object names in<EM class="parameter"> <CODE>
framebuffers</CODE></EM>. There is no guarantee that the names form a
 contiguous set of integers; however, it is guaranteed that none of the
 returned names was in use immediately before the call to <CODE class="function">
glGenFramebuffers</CODE>.</P>
<P> Framebuffer object names returned by a call to <CODE class="function">
glGenFramebuffers</CODE> are not returned by subsequent calls, unless
 they are first deleted with <A class="citerefentry" href="#glDeleteFramebuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteFramebuffers</A>.</P>
<P> No framebuffer objects are associated with the returned framebuffer
 object names until they are first bound by calling <A class="citerefentry"
href="#glBindFramebuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindFramebuffer</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3040">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>n</CODE></EM> is negative.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3041">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glIsFramebuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsFramebuffer</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3042">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindFramebuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindFramebuffer</A>, <A class="citerefentry" href="#glDeleteFramebuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteFramebuffers</A>, <A class="citerefentry" href="#glIsFramebuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsFramebuffer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGenRenderbuffers">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3044">Name</A></H2>
<P>glGenRenderbuffers -- generate renderbuffer object names</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3045">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGenRenderbuffers</B>
(</CODE></TD><TD>GLsizei<VAR class="pdparam"> n</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint *<VAR class="pdparam"> renderbuffers</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3046">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>n</CODE></EM></DT>
<DD>
<P> Specifies the number of renderbuffer object names to be generated.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>renderbuffers</CODE></EM></DT>
<DD>
<P> Specifies an array in which the generated renderbuffer object names
 are stored.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3047">Description</A></H2>
<P> <CODE class="function">glGenRenderbuffers</CODE> returns<EM class="parameter">
 <CODE>n</CODE></EM> renderbuffer object names in<EM class="parameter"> <CODE>
renderbuffers</CODE></EM>. There is no guarantee that the names form a
 contiguous set of integers; however, it is guaranteed that none of the
 returned names was in use immediately before the call to <CODE class="function">
glGenRenderbuffers</CODE>.</P>
<P> Renderbuffer object names returned by a call to <CODE class="function">
glGenRenderbuffers</CODE> are not returned by subsequent calls, unless
 they are first deleted with <A class="citerefentry" href="#glDeleteRenderbuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteRenderbuffers</A>.</P>
<P> No renderbuffer objects are associated with the returned
 renderbuffer object names until they are first bound by calling <A class="citerefentry"
href="#glBindRenderbuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindRenderbuffer</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3048">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>n</CODE></EM> is negative.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3049">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glIsRenderbuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsRenderbuffer</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3050">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindRenderbuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindRenderbuffer</A>, <A class="citerefentry" href="#glDeleteRenderbuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteRenderbuffers</A>, <A class="citerefentry" href="#glIsRenderbuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsRenderbuffer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGenTextures"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3052">Name</A></H2>
<P>glGenTextures -- generate texture names</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3053">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGenTextures</B>(</CODE>
</TD><TD>GLsizei<VAR class="pdparam"> n</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint *<VAR class="pdparam"> textures</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3054">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>n</CODE></EM></DT>
<DD>
<P> Specifies the number of texture names to be generated.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>textures</CODE></EM></DT>
<DD>
<P> Specifies an array in which the generated texture names are stored.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3055">Description</A></H2>
<P> <CODE class="function">glGenTextures</CODE> returns<EM class="parameter">
 <CODE>n</CODE></EM> texture names in<EM class="parameter"> <CODE>
textures</CODE></EM>. There is no guarantee that the names form a
 contiguous set of integers; however, it is guaranteed that none of the
 returned names was in use immediately before the call to <CODE class="function">
glGenTextures</CODE>.</P>
<P> The generated textures have no dimensionality; they assume the
 dimensionality of the texture target to which they are first bound (see
 <A class="citerefentry" href="#glBindTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindTexture</A>).</P>
<P> Texture names returned by a call to <CODE class="function">
glGenTextures</CODE> are not returned by subsequent calls, unless they
 are first deleted with <A class="citerefentry" href="#glDeleteTextures">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteTextures</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3056">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>n</CODE></EM> is negative.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3057">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glIsTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsTexture</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3058">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindTexture</A>, <A class="citerefentry" href="#glCopyTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A>, <A class="citerefentry" href="#glDeleteTextures">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteTextures</A>, <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A>, <A class="citerefentry" href="#glGetTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetTexParameter</A>, <A class="citerefentry" href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGenerateMipmap"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3060">Name</A></H2>
<P>glGenerateMipmap -- generate a complete set of mipmaps for a texture
 object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3061">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGenerateMipmap</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3062">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P>Specifies the texture target of the active texture unit to which the
 texture object is bound whose mipmaps will be generated. Must be one of
 the following symbolic constants: <CODE class="constant">GL_TEXTURE_2D</CODE>
 or <CODE class="constant">GL_TEXTURE_CUBE_MAP</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3063">Description</A></H2>
<P><CODE class="function">glGenerateMipmap</CODE> computes a complete
 set of mipmap arrays derived from the zero level array. Array levels up
 to and including the 1x1 dimension texture image are replaced with the
 derived arrays, regardless of previous contents. The zero level texture
 image is left unchanged.</P>
<P>The internal formats of the derived mipmap arrays all match those of
 the zero level texture image. The dimensions of the derived arrays are
 computed by halving the width and height of the zero level texture
 image, then in turn halving the dimensions of each array level until
 the 1x1 dimension texture image is reached.</P>
<P>The contents of the derived arrays are computed by repeated filtered
 reduction of the zero level array. No particular filter algorithm is
 required, though a box filter is recommended. <A class="citerefentry" href="#glHint">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glHint</A> may be called to express a preference for speed or quality of
 filtering.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3064">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>
 or <CODE class="constant">GL_TEXTURE_CUBE_MAP</CODE>.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the texture bound to<EM class="parameter"> <CODE>target</CODE></EM> is
 a cube map, but its six faces do not share indentical widths, heights,
 formats, and types.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 either the width or height of the zero level array is not a power of
 two.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the zero level array is stored in a compressed internal format.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3065">See Also</A></H2>
<P><A class="citerefentry" href="#glBindTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindTexture</A>, <A class="citerefentry" href="#glFramebufferTexture2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFramebufferTexture2D</A>, <A class="citerefentry" href="#glHint">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glHint</A>, <A class="citerefentry" href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGet"></A><DIV class="titlepage">
</DIV><DIV class="refnamediv">
<H2><A NAME="0_3067">Name</A></H2>
<P>glGet -- return the value or values of a selected parameter</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3068">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetBooleanv</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLboolean *<VAR class="pdparam"> params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3069">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetFloatv</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat *<VAR class="pdparam"> params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3070">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetIntegerv</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam"> params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3071">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pname</CODE></EM></DT>
<DD>
<P> Specifies the parameter value to be returned. The symbolic constants
 in the list below are accepted.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>params</CODE></EM></DT>
<DD>
<P> Returns the value or values of the specified parameter.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3072">Description</A></H2>
<P> These four commands return values for simple state variables in GL.<EM
class="parameter"> <CODE>pname</CODE></EM> is a symbolic constant
 indicating the state variable to be returned, and<EM class="parameter">
 <CODE>params</CODE></EM> is a pointer to an array of the indicated type
 in which to place the returned data.</P>
<P> Type conversion is performed if<EM class="parameter"> <CODE>params</CODE>
</EM> has a different type than the state variable value being
 requested. If <CODE class="function">glGetBooleanv</CODE> is called, a
 floating-point (or integer) value is converted to <CODE class="constant">
GL_FALSE</CODE> if and only if it is 0.0 (or 0). Otherwise, it is
 converted to <CODE class="constant">GL_TRUE</CODE>. If <CODE class="function">
glGetIntegerv</CODE> is called, boolean values are returned as <CODE class="constant">
GL_TRUE</CODE> or <CODE class="constant">GL_FALSE</CODE>, and most
 floating-point values are rounded to the nearest integer value.
 Floating-point colors and normals, however, are returned with a linear
 mapping that maps 1.0 to the most positive representable integer value
 and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mn-->
 -1.0 to the most negative representable integer value. If <CODE class="function">
glGetFloatv</CODE> is called, boolean values are returned as <CODE class="constant">
GL_TRUE</CODE> or <CODE class="constant">GL_FALSE</CODE>, and integer
 values are converted to floating-point values.</P>
<P> The following symbolic constants are accepted by<EM class="parameter">
 <CODE>pname</CODE></EM>:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ACTIVE_TEXTURE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value indicating the active multitexture unit. The initial value is <CODE
class="constant">GL_TEXTURE0</CODE>. See <A class="citerefentry" href="#0_2644">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ALIASED_LINE_WIDTH_RANGE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns two values,
 the smallest and largest supported widths for aliased lines. The range
 must include width 1.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ALIASED_POINT_SIZE_RANGE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns two values,
 the smallest and largest supported sizes for aliased points. The range
 must include size 1.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ALPHA_BITS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the number of alpha bitplanes in the color buffer of the currently
 bound framebuffer.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ARRAY_BUFFER_BINDING</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value, the name of the buffer object currently bound to the target <CODE
class="constant">GL_ARRAY_BUFFER</CODE>. If no buffer object is bound to
 this target, 0 is returned. The initial value is 0. See <A class="citerefentry"
href="#glBindBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_BLEND</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 boolean value indicating whether blending is enabled. The initial value
 is <CODE class="constant">GL_FALSE</CODE>. See <A class="citerefentry" href="#glBlendFunc">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_BLEND_COLOR</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns four values,
 the red, green, blue, and alpha values which are the components of the
 blend color. See <A class="citerefentry" href="#glBlendColor">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendColor</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_BLEND_DST_ALPHA</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the symbolic constant identifying the alpha destination blend function.
 The initial value is <CODE class="constant">GL_ZERO</CODE>. See <A class="citerefentry"
href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A> and <A class="citerefentry" href="#glBlendFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFuncSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_BLEND_DST_RGB</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the symbolic constant identifying the RGB destination blend function.
 The initial value is <CODE class="constant">GL_ZERO</CODE>. See <A class="citerefentry"
href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A> and <A class="citerefentry" href="#glBlendFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFuncSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_BLEND_EQUATION_ALPHA</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating whether the Alpha blend equation is <CODE class="constant">
GL_FUNC_ADD</CODE>, <CODE class="constant">GL_FUNC_SUBTRACT</CODE>, or <CODE
class="constant">GL_FUNC_REVERSE_SUBTRACT</CODE>. See <A class="citerefentry"
href="#glBlendEquationSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquationSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_BLEND_EQUATION_RGB</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating whether the RGB blend equation is <CODE class="constant">
GL_FUNC_ADD</CODE>, <CODE class="constant">GL_FUNC_SUBTRACT</CODE>, or <CODE
class="constant">GL_FUNC_REVERSE_SUBTRACT</CODE>. See <A class="citerefentry"
href="#glBlendEquationSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendEquationSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_BLEND_SRC_ALPHA</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the symbolic constant identifying the alpha source blend function. The
 initial value is <CODE class="constant">GL_ONE</CODE>. See <A class="citerefentry"
href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A> and <A class="citerefentry" href="#glBlendFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFuncSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_BLEND_SRC_RGB</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the symbolic constant identifying the RGB source blend function. The
 initial value is <CODE class="constant">GL_ONE</CODE>. See <A class="citerefentry"
href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A> and <A class="citerefentry" href="#glBlendFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFuncSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_BLUE_BITS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the number of blue bitplanes in the color buffer of the currently bound
 framebuffer.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_COLOR_CLEAR_VALUE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns four values:
 the red, green, blue, and alpha values used to clear the color buffers.
 Integer values, if requested, are linearly mapped from the internal
 floating-point representation such that 1.0 returns the most positive
 representable integer value, and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mn-->
 -1.0 returns the most negative representable integer value. The initial
 value is (0, 0, 0, 0). See <A class="citerefentry" href="#glClearColor">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClearColor</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_COLOR_WRITEMASK</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns four boolean
 values: the red, green, blue, and alpha write enables for the color
 buffers. The initial value is (<CODE class="constant">GL_TRUE</CODE>, <CODE
class="constant">GL_TRUE</CODE>, <CODE class="constant">GL_TRUE</CODE>, <CODE
class="constant">GL_TRUE</CODE>). See <A class="citerefentry" href="#glColorMask">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glColorMask</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_COMPRESSED_TEXTURE_FORMATS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a list of
 symbolic constants of length <CODE class="constant">
GL_NUM_COMPRESSED_TEXTURE_FORMATS</CODE> indicating which compressed
 texture formats are available. See <A class="citerefentry" href="#glCompressedTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexImage2D</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_CULL_FACE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 boolean value indicating whether polygon culling is enabled. The
 initial value is <CODE class="constant">GL_FALSE</CODE>. See <A class="citerefentry"
href="#glCullFace">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCullFace</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_CULL_FACE_MODE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating which polygon faces are to be culled. The
 initial value is <CODE class="constant">GL_BACK</CODE>. See <A class="citerefentry"
href="#glCullFace">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCullFace</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_CURRENT_PROGRAM</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the name of the program object that is currently active, or 0 if no
 program object is active. See <A class="citerefentry" href="#glUseProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DEPTH_BITS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the number of bitplanes in the depth buffer of the currently bound
 framebuffer.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DEPTH_CLEAR_VALUE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the value that is used to clear the depth buffer. Integer values, if
 requested, are linearly mapped from the internal floating-point
 representation such that 1.0 returns the most positive representable
 integer value, and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mn-->
 -1.0 returns the most negative representable integer value. The initial
 value is 1. See <A class="citerefentry" href="#glClearDepthf">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClearDepthf</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DEPTH_FUNC</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the symbolic constant that indicates the depth comparison function. The
 initial value is <CODE class="constant">GL_LESS</CODE>. See <A class="citerefentry"
href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DEPTH_RANGE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns two values:
 the near and far mapping limits for the depth buffer. Integer values,
 if requested, are linearly mapped from the internal floating-point
 representation such that 1.0 returns the most positive representable
 integer value, and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mn-->
 -1.0 returns the most negative representable integer value. The initial
 value is (0, 1). See <A class="citerefentry" href="#glDepthRangef">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthRangef</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DEPTH_TEST</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 boolean value indicating whether depth testing of fragments is enabled.
 The initial value is <CODE class="constant">GL_FALSE</CODE>. See <A class="citerefentry"
href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A> and <A class="citerefentry" href="#glDepthRangef">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthRangef</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DEPTH_WRITEMASK</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 boolean value indicating if the depth buffer is enabled for writing.
 The initial value is <CODE class="constant">GL_TRUE</CODE>. See <A class="citerefentry"
href="#glDepthMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthMask</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DITHER</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 boolean value indicating whether dithering of fragment colors and
 indices is enabled. The initial value is <CODE class="constant">GL_TRUE</CODE>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ELEMENT_ARRAY_BUFFER_BINDING</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value, the name of the buffer object currently bound to the target <CODE
class="constant">GL_ELEMENT_ARRAY_BUFFER</CODE>. If no buffer object is
 bound to this target, 0 is returned. The initial value is 0. See <A class="citerefentry"
href="#glBindBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_FRAMEBUFFER_BINDING</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value, the name of the currently bound framebuffer. The initial value
 is 0, indicating the default framebuffer. See <A class="citerefentry" href="#glBindFramebuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindFramebuffer</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_FRONT_FACE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating whether clockwise or counterclockwise
 polygon winding is treated as front-facing. The initial value is <CODE class="constant">
GL_CCW</CODE>. See <A class="citerefentry" href="#glFrontFace">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFrontFace</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_GENERATE_MIPMAP_HINT</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating the mode of the mipmap generation
 filtering hint. The initial value is <CODE class="constant">
GL_DONT_CARE</CODE>. See <A class="citerefentry" href="#glHint">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glHint</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_GREEN_BITS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the number of green bitplanes in the color buffer of the currently
 bound framebuffer.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_IMPLEMENTATION_COLOR_READ_FORMAT</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the format chosen by the implementation in which pixels may be read
 from the color buffer of the currently bound framebuffer in conjunction
 with <CODE class="constant">GL_IMPLEMENTATION_COLOR_READ_TYPE</CODE>.
 In addition to this implementation-dependent format/type pair, format <CODE
class="constant">GL_RGBA</CODE> in conjunction with type <CODE class="constant">
GL_UNSIGNED_BYTE</CODE> is always allowed by every implementation,
 regardless of the currently bound render surface. See <A class="citerefentry"
href="#glReadPixels">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReadPixels</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_IMPLEMENTATION_COLOR_READ_TYPE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the type chosen by the implementation with which pixels may be read
 from the color buffer of the currently bound framebuffer in conjunction
 with <CODE class="constant">GL_IMPLEMENTATION_COLOR_READ_FORMAT</CODE>.
 In addition to this implementation-dependent format/type pair, format <CODE
class="constant">GL_RGBA</CODE> in conjunction with type <CODE class="constant">
GL_UNSIGNED_BYTE</CODE> is always allowed by every implementation,
 regardless of the currently bound render surface. See <A class="citerefentry"
href="#glReadPixels">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReadPixels</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LINE_WIDTH</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the line width as specified with <A class="citerefentry" href="#glLineWidth">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLineWidth</A>. The initial value is 1.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the maximum supported texture image units that can be used to access
 texture maps from the vertex shader and the fragment processor
 combined. If both the vertex shader and the fragment processing stage
 access the same texture image unit, then that counts as using two
 texture image units against this limit. The value must be at least 8.
 See <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value.
 The value gives a rough estimate of the largest cube-map texture that
 the GL can handle. The value must be at least 16. See <A class="citerefentry"
href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_MAX_FRAGMENT_UNIFORM_VECTORS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the maximum number of four-element floating-point, integer, or boolean
 vectors that can be held in uniform variable storage for a fragment
 shader. The value must be at least 16. See <A class="citerefentry" href="#glUniform">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUniform</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_MAX_RENDERBUFFER_SIZE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value.
 The value indicates the largest renderbuffer width and height that the
 GL can handle. The value must be at least 1. See <A class="citerefentry"
href="#glRenderbufferStorage">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glRenderbufferStorage</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_MAX_TEXTURE_IMAGE_UNITS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the maximum supported texture image units that can be used to access
 texture maps from the fragment shader. The value must be at least 8.
 See <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_MAX_TEXTURE_SIZE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value.
 The value gives a rough estimate of the largest texture that the GL can
 handle. The value must be at least 64. See <A class="citerefentry" href="#glTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_MAX_VARYING_VECTORS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the maximum number four-element floating-point vectors available for
 interpolating varying variables used by vertex and fragment shaders.
 Varying variables declared as matrices or arrays will consume multiple
 interpolators. The value must be at least 8.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_MAX_VERTEX_ATTRIBS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the maximum number of 4-component generic vertex attributes accessible
 to a vertex shader. The value must be at least 8. See <A class="citerefentry"
href="#glVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttrib</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the maximum supported texture image units that can be used to access
 texture maps from the vertex shader. The value may be 0. See <A class="citerefentry"
href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_MAX_VERTEX_UNIFORM_VECTORS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the maximum number of four-element floating-point, integer, or boolean
 vectors that can be held in uniform variable storage for a vertex
 shader. The value must be at least 128. See <A class="citerefentry" href="#glUniform">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUniform</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_MAX_VIEWPORT_DIMS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns two values:
 the maximum supported width and height of the viewport. These must be
 at least as large as the visible dimensions of the display being
 rendered to. See <A class="citerefentry" href="#glViewport">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glViewport</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NUM_COMPRESSED_TEXTURE_FORMATS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 integer value indicating the number of available compressed texture
 formats. The minimum value is 0. See <A class="citerefentry" href="#glCompressedTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexImage2D</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NUM_SHADER_BINARY_FORMATS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 integer value indicating the number of available shader binary formats.
 The minimum value is 0. See <A class="citerefentry" href="#glShaderBinary">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderBinary</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_PACK_ALIGNMENT</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the byte alignment used for writing pixel data to memory. The initial
 value is 4. See <A class="citerefentry" href="#glPixelStorei">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPixelStorei</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_POLYGON_OFFSET_FACTOR</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the scaling factor used to determine the variable offset that is added
 to the depth value of each fragment generated when a polygon is
 rasterized. The initial value is 0. See <A class="citerefentry" href="#glPolygonOffset">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPolygonOffset</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_POLYGON_OFFSET_FILL</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 boolean value indicating whether polygon offset is enabled for polygons
 in fill mode. The initial value is <CODE class="constant">GL_FALSE</CODE>
. See <A class="citerefentry" href="#glPolygonOffset">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPolygonOffset</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_POLYGON_OFFSET_UNITS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value.
 This value is multiplied by an implementation-specific value and then
 added to the depth value of each fragment generated when a polygon is
 rasterized. The initial value is 0. See <A class="citerefentry" href="#glPolygonOffset">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPolygonOffset</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RED_BITS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the number of red bitplanes in the color buffer of the currently bound
 framebuffer.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RENDERBUFFER_BINDING</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value, the name of the currently bound renderbuffer. The initial value
 is 0, indicating no renderbuffer is bound. See <A class="citerefentry" href="#glBindRenderbuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindRenderbuffer</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SAMPLE_ALPHA_TO_COVERAGE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 boolean value indicating if the fragment coverage value should be ANDed
 with a temporary coverage value based on the fragment's alpha value.
 The initial value is <CODE class="constant">GL_FALSE</CODE>. See <A class="citerefentry"
href="#glSampleCoverage">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glSampleCoverage</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SAMPLE_BUFFERS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 integer value indicating the number of sample buffers associated with
 the currently bound framebuffer. See <A class="citerefentry" href="#glSampleCoverage">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glSampleCoverage</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SAMPLE_COVERAGE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 boolean value indicating if the fragment coverage value should be ANDed
 with a temporary coverage value based on the current sample coverage
 value. The initial value is <CODE class="constant">GL_FALSE</CODE>. See
 <A class="citerefentry" href="#glSampleCoverage">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glSampleCoverage</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SAMPLE_COVERAGE_INVERT</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 boolean value indicating if the temporary coverage value should be
 inverted. See <A class="citerefentry" href="#glSampleCoverage">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glSampleCoverage</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SAMPLE_COVERAGE_VALUE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 positive floating-point value indicating the current sample coverage
 value. See <A class="citerefentry" href="#glSampleCoverage">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glSampleCoverage</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SAMPLES</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 integer value indicating the coverage mask size of the currently bound
 framebuffer. See <A class="citerefentry" href="#glSampleCoverage">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glSampleCoverage</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SCISSOR_BOX</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns four values:
 the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 x and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 y window coordinates of the scissor box, followed by its width and
 height. Initially the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 x and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 y window coordinates are both 0 and the width and height are set to the
 size of the window. See <A class="citerefentry" href="#glScissor">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glScissor</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SCISSOR_TEST</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 boolean value indicating whether scissoring is enabled. The initial
 value is <CODE class="constant">GL_FALSE</CODE>. See <A class="citerefentry"
href="#glScissor">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glScissor</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SHADER_BINARY_FORMATS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a list of
 symbolic constants of length <CODE class="constant">
GL_NUM_SHADER_BINARY_FORMATS</CODE> indicating which shader binary
 formats are available. See <A class="citerefentry" href="#glShaderBinary">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderBinary</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SHADER_COMPILER</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 boolean value indicating whether a shader compiler is supported. <CODE class="constant">
GL_FALSE</CODE> indicates that any call to <A class="citerefentry" href="#glShaderSource">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A>, <A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, or <A class="citerefentry" href="#glReleaseShaderCompiler">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReleaseShaderCompiler</A> will result in a <CODE class="constant">
GL_INVALID_OPERATION</CODE> error being generated.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_BACK_FAIL</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating what action is taken for back-facing
 polygons when the stencil test fails. The initial value is <CODE class="constant">
GL_KEEP</CODE>. See <A class="citerefentry" href="#glStencilOpSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_BACK_FUNC</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating what function is used for back-facing
 polygons to compare the stencil reference value with the stencil buffer
 value. The initial value is <CODE class="constant">GL_ALWAYS</CODE>.
 See <A class="citerefentry" href="#glStencilFuncSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_BACK_PASS_DEPTH_FAIL</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating what action is taken for back-facing
 polygons when the stencil test passes, but the depth test fails. The
 initial value is <CODE class="constant">GL_KEEP</CODE>. See <A class="citerefentry"
href="#glStencilOpSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_BACK_PASS_DEPTH_PASS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating what action is taken for back-facing
 polygons when the stencil test passes and the depth test passes. The
 initial value is <CODE class="constant">GL_KEEP</CODE>. See <A class="citerefentry"
href="#glStencilOpSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_BACK_REF</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the reference value that is compared with the contents of the stencil
 buffer for back-facing polygons. The initial value is 0. See <A class="citerefentry"
href="#glStencilFuncSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_BACK_VALUE_MASK</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the mask that is used for back-facing polygons to mask both the stencil
 reference value and the stencil buffer value before they are compared.
 The initial value is all 1's. See <A class="citerefentry" href="#glStencilFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_BACK_WRITEMASK</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the mask that controls writing of the stencil bitplanes for back-facing
 polygons. The initial value is all 1's. See <A class="citerefentry" href="#glStencilMaskSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMaskSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_BITS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the number of bitplanes in the stencil buffer of the currently bound
 framebuffer.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_CLEAR_VALUE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the index to which the stencil bitplanes are cleared. The initial value
 is 0. See <A class="citerefentry" href="#glClearStencil">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glClearStencil</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_FAIL</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating what action is taken when the stencil test
 fails for front-facing polygons and non-polygons. The initial value is <CODE
class="constant">GL_KEEP</CODE>. See <A class="citerefentry" href="#glStencilOp">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A> and <A class="citerefentry" href="#glStencilOpSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_FUNC</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating what function is used to compare the
 stencil reference value with the stencil buffer value for front-facing
 polygons and non-polygons. The initial value is <CODE class="constant">
GL_ALWAYS</CODE>. See <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A> and <A class="citerefentry" href="#glStencilFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_PASS_DEPTH_FAIL</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating what action is taken when the stencil test
 passes, but the depth test fails for front-facing polygons and
 non-polygons. The initial value is <CODE class="constant">GL_KEEP</CODE>
. See <A class="citerefentry" href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A> and <A class="citerefentry" href="#glStencilOpSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_PASS_DEPTH_PASS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, a
 symbolic constant indicating what action is taken when the stencil test
 passes and the depth test passes for front-facing polygons and
 non-polygons. The initial value is <CODE class="constant">GL_KEEP</CODE>
. See <A class="citerefentry" href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A> and <A class="citerefentry" href="#glStencilOpSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_REF</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the reference value that is compared with the contents of the stencil
 buffer for front-facing polygons and non-polygons. The initial value is
 0. See <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A> and <A class="citerefentry" href="#glStencilFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_TEST</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 boolean value indicating whether stencil testing of fragments is
 enabled. The initial value is <CODE class="constant">GL_FALSE</CODE>.
 See <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A> and <A class="citerefentry" href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_VALUE_MASK</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the mask that is used to mask both the stencil reference value and the
 stencil buffer value before they are compared for front-facing polygons
 and non-polygons. The initial value is all 1's. See <A class="citerefentry"
href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A> and <A class="citerefentry" href="#glStencilFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_STENCIL_WRITEMASK</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the mask that controls writing of the stencil bitplanes for
 front-facing polygons and non-polygons. The initial value is all 1's.
 See <A class="citerefentry" href="#glStencilMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A> and <A class="citerefentry" href="#glStencilMaskSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMaskSeparate</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SUBPIXEL_BITS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value, an
 estimate of the number of bits of subpixel resolution that are used to
 position rasterized geometry in window coordinates. The value must be
 at least 4.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_TEXTURE_BINDING_2D</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value, the name of the texture currently bound to the target <CODE class="constant">
GL_TEXTURE_2D</CODE> for the active multitexture unit. The initial value
 is 0. See <A class="citerefentry" href="#glBindTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindTexture</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_TEXTURE_BINDING_CUBE_MAP</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value, the name of the texture currently bound to the target <CODE class="constant">
GL_TEXTURE_CUBE_MAP</CODE> for the active multitexture unit. The initial
 value is 0. See <A class="citerefentry" href="#glBindTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindTexture</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_UNPACK_ALIGNMENT</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns one value,
 the byte alignment used for reading pixel data from memory. The initial
 value is 4. See <A class="citerefentry" href="#glPixelStorei">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPixelStorei</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_VIEWPORT</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns four values:
 the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 x and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 y window coordinates of the viewport, followed by its width and height.
 Initially the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 x and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 y window coordinates are both set to 0, and the width and height are
 set to the width and height of the window into which the GL will do its
 rendering. See <A class="citerefentry" href="#glViewport">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glViewport</A>.</P>
</DD>
</DL>
</DIV>
<P> Many of the boolean parameters can also be queried more easily using
 <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3073">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>pname</CODE></EM> is not one of the values listed previously.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3074">See Also</A></H2>
<P> <A class="citerefentry" href="#glGetActiveAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveAttrib</A>, <A class="citerefentry" href="#glGetActiveUniform">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveUniform</A>, <A class="citerefentry" href="#glGetAttachedShaders">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttachedShaders</A>, <A class="citerefentry" href="#glGetAttribLocation">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttribLocation</A>, <A class="citerefentry" href="#glGetBufferParameteriv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetBufferParameteriv</A>, <A class="citerefentry" href="#glGetError">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetError</A>, <A class="citerefentry" href="#glGetFramebufferAttachmentParameteriv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetFramebufferAttachmentParameteriv</A>, <A class="citerefentry" href="#glGetProgramiv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A>, <A class="citerefentry" href="#glGetProgramInfoLog">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramInfoLog</A>, <A class="citerefentry" href="#glGetRenderbufferParameteriv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetRenderbufferParameteriv</A>, <A class="citerefentry" href="#glGetShaderiv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A>, <A class="citerefentry" href="#glGetShaderInfoLog">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderInfoLog</A>, <A class="citerefentry" href="#glGetShaderSource">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderSource</A>, <A class="citerefentry" href="#glGetString">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetString</A>, <A class="citerefentry" href="#glGetTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetTexParameter</A>, <A class="citerefentry" href="#glGetUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniform</A>, <A class="citerefentry" href="#glGetUniformLocation">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniformLocation</A>, <A class="citerefentry" href="#glGetVertexAttrib">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttrib</A>, <A class="citerefentry" href="#glGetVertexAttribPointerv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttribPointerv</A>, <A class="citerefentry" href="#glIsEnabled">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetActiveAttrib"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3076">Name</A></H2>
<P>glGetActiveAttrib -- return information about an active attribute
 variable</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3077">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetActiveAttrib</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> program</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> bufSize</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei *<VAR class="pdparam">length</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam">size</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum *<VAR class="pdparam">type</VAR>,</TD></TR>
<TR><TD></TD><TD>GLchar *<VAR class="pdparam">name</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3078">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the program object to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>index</CODE></EM></DT>
<DD>
<P>Specifies the index of the attribute variable to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>bufSize</CODE></EM></DT>
<DD>
<P>Specifies the maximum number of characters OpenGL is allowed to write
 in the character buffer indicated by<EM class="parameter"> <CODE>name</CODE>
</EM>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>length</CODE></EM></DT>
<DD>
<P>Returns the number of characters actually written by OpenGL in the
 string indicated by<EM class="parameter"> <CODE>name</CODE></EM>
 (excluding the null terminator) if a value other than <CODE class="constant">
NULL</CODE> is passed.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>size</CODE></EM></DT>
<DD>
<P>Returns the size of the attribute variable.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>type</CODE></EM></DT>
<DD>
<P>Returns the data type of the attribute variable.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>name</CODE></EM></DT>
<DD>
<P>Returns a null terminated string containing the name of the attribute
 variable.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3079">Description</A></H2>
<P><CODE class="function">glGetActiveAttrib</CODE> returns information
 about an active attribute variable in the program object specified by<EM
class="parameter"> <CODE>program</CODE></EM>. The number of active
 attributes can be obtained by calling <A class="citerefentry" href="#glGetProgramiv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with the value <CODE class="constant">
GL_ACTIVE_ATTRIBUTES</CODE>. A value of 0 for<EM class="parameter"> <CODE>
index</CODE></EM> selects the first active attribute variable.
 Permissible values for<EM class="parameter"> <CODE>index</CODE></EM>
 range from 0 to the number of active attribute variables minus 1.</P>
<P>Attribute variables have arbitrary names and obtain their values
 through numbered generic vertex attributes. An attribute variable is
 considered active if it is determined during the link operation that it
 may be accessed during program execution. Therefore,<EM class="parameter">
 <CODE>program</CODE></EM> should have previously been the target of a
 call to <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, but it is not necessary for it to have been linked
 successfully.</P>
<P>The size of the character buffer required to store the longest
 attribute variable name in<EM class="parameter"> <CODE>program</CODE></EM>
 can be obtained by calling <A class="citerefentry" href="#glGetProgramiv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with the value <CODE class="constant">
GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</CODE>. This value should be used to
 allocate a buffer of sufficient size to store the returned attribute
 name. The size of this character buffer is passed in<EM class="parameter">
 <CODE>bufSize</CODE></EM>, and a pointer to this character buffer is
 passed in<EM class="parameter"> <CODE>name</CODE></EM>.</P>
<P><CODE class="function">glGetActiveAttrib</CODE> returns the name of
 the attribute variable indicated by<EM class="parameter"> <CODE>index</CODE>
</EM>, storing it in the character buffer specified by<EM class="parameter">
 <CODE>name</CODE></EM>. The string returned will be null terminated.
 The actual number of characters written into this buffer is returned in<EM
class="parameter"> <CODE>length</CODE></EM>, and this count does not
 include the null termination character. If the length of the returned
 string is not required, a value of <CODE class="constant">NULL</CODE>
 can be passed in the<EM class="parameter"> <CODE>length</CODE></EM>
 argument.</P>
<P>The<EM class="parameter"> <CODE>type</CODE></EM> argument will return
 a pointer to the attribute variable's data type. The symbolic constants
 <CODE class="constant">GL_FLOAT</CODE>, <CODE class="constant">
GL_FLOAT_VEC2</CODE>, <CODE class="constant">GL_FLOAT_VEC3</CODE>, <CODE class="constant">
GL_FLOAT_VEC4</CODE>, <CODE class="constant">GL_FLOAT_MAT2</CODE>, <CODE class="constant">
GL_FLOAT_MAT3</CODE>, or <CODE class="constant">GL_FLOAT_MAT4</CODE> may
 be returned. The<EM class="parameter"> <CODE>size</CODE></EM> argument
 will return the size of the attribute, in units of the type returned in<EM
class="parameter"> <CODE>type</CODE></EM>.</P>
<P>This function will return as much information as it can about the
 specified active attribute variable. If no information is available,<EM class="parameter">
 <CODE>length</CODE></EM> will be 0, and<EM class="parameter"> <CODE>
name</CODE></EM> will be an empty string. This situation could occur if
 this function is called after a link operation that failed. If an error
 occurs, the return values<EM class="parameter"> <CODE>length</CODE></EM>
,<EM class="parameter"> <CODE>size</CODE></EM>,<EM class="parameter"> <CODE>
type</CODE></EM>, and<EM class="parameter"> <CODE>name</CODE></EM> will
 be unmodified.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3080">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>index</CODE></EM> is greater than or equal to the number of
 active attribute variables in<EM class="parameter"> <CODE>program</CODE>
</EM>.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>bufSize</CODE></EM> is less than 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3081">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_VERTEX_ATTRIBS</CODE>
.</P>
<P><A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with argument <CODE class="constant">
GL_ACTIVE_ATTRIBUTES</CODE> or <CODE class="constant">
GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</CODE>.</P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3082">See Also</A></H2>
<P><A class="citerefentry" href="#glBindAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindAttribLocation</A>, <A class="citerefentry" href="#glGetActiveUniform">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveUniform</A>, <A class="citerefentry" href="#glLinkProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttrib</A>, <A class="citerefentry" href="#glVertexAttribPointer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttribPointer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetActiveUniform">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3084">Name</A></H2>
<P>glGetActiveUniform -- return information about an active uniform
 variable</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3085">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetActiveUniform</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> program</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> bufSize</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei *<VAR class="pdparam">length</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam">size</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum *<VAR class="pdparam">type</VAR>,</TD></TR>
<TR><TD></TD><TD>GLchar *<VAR class="pdparam">name</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3086">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the program object to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>index</CODE></EM></DT>
<DD>
<P>Specifies the index of the uniform variable to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>bufSize</CODE></EM></DT>
<DD>
<P>Specifies the maximum number of characters OpenGL is allowed to write
 in the character buffer indicated by<EM class="parameter"> <CODE>name</CODE>
</EM>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>length</CODE></EM></DT>
<DD>
<P>Returns the number of characters actually written by OpenGL in the
 string indicated by<EM class="parameter"> <CODE>name</CODE></EM>
 (excluding the null terminator) if a value other than <CODE class="constant">
NULL</CODE> is passed.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>size</CODE></EM></DT>
<DD>
<P>Returns the size of the uniform variable.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>type</CODE></EM></DT>
<DD>
<P>Returns the data type of the uniform variable.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>name</CODE></EM></DT>
<DD>
<P>Returns a null terminated string containing the name of the uniform
 variable.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3087">Description</A></H2>
<P><CODE class="function">glGetActiveUniform</CODE> returns information
 about an active uniform variable in the program object specified by<EM class="parameter">
 <CODE>program</CODE></EM>. The number of active uniform variables can
 be obtained by calling <A class="citerefentry" href="#glGetProgramiv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with the value <CODE class="constant">
GL_ACTIVE_UNIFORMS</CODE>. A value of 0 for<EM class="parameter"> <CODE>
index</CODE></EM> selects the first active uniform variable. Permissible
 values for<EM class="parameter"> <CODE>index</CODE></EM> range from 0
 to the number of active uniform variables minus 1.</P>
<P>Shaders may use either built-in uniform variables, user-defined
 uniform variables, or both. Built-in uniform variables have a prefix of
 &quot;gl_&quot; and reference existing OpenGL state or values derived from such
 state (e.g.,<EM class="parameter"> <CODE>gl_DepthRange</CODE></EM>).
 User-defined uniform variables have arbitrary names and obtain their
 values from the application through calls to <A class="citerefentry" href="#glUniform">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUniform</A>. A uniform variable (either built-in or user-defined) is
 considered active if it is determined during the link operation that it
 may be accessed during program execution. Therefore,<EM class="parameter">
 <CODE>program</CODE></EM> should have previously been the target of a
 call to <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, but it is not necessary for it to have been linked
 successfully.</P>
<P>The size of the character buffer required to store the longest
 uniform variable name in<EM class="parameter"> <CODE>program</CODE></EM>
 can be obtained by calling <A class="citerefentry" href="#glGetProgramiv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with the value <CODE class="constant">
GL_ACTIVE_UNIFORM_MAX_LENGTH</CODE>. This value should be used to
 allocate a buffer of sufficient size to store the returned uniform
 variable name. The size of this character buffer is passed in<EM class="parameter">
 <CODE>bufSize</CODE></EM>, and a pointer to this character buffer is
 passed in<EM class="parameter"> <CODE>name.</CODE></EM></P>
<P><CODE class="function">glGetActiveUniform</CODE> returns the name of
 the uniform variable indicated by<EM class="parameter"> <CODE>index</CODE>
</EM>, storing it in the character buffer specified by<EM class="parameter">
 <CODE>name</CODE></EM>. The string returned will be null terminated.
 The actual number of characters written into this buffer is returned in<EM
class="parameter"> <CODE>length</CODE></EM>, and this count does not
 include the null termination character. If the length of the returned
 string is not required, a value of <CODE class="constant">NULL</CODE>
 can be passed in the<EM class="parameter"> <CODE>length</CODE></EM>
 argument.</P>
<P>The<EM class="parameter"> <CODE>type</CODE></EM> argument will return
 a pointer to the uniform variable's data type. The symbolic constants <CODE
class="constant">GL_FLOAT</CODE>, <CODE class="constant">GL_FLOAT_VEC2</CODE>
, <CODE class="constant">GL_FLOAT_VEC3</CODE>, <CODE class="constant">
GL_FLOAT_VEC4</CODE>, <CODE class="constant">GL_INT</CODE>, <CODE class="constant">
GL_INT_VEC2</CODE>, <CODE class="constant">GL_INT_VEC3</CODE>, <CODE class="constant">
GL_INT_VEC4</CODE>, <CODE class="constant">GL_BOOL</CODE>, <CODE class="constant">
GL_BOOL_VEC2</CODE>, <CODE class="constant">GL_BOOL_VEC3</CODE>, <CODE class="constant">
GL_BOOL_VEC4</CODE>, <CODE class="constant">GL_FLOAT_MAT2</CODE>, <CODE class="constant">
GL_FLOAT_MAT3</CODE>, <CODE class="constant">GL_FLOAT_MAT4</CODE>, <CODE class="constant">
GL_SAMPLER_2D</CODE>, or <CODE class="constant">GL_SAMPLER_CUBE</CODE>
 may be returned.</P>
<P>If one or more elements of an array are active, the name of the array
 is returned in<EM class="parameter"> <CODE>name</CODE></EM>, the type
 is returned in<EM class="parameter"> <CODE>type</CODE></EM>, and the<EM class="parameter">
 <CODE>size</CODE></EM> parameter returns the highest array element
 index used, plus one, as determined by the compiler and/or linker. Only
 one active uniform variable will be reported for a uniform array.</P>
<P>Uniform variables that are declared as structures or arrays of
 structures will not be returned directly by this function. Instead,
 each of these uniform variables will be reduced to its fundamental
 components containing the &quot;.&quot; and &quot;[]&quot; operators such that each of the
 names is valid as an argument to <A class="citerefentry" href="#glGetUniformLocation">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniformLocation</A>. Each of these reduced uniform variables is
 counted as one active uniform variable and is assigned an index. A
 valid name cannot be a structure, an array of structures, or a
 subcomponent of a vector or matrix.</P>
<P>The size of the uniform variable will be returned in<EM class="parameter">
 <CODE>size</CODE></EM>. Uniform variables other than arrays will have a
 size of 1. Structures and arrays of structures will be reduced as
 described earlier, such that each of the names returned will be a data
 type in the earlier list. If this reduction results in an array, the
 size returned will be as described for uniform arrays; otherwise, the
 size returned will be 1.</P>
<P>The list of active uniform variables may include both built-in
 uniform variables (which begin with the prefix &quot;gl_&quot;) as well as
 user-defined uniform variable names.</P>
<P>This function will return as much information as it can about the
 specified active uniform variable. If no information is available,<EM class="parameter">
 <CODE>length</CODE></EM> will be 0, and<EM class="parameter"> <CODE>
name</CODE></EM> will be an empty string. This situation could occur if
 this function is called after a link operation that failed. If an error
 occurs, the return values<EM class="parameter"> <CODE>length</CODE></EM>
,<EM class="parameter"> <CODE>size</CODE></EM>,<EM class="parameter"> <CODE>
type</CODE></EM>, and<EM class="parameter"> <CODE>name</CODE></EM> will
 be unmodified.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3088">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>index</CODE></EM> is greater than or equal to the number of
 active uniform variables in<EM class="parameter"> <CODE>program</CODE></EM>
.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>bufSize</CODE></EM> is less than 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3089">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">
GL_MAX_VERTEX_UNIFORM_VECTORS</CODE> or <CODE class="constant">
GL_MAX_FRAGMENT_UNIFORM_VECTORS</CODE>.</P>
<P><A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with argument <CODE class="constant">
GL_ACTIVE_UNIFORMS</CODE> or <CODE class="constant">
GL_ACTIVE_UNIFORM_MAX_LENGTH</CODE>.</P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3090">See Also</A></H2>
<P><A class="citerefentry" href="#glGetActiveAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveAttrib</A>, <A class="citerefentry" href="#glGetUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniform</A>, <A class="citerefentry" href="#glGetUniformLocation">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniformLocation</A>, <A class="citerefentry" href="#glLinkProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUniform</A>, <A class="citerefentry" href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetAttachedShaders">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3092">Name</A></H2>
<P>glGetAttachedShaders -- return the handles of the shader objects
 attached to a program object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3093">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glGetAttachedShaders</B>(</CODE></TD><TD>GLuint<VAR class="pdparam">
 program</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> maxCount</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei *<VAR class="pdparam">count</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint *<VAR class="pdparam">shaders</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3094">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the program object to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>maxCount</CODE></EM></DT>
<DD>
<P>Specifies the size of the array for storing the returned object
 names.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>count</CODE></EM></DT>
<DD>
<P>Returns the number of names actually returned in<EM class="parameter">
 <CODE>objects</CODE></EM>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shaders</CODE></EM></DT>
<DD>
<P>Specifies an array that is used to return the names of attached
 shader objects.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3095">Description</A></H2>
<P><CODE class="function">glGetAttachedShaders</CODE> returns the names
 of the shader objects attached to<EM class="parameter"> <CODE>program</CODE>
</EM>. The names of shader objects that are attached to<EM class="parameter">
 <CODE>program</CODE></EM> will be returned in<EM class="parameter"> <CODE>
shaders.</CODE></EM> The actual number of shader names written into<EM class="parameter">
 <CODE>shaders</CODE></EM> is returned in<EM class="parameter"> <CODE>
count.</CODE></EM> If no shader objects are attached to<EM class="parameter">
 <CODE>program</CODE></EM>,<EM class="parameter"> <CODE>count</CODE></EM>
 is set to 0. The maximum number of shader names that may be returned in<EM
class="parameter"> <CODE>shaders</CODE></EM> is specified by<EM class="parameter">
 <CODE>maxCount</CODE></EM>.</P>
<P>If the number of names actually returned is not required (for
 instance, if it has just been obtained by calling <A class="citerefentry"
href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A>), a value of <CODE class="constant">NULL</CODE> may
 be passed for count. If no shader objects are attached to<EM class="parameter">
 <CODE>program</CODE></EM>, a value of 0 will be returned in<EM class="parameter">
 <CODE>count</CODE></EM>. The actual number of attached shaders can be
 obtained by calling <A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with the value <CODE class="constant">
GL_ATTACHED_SHADERS</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3096">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>maxCount</CODE></EM> is less than 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3097">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with argument <CODE class="constant">
GL_ATTACHED_SHADERS</CODE></P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3098">See Also</A></H2>
<P><A class="citerefentry" href="#glAttachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glAttachShader</A>, <A class="citerefentry" href="#glDetachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDetachShader</A></P>
.</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetAttribLocation">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3100">Name</A></H2>
<P>glGetAttribLocation -- return the location of an attribute variable</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3101">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLint<B class="fsfunc">
 glGetAttribLocation</B>(</CODE></TD><TD>GLuint<VAR class="pdparam">
 program</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLchar *<VAR class="pdparam">name</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3102">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the program object to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>name</CODE></EM></DT>
<DD>
<P>Points to a null terminated string containing the name of the
 attribute variable whose location is to be queried.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3103">Description</A></H2>
<P><CODE class="function">glGetAttribLocation</CODE> queries the
 previously linked program object specified by<EM class="parameter"> <CODE>
program</CODE></EM> for the attribute variable specified by<EM class="parameter">
 <CODE>name</CODE></EM> and returns the index of the generic vertex
 attribute that is bound to that attribute variable. If<EM class="parameter">
 <CODE>name</CODE></EM> is a matrix attribute variable, the index of the
 first column of the matrix is returned. If the named attribute variable
 is not an active attribute in the specified program object or if<EM class="parameter">
 <CODE>name</CODE></EM> starts with the reserved prefix &quot;gl_&quot;, a value
 of -1 is returned.</P>
<P>The association between an attribute variable name and a generic
 attribute index can be specified at any time by calling <A class="citerefentry"
href="#glBindAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindAttribLocation</A>. Attribute bindings do not go into effect until
 <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A> is called. After a program object has been linked
 successfully, the index values for attribute variables remain fixed
 until the next link command occurs. The attribute values can only be
 queried after a link if the link was successful. <CODE class="function">
glGetAttribLocation</CODE> returns the binding that actually went into
 effect the last time <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A> was called for the specified program object. Attribute
 bindings that have been specified since the last link operation are not
 returned by <CODE class="function">glGetAttribLocation</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3104">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> has not been successfully linked.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3105">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetActiveAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveAttrib</A> with argument<EM class="parameter"> <CODE>program</CODE>
</EM> and the index of an active attribute</P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3106">See Also</A></H2>
<P><A class="citerefentry" href="#glBindAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindAttribLocation</A>, <A class="citerefentry" href="#glLinkProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttrib</A>, <A class="citerefentry" href="#glVertexAttribPointer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttribPointer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetBufferParameteriv">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3108">Name</A></H2>
<P>glGetBufferParameteriv -- return parameters of a buffer object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3109">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glGetBufferParameteriv</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> value</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam"> data</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3110">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target buffer object. The symbolic constant must be <CODE
class="constant">GL_ARRAY_BUFFER</CODE> or <CODE class="constant">
GL_ELEMENT_ARRAY_BUFFER</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>value</CODE></EM></DT>
<DD>
<P> Specifies the symbolic name of a buffer object parameter. Accepted
 values are <CODE class="constant">GL_BUFFER_SIZE</CODE> or <CODE class="constant">
GL_BUFFER_USAGE</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>data</CODE></EM></DT>
<DD>
<P> Returns the requested parameter.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3111">Description</A></H2>
<P> <CODE class="function">glGetBufferParameteriv</CODE> returns in<EM class="parameter">
 <CODE>data</CODE></EM> a selected parameter of the buffer object
 specified by<EM class="parameter"> <CODE>target</CODE></EM>.</P>
<P><EM class="parameter"> <CODE>value</CODE></EM> names a specific
 buffer object parameter, as follows:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_BUFFER_SIZE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the size of
 the buffer object, measured in bytes. The initial value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_BUFFER_USAGE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the buffer
 object's usage pattern. The initial value is <CODE class="constant">
GL_STATIC_DRAW</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3112">Notes</A></H2>
<P> If an error is generated, no change is made to the contents of<EM class="parameter">
 <CODE>data</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3113">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> or<EM class="parameter"> <CODE>value</CODE></EM>
 is not an accepted value.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the reserved buffer object name 0 is bound to<EM class="parameter"> <CODE>
target</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3114">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>, <A class="citerefentry" href="#glBufferData">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBufferData</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetError"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3116">Name</A></H2>
<P>glGetError -- return error information</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3117">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLenum<B class="fsfunc"> glGetError</B>(</CODE>
</TD><TD><VAR class="pdparam"> void</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="description"></A>
<H2><A NAME="0_3118">Description</A></H2>
<P> <CODE class="function">glGetError</CODE> returns the value of the
 error flag. Each detectable error is assigned a numeric code and
 symbolic name. When an error occurs, the error flag is set to the
 appropriate error code value. No other errors are recorded until <CODE class="function">
glGetError</CODE> is called, the error code is returned, and the flag is
 reset to <CODE class="constant">GL_NO_ERROR</CODE>. If a call to <CODE class="function">
glGetError</CODE> returns <CODE class="constant">GL_NO_ERROR</CODE>,
 there has been no detectable error since the last call to <CODE class="function">
glGetError</CODE>, or since the GL was initialized.</P>
<P> To allow for distributed implementations, there may be several error
 flags. If any single error flag has recorded an error, the value of
 that flag is returned and that flag is reset to <CODE class="constant">
GL_NO_ERROR</CODE> when <CODE class="function">glGetError</CODE> is
 called. If more than one flag has recorded an error, <CODE class="function">
glGetError</CODE> returns and clears an arbitrary error flag value.
 Thus, <CODE class="function">glGetError</CODE> should always be called
 in a loop, until it returns <CODE class="constant">GL_NO_ERROR</CODE>,
 if all error flags are to be reset.</P>
<P> Initially, all error flags are set to <CODE class="constant">
GL_NO_ERROR</CODE>.</P>
<P> The following errors are currently defined:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NO_ERROR</CODE></DT>
<DD>
<P> No error has been recorded. The value of this symbolic constant is
 guaranteed to be 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_INVALID_ENUM</CODE></DT>
<DD>
<P> An unacceptable value is specified for an enumerated argument. The
 offending command is ignored and has no other side effect than to set
 the error flag.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_INVALID_VALUE</CODE></DT>
<DD>
<P> A numeric argument is out of range. The offending command is ignored
 and has no other side effect than to set the error flag.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_INVALID_OPERATION</CODE></DT>
<DD>
<P> The specified operation is not allowed in the current state. The
 offending command is ignored and has no other side effect than to set
 the error flag.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_INVALID_FRAMEBUFFER_OPERATION</CODE></DT>
<DD>
<P> The command is trying to render to or read from the framebuffer
 while the currently bound framebuffer is not framebuffer complete (i.e.
 the return value from <A class="citerefentry" href="#glCheckFramebufferStatus">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A> is not <CODE class="constant">
GL_FRAMEBUFFER_COMPLETE</CODE>). The offending command is ignored and
 has no other side effect than to set the error flag.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_OUT_OF_MEMORY</CODE></DT>
<DD>
<P> There is not enough memory left to execute the command. The state of
 the GL is undefined, except for the state of the error flags, after
 this error is recorded.</P>
</DD>
</DL>
</DIV>
<P> When an error flag is set, results of a GL operation are undefined
 only if <CODE class="constant">GL_OUT_OF_MEMORY</CODE> has occurred. In
 all other cases, the command generating the error is ignored and has no
 effect on the GL state or frame buffer contents. If the generating
 command returns a value, it returns 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3119">See Also</A></H2>
<P> <A class="citerefentry" href="#glCheckFramebufferStatus">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetFramebufferAttachmentParameteriv">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3121">Name</A></H2>
<P>glGetFramebufferAttachmentParameteriv -- return attachment
 parameters of a framebuffer object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3122">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glGetFramebufferAttachmentParameteriv</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> attachment</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam"> params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3123">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target framebuffer object. The symbolic constant must
 be <CODE class="constant">GL_FRAMEBUFFER</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>attachment</CODE></EM></DT>
<DD>
<P> Specifies the symbolic name of a framebuffer object attachment
 point. Accepted values are <CODE class="constant">GL_COLOR_ATTACHMENT0</CODE>
, <CODE class="constant">GL_DEPTH_ATTACHMENT</CODE>, and <CODE class="constant">
GL_STENCIL_ATTACHMENT</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pname</CODE></EM></DT>
<DD>
<P> Specifies the symbolic name of a framebuffer object attachment
 parameter. Accepted values are <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE>, <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</CODE>, <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</CODE>, and <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>params</CODE></EM></DT>
<DD>
<P> Returns the requested parameter.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3124">Description</A></H2>
<P> <CODE class="function">glGetFramebufferAttachmentParameteriv</CODE>
 returns in<EM class="parameter"> <CODE>params</CODE></EM> a selected
 attachment parameter of the attachpoint point<EM class="parameter"> <CODE>
attachment</CODE></EM> of the currently bound framebuffer object.</P>
<P><EM class="parameter"> <CODE>pname</CODE></EM> names a specific
 framebuffer object attachment parameter, as follows:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the type of
 object which contains the attached image, either <CODE class="constant">
GL_RENDERBUFFER</CODE>, <CODE class="constant">GL_TEXTURE</CODE>, or if
 no image is attached, <CODE class="constant">GL_NONE</CODE>. The
 initial value is <CODE class="constant">GL_NONE</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</CODE></DT>
<DD>
<P> If the value of <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE> is <CODE class="constant">
GL_RENDERBUFFER</CODE>,<EM class="parameter"> <CODE>params</CODE></EM>
 returns the name of the renderbuffer object which contains the attached
 image. If the value of <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE> is <CODE class="constant">
GL_TEXTURE</CODE>,<EM class="parameter"> <CODE>params</CODE></EM>
 returns the name of the texture object which contains the attached
 image. The initial value is zero.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</CODE></DT>
<DD>
<P> If the value of <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE> is <CODE class="constant">
GL_TEXTURE</CODE>,<EM class="parameter"> <CODE>params</CODE></EM>
 returns the mipmap level of the texture object which contains the
 attached image. The initial value is zero.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</CODE>
</DT>
<DD>
<P> If the value of <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE> is <CODE class="constant">
GL_TEXTURE</CODE> and <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</CODE> is the name of a cube-map
 texture,<EM class="parameter"> <CODE>params</CODE></EM> returns the
 cube map face of the cube-map texture object which contains the
 attached image. If the attached image is from a texture object but not
 a cube-map,<EM class="parameter"> <CODE>params</CODE></EM> returns 0.
 The initial value is <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3125">Notes</A></H2>
<P> If an error is generated, no change is made to the contents of<EM class="parameter">
 <CODE>params</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3126">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_FRAMEBUFFER</CODE>
.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>attachment</CODE></EM> is not <CODE class="constant">
GL_COLOR_ATTACHMENT0</CODE>, <CODE class="constant">GL_DEPTH_ATTACHMENT</CODE>
, or <CODE class="constant">GL_STENCIL_ATTACHMENT</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if the
 attached object at the named attachment point is <CODE class="constant">
GL_RENDERBUFFER</CODE> and<EM class="parameter"> <CODE>pname</CODE></EM>
 is not <CODE class="constant">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE>
 or <CODE class="constant">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if the
 attached object at the named attachment point is <CODE class="constant">
GL_TEXTURE</CODE> and<EM class="parameter"> <CODE>pname</CODE></EM> is
 not <CODE class="constant">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE>
, <CODE class="constant">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</CODE>, <CODE
class="constant">GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</CODE>, or <CODE
class="constant">GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if there
 is no attached object at the named attachment point and<EM class="parameter">
 <CODE>pname</CODE></EM> is not <CODE class="constant">
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the default framebuffer object name 0 is bound.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3127">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindFramebuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindFramebuffer</A>, <A class="citerefentry" href="#glFramebufferRenderbuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFramebufferRenderbuffer</A>, <A class="citerefentry" href="#glFramebufferTexture2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFramebufferTexture2D</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetProgramInfoLog">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3129">Name</A></H2>
<P>glGetProgramInfoLog -- return the information log for a program
 object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3130">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetProgramInfoLog</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> program</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> maxLength</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei *<VAR class="pdparam">length</VAR>,</TD></TR>
<TR><TD></TD><TD>GLchar *<VAR class="pdparam">infoLog</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3131">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the program object whose information log is to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>maxLength</CODE></EM></DT>
<DD>
<P>Specifies the size of the character buffer for storing the returned
 information log.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>length</CODE></EM></DT>
<DD>
<P>Returns the length of the string returned in<EM class="parameter"> <CODE>
infoLog</CODE></EM> (excluding the null terminator).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>infoLog</CODE></EM></DT>
<DD>
<P>Specifies an array of characters that is used to return the
 information log.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3132">Description</A></H2>
<P><CODE class="function">glGetProgramInfoLog</CODE> returns the
 information log for the specified program object. The information log
 for a program object is modified when the program object is linked or
 validated. The string that is returned will be null terminated.</P>
<P><CODE class="function">glGetProgramInfoLog</CODE> returns in<EM class="parameter">
 <CODE>infoLog</CODE></EM> as much of the information log as it can, up
 to a maximum of<EM class="parameter"> <CODE>maxLength</CODE></EM>
 characters. The number of characters actually returned, excluding the
 null termination character, is specified by<EM class="parameter"> <CODE>
length</CODE></EM>. If the length of the returned string is not
 required, a value of <CODE class="constant">NULL</CODE> can be passed
 in the<EM class="parameter"> <CODE>length</CODE></EM> argument. The
 size of the buffer required to store the returned information log can
 be obtained by calling <A class="citerefentry" href="#glGetProgramiv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with the value <CODE class="constant">
GL_INFO_LOG_LENGTH</CODE>.</P>
<P>The information log for a program object is either an empty string,
 or a string containing information about the last link operation, or a
 string containing information about the last validation operation. It
 may contain diagnostic messages, warning messages, and other
 information. When a program object is created, its information log will
 be a string of length 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3133">Notes</A></H2>
<P>The information log for a program object is the OpenGL implementer's
 primary mechanism for conveying information about linking and
 validating. Therefore, the information log can be helpful to
 application developers during the development process, even when these
 operations are successful. Application developers should not expect
 different OpenGL implementations to produce identical information logs.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3134">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>maxLength</CODE></EM> is less than 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3135">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with argument <CODE class="constant">
GL_INFO_LOG_LENGTH</CODE></P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3136">See Also</A></H2>
<P><A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glGetShaderInfoLog">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderInfoLog</A>, <A class="citerefentry" href="#glLinkProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glValidateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glValidateProgram</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetProgramiv"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3138">Name</A></H2>
<P>glGetProgramiv -- return a parameter from a program object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3139">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetProgramiv</B>(</CODE>
</TD><TD>GLuint<VAR class="pdparam"> program</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam">params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3140">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the program object to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pname</CODE></EM></DT>
<DD>
<P>Specifies the object parameter. Accepted symbolic names are <CODE class="constant">
GL_DELETE_STATUS</CODE>, <CODE class="constant">GL_LINK_STATUS</CODE>, <CODE
class="constant">GL_VALIDATE_STATUS</CODE>, <CODE class="constant">
GL_INFO_LOG_LENGTH</CODE>, <CODE class="constant">GL_ATTACHED_SHADERS</CODE>
, <CODE class="constant">GL_ACTIVE_ATTRIBUTES</CODE>, <CODE class="constant">
GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</CODE>, <CODE class="constant">
GL_ACTIVE_UNIFORMS</CODE>, <CODE class="constant">
GL_ACTIVE_UNIFORM_MAX_LENGTH</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>params</CODE></EM></DT>
<DD>
<P>Returns the requested object parameter.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3141">Description</A></H2>
<P><CODE class="function">glGetProgramiv</CODE> returns in<EM class="parameter">
 <CODE>params</CODE></EM> the value of a parameter for a specific
 program object. The following parameters are defined:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DELETE_STATUS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns <CODE class="constant">
GL_TRUE</CODE> if<EM class="parameter"> <CODE>program</CODE></EM> is
 currently flagged for deletion, and <CODE class="constant">GL_FALSE</CODE>
 otherwise.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LINK_STATUS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns <CODE class="constant">
GL_TRUE</CODE> if the last link operation on<EM class="parameter"> <CODE>
program</CODE></EM> was successful, and <CODE class="constant">GL_FALSE</CODE>
 otherwise.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_VALIDATE_STATUS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns <CODE class="constant">
GL_TRUE</CODE> or if the last validation operation on<EM class="parameter">
 <CODE>program</CODE></EM> was successful, and <CODE class="constant">
GL_FALSE</CODE> otherwise.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_INFO_LOG_LENGTH</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the number of
 characters in the information log for<EM class="parameter"> <CODE>
program</CODE></EM> including the null termination character (i.e., the
 size of the character buffer required to store the information log). If<EM
class="parameter"> <CODE>program</CODE></EM> has no information log, a
 value of 0 is returned.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ATTACHED_SHADERS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the number of
 shader objects attached to<EM class="parameter"> <CODE>program</CODE></EM>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ACTIVE_ATTRIBUTES</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the number of
 active attribute variables for<EM class="parameter"> <CODE>program</CODE>
</EM>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the length of
 the longest active attribute name for<EM class="parameter"> <CODE>
program</CODE></EM>, including the null termination character (i.e., the
 size of the character buffer required to store the longest attribute
 name). If no active attributes exist, 0 is returned.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ACTIVE_UNIFORMS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the number of
 active uniform variables for<EM class="parameter"> <CODE>program</CODE></EM>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ACTIVE_UNIFORM_MAX_LENGTH</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the length of
 the longest active uniform variable name for<EM class="parameter"> <CODE>
program</CODE></EM>, including the null termination character (i.e., the
 size of the character buffer required to store the longest uniform
 variable name). If no active uniform variables exist, 0 is returned.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3142">Notes</A></H2>
<P>If an error is generated, no change is made to the contents of<EM class="parameter">
 <CODE>params</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3143">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>pname</CODE></EM> is not an accepted value.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> does not refer to a program object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3144">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetActiveAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveAttrib</A> with argument<EM class="parameter"> <CODE>program</CODE>
</EM></P>
<P><A class="citerefentry" href="#glGetActiveUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveUniform</A> with argument<EM class="parameter"> <CODE>program</CODE>
</EM></P>
<P><A class="citerefentry" href="#glGetAttachedShaders">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttachedShaders</A> with argument<EM class="parameter"> <CODE>
program</CODE></EM></P>
<P><A class="citerefentry" href="#glGetProgramInfoLog">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramInfoLog</A> with argument<EM class="parameter"> <CODE>
program</CODE></EM></P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A><EM class="parameter"> <CODE></CODE></EM></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3145">See Also</A></H2>
<P><A class="citerefentry" href="#glAttachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glAttachShader</A>, <A class="citerefentry" href="#glCreateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateProgram</A>, <A class="citerefentry" href="#glDeleteProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteProgram</A>, <A class="citerefentry" href="#glGetShaderiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A>, <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glValidateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glValidateProgram</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetRenderbufferParameteriv">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3147">Name</A></H2>
<P>glGetRenderbufferParameteriv -- return parameters of a renderbuffer
 object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3148">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glGetRenderbufferParameteriv</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam"> params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3149">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target renderbuffer object. The symbolic constant must
 be <CODE class="constant">GL_RENDERBUFFER</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pname</CODE></EM></DT>
<DD>
<P> Specifies the symbolic name of a renderbuffer object parameter.
 Accepted values are <CODE class="constant">GL_RENDERBUFFER_WIDTH</CODE>
, <CODE class="constant">GL_RENDERBUFFER_HEIGHT</CODE>, <CODE class="constant">
GL_RENDERBUFFER_INTERNAL_FORMAT</CODE>, <CODE class="constant">
GL_RENDERBUFFER_RED_SIZE</CODE>, <CODE class="constant">
GL_RENDERBUFFER_GREEN_SIZE</CODE>, <CODE class="constant">
GL_RENDERBUFFER_BLUE_SIZE</CODE>, <CODE class="constant">
GL_RENDERBUFFER_ALPHA_SIZE</CODE>, <CODE class="constant">
GL_RENDERBUFFER_DEPTH_SIZE</CODE>, or <CODE class="constant">
GL_RENDERBUFFER_STENCIL_SIZE</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>params</CODE></EM></DT>
<DD>
<P> Returns the requested parameter.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3150">Description</A></H2>
<P> <CODE class="function">glGetRenderbufferParameteriv</CODE> returns
 in<EM class="parameter"> <CODE>params</CODE></EM> a selected parameter
 of the currently bound renderbuffer object.</P>
<P><EM class="parameter"> <CODE>pname</CODE></EM> names a specific
 renderbuffer object parameter, as follows:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RENDERBUFFER_WIDTH</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the width in
 pixels of the image of the currently bound renderbuffer. The initial
 value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RENDERBUFFER_HEIGHT</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the height in
 pixels of the image of the currently bound renderbuffer. The initial
 value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RENDERBUFFER_INTERNAL_FORMAT</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the internal
 format of the image of the currently bound renderbuffer. The initial
 value is <CODE class="constant">GL_RGBA4</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RENDERBUFFER_RED_SIZE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the
 resolution in bits for the red component of the image of the currently
 bound renderbuffer. The initial value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RENDERBUFFER_GREEN_SIZE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the
 resolution in bits for the green component of the image of the
 currently bound renderbuffer. The initial value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RENDERBUFFER_BLUE_SIZE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the
 resolution in bits for the blue component of the image of the currently
 bound renderbuffer. The initial value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RENDERBUFFER_ALPHA_SIZE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the
 resolution in bits for the alpha component of the image of the
 currently bound renderbuffer. The initial value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RENDERBUFFER_DEPTH_SIZE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the
 resolution in bits for the depth component of the image of the
 currently bound renderbuffer. The initial value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RENDERBUFFER_STENCIL_SIZE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns the
 resolution in bits for the stencil component of the image of the
 currently bound renderbuffer. The initial value is 0.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3151">Notes</A></H2>
<P> The resolution of components reported by <CODE class="function">
glGetRenderbufferParameteriv</CODE> are the actual resolutions at which
 the components are stored, which may be different than those requested
 by the<EM class="parameter"> <CODE>internalformat</CODE></EM> parameter
 of <A class="citerefentry" href="#glRenderbufferStorage">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glRenderbufferStorage</A>.</P>
<P> If an error is generated, no change is made to the contents of<EM class="parameter">
 <CODE>params</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3152">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_RENDERBUFFER</CODE>
.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>pname</CODE></EM> is not <CODE class="constant">
GL_RENDERBUFFER_WIDTH</CODE>, <CODE class="constant">
GL_RENDERBUFFER_HEIGHT</CODE>, <CODE class="constant">
GL_RENDERBUFFER_INTERNAL_FORMAT</CODE>, <CODE class="constant">
GL_RENDERBUFFER_RED_SIZE</CODE>, <CODE class="constant">
GL_RENDERBUFFER_GREEN_SIZE</CODE>, <CODE class="constant">
GL_RENDERBUFFER_BLUE_SIZE</CODE>, <CODE class="constant">
GL_RENDERBUFFER_ALPHA_SIZE</CODE>, <CODE class="constant">
GL_RENDERBUFFER_DEPTH_SIZE</CODE>, or <CODE class="constant">
GL_RENDERBUFFER_STENCIL_SIZE</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the reserved renderbuffer object name 0 is bound.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3153">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindRenderbuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindRenderBuffer</A>, <A class="citerefentry" href="#glRenderbufferStorage">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glRenderbufferStorage</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetShaderInfoLog">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3155">Name</A></H2>
<P>glGetShaderInfoLog -- return the information log for a shader object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3156">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetShaderInfoLog</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> shader</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> maxLength</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei *<VAR class="pdparam">length</VAR>,</TD></TR>
<TR><TD></TD><TD>GLchar *<VAR class="pdparam">infoLog</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3157">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shader</CODE></EM></DT>
<DD>
<P>Specifies the shader object whose information log is to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>maxLength</CODE></EM></DT>
<DD>
<P>Specifies the size of the character buffer for storing the returned
 information log.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>length</CODE></EM></DT>
<DD>
<P>Returns the length of the string returned in<EM class="parameter"> <CODE>
infoLog</CODE></EM> (excluding the null terminator).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>infoLog</CODE></EM></DT>
<DD>
<P>Specifies an array of characters that is used to return the
 information log.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3158">Description</A></H2>
<P><CODE class="function">glGetShaderInfoLog</CODE> returns the
 information log for the specified shader object. The information log
 for a shader object is modified when the shader is compiled. The string
 that is returned will be null terminated.</P>
<P><CODE class="function">glGetShaderInfoLog</CODE> returns in<EM class="parameter">
 <CODE>infoLog</CODE></EM> as much of the information log as it can, up
 to a maximum of<EM class="parameter"> <CODE>maxLength</CODE></EM>
 characters. The number of characters actually returned, excluding the
 null termination character, is specified by<EM class="parameter"> <CODE>
length</CODE></EM>. If the length of the returned string is not
 required, a value of <CODE class="constant">NULL</CODE> can be passed
 in the<EM class="parameter"> <CODE>length</CODE></EM> argument. The
 size of the buffer required to store the returned information log can
 be obtained by calling <A class="citerefentry" href="#glGetShaderiv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A> with the value <CODE class="constant">
GL_INFO_LOG_LENGTH</CODE>.</P>
<P>The information log for a shader object is a string that may contain
 diagnostic messages, warning messages, and other information about the
 last compile operation. When a shader object is created, its
 information log will be a string of length 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3159">Notes</A></H2>
<P>The information log for a shader object is the OpenGL implementer's
 primary mechanism for conveying information about the compilation
 process. Therefore, the information log can be helpful to application
 developers during the development process, even when compilation is
 successful. Application developers should not expect different OpenGL
 implementations to produce identical information logs.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3160">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not a shader object.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>maxLength</CODE></EM> is less than 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3161">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetShaderiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A> with argument <CODE class="constant">
GL_INFO_LOG_LENGTH</CODE></P>
<P><A class="citerefentry" href="#glIsShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsShader</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3162">See Also</A></H2>
<P><A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glGetProgramInfoLog">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramInfoLog</A>, <A class="citerefentry" href="#glLinkProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glValidateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glValidateProgram</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetShaderPrecisionFormat">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3164">Name</A></H2>
<P>glGetShaderPrecisionFormat -- return the range and precision for
 different shader numeric formats</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3165">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glGetShaderPrecisionFormat</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 shaderType</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> precisionType</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam">range</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam">precision</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3166">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shaderType</CODE></EM></DT>
<DD>
<P>Specifies the type of shader to query. Must be either <CODE class="constant">
GL_VERTEX_SHADER</CODE> or <CODE class="constant">GL_FRAGMENT_SHADER</CODE>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>precisionType</CODE></EM></DT>
<DD>
<P>Specifies the numeric format to query, corresponding to a shader
 precision qualifier and variable type. Must be one of <CODE class="constant">
GL_LOW_FLOAT</CODE>, <CODE class="constant">GL_MEDIUM_FLOAT</CODE>, <CODE
class="constant">GL_HIGH_FLOAT</CODE>, <CODE class="constant">GL_LOW_INT</CODE>
, <CODE class="constant">GL_MEDIUM_INT</CODE>, or <CODE class="constant">
GL_HIGH_INT</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>range</CODE></EM></DT>
<DD>
<P>Specifies a pointer to the two-element array in which the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2 of the minimum and maximum representable magnitudes of the format are
 returned.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>precision</CODE></EM></DT>
<DD>
<P>Specifies a pointer to the location in which the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2 of the precision of the format is returned.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3167">Description</A></H2>
<P><CODE class="function">glGetShaderPrecisionFormat</CODE> returns
 range and precision limits for floating-point and integer shader
 variable formats with low, medium, and high precision qualifiers. When
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 minRep and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 maxRep are the minimum and maximum representable values of the format,
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 floor
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;|&quot; close=&quot;|&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 minRep and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 floor
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;|&quot; close=&quot;|&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 maxRep are returned in<EM class="parameter"> <CODE>range</CODE></EM> as
 the first and second elements, respectively.</P>
<P>If the smallest representable value greater than 1 is
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 1
<!--mml:mo-->
 +
<!--mml:mn-->
 &acirc; then
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 floor
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mo-->
 -
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 &acirc; is returned in<EM class="parameter"> <CODE>precision</CODE></EM>.
 An integer format will have an &acirc; of 1, and thus will return 0.
 Floating-point formats will return values greater than 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3168">Notes</A></H2>
<P>The minimum range and precision required for different formats is
 described in the
<!--span class=&quot;emphasis&quot;-->
<EM> OpenGL ES Shading Language Specification.</EM></P>
<P>If a high precision floating-point format is not supported for
 fragment shaders, calling <CODE class="function">
glGetShaderPrecisionFormat</CODE> with arguments <CODE class="constant">
GL_FRAGMENT_SHADER</CODE> and <CODE class="constant">GL_HIGH_FLOAT</CODE>
 will return 0 for both<EM class="parameter"> <CODE>range</CODE></EM>
 and<EM class="parameter"> <CODE>precision</CODE></EM>. Support for a
 high precision floating-point format is mandatory for vertex shaders.</P>
<P>Shader compiler support is optional, and thus must be queried before
 use by calling <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SHADER_COMPILER</CODE>
. <A class="citerefentry" href="#glShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A>, <A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <CODE class="function">glGetShaderPrecisionFormat</CODE>
, and <A class="citerefentry" href="#glReleaseShaderCompiler">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReleaseShaderCompiler</A> will each generate <CODE class="constant">
GL_INVALID_OPERATION</CODE> on implementations that do not support a
 shader compiler. Such implementations instead offer the <A class="citerefentry"
href="#glShaderBinary">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderBinary</A> alternative for supplying a pre-compiled shader
 binary.</P>
<P>If an error is generated, no change is made to the contents of<EM class="parameter">
 <CODE>range</CODE></EM> or<EM class="parameter"> <CODE>precision</CODE></EM>
.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3169">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if a
 shader compiler is not supported.</P>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>shaderType</CODE></EM> or<EM class="parameter"> <CODE>
precisionType</CODE></EM> is not an accepted value.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3170">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SHADER_COMPILER</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3171">See Also</A></H2>
<P><A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetShaderSource"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3173">Name</A></H2>
<P>glGetShaderSource -- return the source code string from a shader
 object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3174">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetShaderSource</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> shader</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> bufSize</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei *<VAR class="pdparam">length</VAR>,</TD></TR>
<TR><TD></TD><TD>GLchar *<VAR class="pdparam">source</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3175">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shader</CODE></EM></DT>
<DD>
<P>Specifies the shader object to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>bufSize</CODE></EM></DT>
<DD>
<P>Specifies the size of the character buffer for storing the returned
 source code string.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>length</CODE></EM></DT>
<DD>
<P>Returns the length of the string returned in<EM class="parameter"> <CODE>
source</CODE></EM> (excluding the null terminator).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>source</CODE></EM></DT>
<DD>
<P>Specifies an array of characters that is used to return the source
 code string.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3176">Description</A></H2>
<P><CODE class="function">glGetShaderSource</CODE> returns the
 concatenation of the source code strings from the shader object
 specified by<EM class="parameter"> <CODE>shader</CODE></EM>. The source
 code strings for a shader object are the result of a previous call to <A
class="citerefentry" href="#glShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A>. The string returned by the function will be null
 terminated.</P>
<P><CODE class="function">glGetShaderSource</CODE> returns in<EM class="parameter">
 <CODE>source</CODE></EM> as much of the source code string as it can,
 up to a maximum of<EM class="parameter"> <CODE>bufSize</CODE></EM>
 characters. The number of characters actually returned, excluding the
 null termination character, is specified by<EM class="parameter"> <CODE>
length</CODE></EM>. If the length of the returned string is not
 required, a value of <CODE class="constant">NULL</CODE> can be passed
 in the<EM class="parameter"> <CODE>length</CODE></EM> argument. The
 size of the buffer required to store the returned source code string
 can be obtained by calling <A class="citerefentry" href="#glGetShaderiv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A> with the value <CODE class="constant">
GL_SHADER_SOURCE_LENGTH</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3177">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not a shader object.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>bufSize</CODE></EM> is less than 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3178">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetShaderiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A> with argument <CODE class="constant">
GL_SHADER_SOURCE_LENGTH</CODE></P>
<P><A class="citerefentry" href="#glIsShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsShader</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3179">See Also</A></H2>
<P><A class="citerefentry" href="#glCreateShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateShader</A>, <A class="citerefentry" href="#glShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetShaderiv"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3181">Name</A></H2>
<P>glGetShaderiv -- return a parameter from a shader object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3182">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetShaderiv</B>(</CODE>
</TD><TD>GLuint<VAR class="pdparam"> shader</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam">params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3183">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shader</CODE></EM></DT>
<DD>
<P>Specifies the shader object to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pname</CODE></EM></DT>
<DD>
<P>Specifies the object parameter. Accepted symbolic names are <CODE class="constant">
GL_SHADER_TYPE</CODE>, <CODE class="constant">GL_DELETE_STATUS</CODE>, <CODE
class="constant">GL_COMPILE_STATUS</CODE>, <CODE class="constant">
GL_INFO_LOG_LENGTH</CODE>, <CODE class="constant">
GL_SHADER_SOURCE_LENGTH</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>params</CODE></EM></DT>
<DD>
<P>Returns the requested object parameter.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3184">Description</A></H2>
<P><CODE class="function">glGetShaderiv</CODE> returns in<EM class="parameter">
 <CODE>params</CODE></EM> the value of a parameter for a specific shader
 object. The following parameters are defined:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SHADER_TYPE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns <CODE class="constant">
GL_VERTEX_SHADER</CODE> if<EM class="parameter"> <CODE>shader</CODE></EM>
 is a vertex shader object, and <CODE class="constant">
GL_FRAGMENT_SHADER</CODE> if<EM class="parameter"> <CODE>shader</CODE></EM>
 is a fragment shader object.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DELETE_STATUS</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns <CODE class="constant">
GL_TRUE</CODE> if<EM class="parameter"> <CODE>shader</CODE></EM> is
 currently flagged for deletion, and <CODE class="constant">GL_FALSE</CODE>
 otherwise.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_COMPILE_STATUS</CODE></DT>
<DD>
<P>For implementations that support a shader compiler,<EM class="parameter">
 <CODE>params</CODE></EM> returns <CODE class="constant">GL_TRUE</CODE>
 if the last compile operation on<EM class="parameter"> <CODE>shader</CODE>
</EM> was successful, and <CODE class="constant">GL_FALSE</CODE>
 otherwise.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_INFO_LOG_LENGTH</CODE></DT>
<DD>
<P>For implementations that support a shader compiler,<EM class="parameter">
 <CODE>params</CODE></EM> returns the number of characters in the
 information log for<EM class="parameter"> <CODE>shader</CODE></EM>
 including the null termination character (i.e., the size of the
 character buffer required to store the information log). If<EM class="parameter">
 <CODE>shader</CODE></EM> has no information log, a value of 0 is
 returned.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SHADER_SOURCE_LENGTH</CODE></DT>
<DD>
<P>For implementations that support a shader compiler,<EM class="parameter">
 <CODE>params</CODE></EM> returns the length of the concatenation of the
 source strings that make up the shader source for the<EM class="parameter">
 <CODE>shader</CODE></EM>, including the null termination character.
 (i.e., the size of the character buffer required to store the shader
 source). If no source code exists, 0 is returned.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3185">Notes</A></H2>
<P>Shader compiler support is optional, and thus must be queried before
 use by calling <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SHADER_COMPILER</CODE>
. <A class="citerefentry" href="#glShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A>, <A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glGetShaderPrecisionFormat">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderPrecisionFormat</A>, and <A class="citerefentry" href="#glReleaseShaderCompiler">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReleaseShaderCompiler</A> will each generate <CODE class="constant">
GL_INVALID_OPERATION</CODE> on implementations that do not support a
 shader compiler, as will <CODE class="function">glGetShaderiv</CODE>
 queries of <CODE class="constant">GL_COMPILE_STATUS</CODE>, <CODE class="constant">
GL_INFO_LOG_LENGTH</CODE>, and <CODE class="constant">
GL_SHADER_SOURCE_LENGTH</CODE>. Such implementations instead offer the <A
class="citerefentry" href="#glShaderBinary">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderBinary</A> alternative for supplying a pre-compiled shader
 binary.</P>
<P>If an error is generated, no change is made to the contents of<EM class="parameter">
 <CODE>params</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3186">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>pname</CODE></EM> is not an accepted value.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>pname</CODE></EM> is <CODE class="constant">GL_COMPILE_STATUS</CODE>
, <CODE class="constant">GL_INFO_LOG_LENGTH</CODE>, or <CODE class="constant">
GL_SHADER_SOURCE_LENGTH</CODE> but a shader compiler is not supported.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> does not refer to a shader object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3187">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SHADER_COMPILER</CODE></P>
<P><A class="citerefentry" href="#glGetShaderInfoLog">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderInfoLog</A> with argument<EM class="parameter"> <CODE>shader</CODE>
</EM></P>
<P><A class="citerefentry" href="#glGetShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderSource</A> with argument<EM class="parameter"> <CODE>shader</CODE>
</EM></P>
<P><A class="citerefentry" href="#glIsShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsShader</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3188">See Also</A></H2>
<P><A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glCreateShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateShader</A>, <A class="citerefentry" href="#glDeleteShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteShader</A>, <A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A>, <A class="citerefentry" href="#glShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A>, <A class="citerefentry" href="#glShaderBinary">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderBinary</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetString"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3190">Name</A></H2>
<P>glGetString -- return a string describing the current GL connection</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3191">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">const GLubyte*<B class="fsfunc">
 glGetString</B>(</CODE></TD><TD>GLenum<VAR class="pdparam"> name</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3192">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>name</CODE></EM></DT>
<DD>
<P> Specifies a symbolic constant, one of <CODE class="constant">
GL_VENDOR</CODE>, <CODE class="constant">GL_RENDERER</CODE>, <CODE class="constant">
GL_VERSION</CODE>, <CODE class="constant">GL_SHADING_LANGUAGE_VERSION</CODE>
, or <CODE class="constant">GL_EXTENSIONS</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3193">Description</A></H2>
<P> <CODE class="function">glGetString</CODE> returns a pointer to a
 static string describing some aspect of the current GL connection.<EM class="parameter">
 <CODE>name</CODE></EM> can be one of the following:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_VENDOR</CODE></DT>
<DD>
<P> Returns the company responsible for this GL implementation. This
 name does not change from release to release.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RENDERER</CODE></DT>
<DD>
<P> Returns the name of the renderer. This name is typically specific to
 a particular configuration of a hardware platform. It does not change
 from release to release.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_VERSION</CODE></DT>
<DD>
<P> Returns a version or release number of the form <CODE class="constant">
OpenGL&lt;space&gt;ES&lt;space&gt;&lt;version number&gt;&lt;space&gt;&lt;vendor-specific
 information&gt;</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_SHADING_LANGUAGE_VERSION</CODE></DT>
<DD>
<P> Returns a version or release number for the shading language of the
 form <CODE class="constant">
OpenGL&lt;space&gt;ES&lt;space&gt;GLSL&lt;space&gt;ES&lt;space&gt;&lt;version
 number&gt;&lt;space&gt;&lt;vendor-specific information&gt;</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_EXTENSIONS</CODE></DT>
<DD>
<P> Returns a space-separated list of supported extensions to GL.</P>
</DD>
</DL>
</DIV>
<P> Because the GL does not include queries for the performance
 characteristics of an implementation, some applications are written to
 recognize known platforms and modify their GL usage based on known
 performance characteristics of these platforms. Strings <CODE class="constant">
GL_VENDOR</CODE> and <CODE class="constant">GL_RENDERER</CODE> together
 uniquely specify a platform. They do not change from release to release
 and should be used by platform-recognition algorithms.</P>
<P> Some applications want to make use of features that are not part of
 the standard GL. These features may be implemented as extensions to the
 standard GL. The <CODE class="constant">GL_EXTENSIONS</CODE> string is
 a space-separated list of supported GL extensions. (Extension names
 never contain a space character.)</P>
<P> All strings are null-terminated.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3194">Notes</A></H2>
<P> If an error is generated, <CODE class="function">glGetString</CODE>
 returns 0.</P>
<P> The client and server may support different versions or extensions. <CODE
class="function">glGetString</CODE> always returns a compatible version
 number or list of extensions. The release number always describes the
 server.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3195">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>name</CODE></EM> is not an accepted value.</P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetTexParameter"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3197">Name</A></H2>
<P>glGetTexParameter -- return texture parameter values</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3198">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetTexParameterfv</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat *<VAR class="pdparam"> params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV><DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetTexParameteriv</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam"> params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3199">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the symbolic name of the target texture of the active
 texture unit. <CODE class="constant">GL_TEXTURE_2D</CODE> and <CODE class="constant">
GL_TEXTURE_CUBE_MAP</CODE> are accepted.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pname</CODE></EM></DT>
<DD>
<P> Specifies the symbolic name of a texture parameter. <CODE class="constant">
GL_TEXTURE_MAG_FILTER</CODE>, <CODE class="constant">
GL_TEXTURE_MIN_FILTER</CODE>, <CODE class="constant">GL_TEXTURE_WRAP_S</CODE>
, and <CODE class="constant">GL_TEXTURE_WRAP_T</CODE> are accepted.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>params</CODE></EM></DT>
<DD>
<P> Returns the texture parameter.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3200">Description</A></H2>
<P> <CODE class="function">glGetTexParameter</CODE> returns in<EM class="parameter">
 <CODE>params</CODE></EM> the value of the texture parameter specified
 as<EM class="parameter"> <CODE>pname</CODE></EM>.<EM class="parameter">
 <CODE>target</CODE></EM> defines the target texture of the active
 texture unit, either <CODE class="constant">GL_TEXTURE_2D</CODE> or <CODE
class="constant">GL_TEXTURE_CUBE_MAP</CODE>, to specify two-dimensional
 or cube-mapped texturing.<EM class="parameter"> <CODE>pname</CODE></EM>
 accepts the same symbols as <A class="citerefentry" href="#glTexParameter">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A>, with the same interpretations:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_TEXTURE_MAG_FILTER</CODE></DT>
<DD>
<P> Returns the single-valued texture magnification filter, a symbolic
 constant. The initial value is <CODE class="constant">GL_LINEAR</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_TEXTURE_MIN_FILTER</CODE></DT>
<DD>
<P> Returns the single-valued texture minification filter, a symbolic
 constant. The initial value is <CODE class="constant">
GL_NEAREST_MIPMAP_LINEAR</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_TEXTURE_WRAP_S</CODE></DT>
<DD>
<P> Returns the single-valued wrapping function for texture coordinate
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s, a symbolic constant. The initial value is <CODE class="constant">
GL_REPEAT</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_TEXTURE_WRAP_T</CODE></DT>
<DD>
<P> Returns the single-valued wrapping function for texture coordinate
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 t, a symbolic constant. The initial value is <CODE class="constant">
GL_REPEAT</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3201">Notes</A></H2>
<P> If an error is generated, no change is made to the contents of<EM class="parameter">
 <CODE>params</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3202">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> or<EM class="parameter"> <CODE>pname</CODE></EM>
 is not an accepted value.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3203">See Also</A></H2>
<P> <A class="citerefentry" href="#glTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetUniform"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3205">Name</A></H2>
<P>glGetUniform -- return the value of a uniform variable</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3206">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetUniformfv</B>(</CODE>
</TD><TD>GLuint<VAR class="pdparam"> program</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat *<VAR class="pdparam">params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetUniformiv</B>(</CODE>
</TD><TD>GLuint<VAR class="pdparam"> program</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam">params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3207">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the program object to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>location</CODE></EM></DT>
<DD>
<P>Specifies the location of the uniform variable to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>params</CODE></EM></DT>
<DD>
<P>Returns the value of the specified uniform variable.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3208">Description</A></H2>
<P><CODE class="function">glGetUniform</CODE> returns in<EM class="parameter">
 <CODE>params</CODE></EM> the value(s) of the specified uniform
 variable. The type of the uniform variable specified by<EM class="parameter">
 <CODE>location</CODE></EM> determines the number of values returned. If
 the uniform variable is defined in the shader as a boolean, int, or
 float, a single value will be returned. If it is defined as a vec2,
 ivec2, or bvec2, two values will be returned. If it is defined as a
 vec3, ivec3, or bvec3, three values will be returned, and so on. To
 query values stored in uniform variables declared as arrays, call <CODE class="function">
glGetUniform</CODE> for each element of the array. To query values
 stored in uniform variables declared as structures, call <CODE class="function">
glGetUniform</CODE> for each field in the structure. The values for
 uniform variables declared as a matrix will be returned in column major
 order.</P>
<P>The locations assigned to uniform variables are not known until the
 program object is linked. After linking has occurred, the command <A class="citerefentry"
href="#glGetUniformLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniformLocation</A> can be used to obtain the location of a uniform
 variable. This location value can then be passed to <CODE class="function">
glGetUniform</CODE> in order to query the current value of the uniform
 variable. After a program object has been linked successfully, the
 index values for uniform variables remain fixed until the next link
 command occurs. The uniform variable values can only be queried after a
 link if the link was successful.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3209">Notes</A></H2>
<P>If an error is generated, no change is made to the contents of<EM class="parameter">
 <CODE>params</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3210">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> has not been successfully linked.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>location</CODE></EM> does not correspond to a valid uniform
 variable location for the specified program object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3211">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetActiveUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveUniform</A> with arguments<EM class="parameter"> <CODE>
program</CODE></EM> and the index of an active uniform variable</P>
<P><A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with arguments<EM class="parameter"> <CODE>program</CODE>
</EM> and <CODE class="constant">GL_ACTIVE_UNIFORMS</CODE> or <CODE class="constant">
GL_ACTIVE_UNIFORM_MAX_LENGTH</CODE></P>
<P><A class="citerefentry" href="#glGetUniformLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniformLocation</A> with arguments<EM class="parameter"> <CODE>
program</CODE></EM> and the name of a uniform variable</P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3212">See Also</A></H2>
<P><A class="citerefentry" href="#glCreateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateProgram</A>, <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUniform</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetUniformLocation">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3214">Name</A></H2>
<P>glGetUniformLocation -- return the location of a uniform variable</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3215">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLint<B class="fsfunc">
 glGetUniformLocation</B>(</CODE></TD><TD>GLuint<VAR class="pdparam">
 program</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLchar *<VAR class="pdparam">name</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3216">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the program object to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>name</CODE></EM></DT>
<DD>
<P>Points to a null terminated string containing the name of the uniform
 variable whose location is to be queried.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3217">Description</A></H2>
<P><CODE class="function">glGetUniformLocation</CODE> returns an integer
 that represents the location of a specific uniform variable within a
 program object.<EM class="parameter"> <CODE>name</CODE></EM> must be a
 null terminated string that contains no white space.<EM class="parameter">
 <CODE>name</CODE></EM> must be an active uniform variable name in<EM class="parameter">
 <CODE>program</CODE></EM> that is not a structure, an array of
 structures, or a subcomponent of a vector or a matrix. This function
 returns -1 if<EM class="parameter"> <CODE>name</CODE></EM> does not
 correspond to an active uniform variable in<EM class="parameter"> <CODE>
program</CODE></EM> or if<EM class="parameter"> <CODE>name</CODE></EM>
 starts with the reserved prefix &quot;gl_&quot;.</P>
<P>Uniform variables that are structures or arrays of structures may be
 queried by calling <CODE class="function">glGetUniformLocation</CODE>
 for each field within the structure. The array element operator &quot;[]&quot;
 and the structure field operator &quot;.&quot; may be used in<EM class="parameter">
 <CODE>name</CODE></EM> in order to select elements within an array or
 fields within a structure. The result of using these operators is not
 allowed to be another structure, an array of structures, or a
 subcomponent of a vector or a matrix. Except if the last part of<EM class="parameter">
 <CODE>name</CODE></EM> indicates a uniform variable array, the location
 of the first element of an array can be retrieved by using the name of
 the array, or by using the name appended by &quot;[0]&quot;.</P>
<P>The actual locations assigned to uniform variables are not known
 until the program object is linked successfully. After linking has
 occurred, the command <CODE class="function">glGetUniformLocation</CODE>
 can be used to obtain the location of a uniform variable. This location
 value can then be passed to <A class="citerefentry" href="#glUniform">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUniform</A> to set the value of the uniform variable or to <A class="citerefentry"
href="#glGetUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniform</A> in order to query the current value of the uniform
 variable. After a program object has been linked successfully, the
 index values for uniform variables remain fixed until the next link
 command occurs. Uniform variable locations and values can only be
 queried after a link if the link was successful.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3218">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> has not been successfully linked.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3219">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetActiveUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveUniform</A> with arguments<EM class="parameter"> <CODE>
program</CODE></EM> and the index of an active uniform variable</P>
<P><A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with arguments<EM class="parameter"> <CODE>program</CODE>
</EM> and <CODE class="constant">GL_ACTIVE_UNIFORMS</CODE> or <CODE class="constant">
GL_ACTIVE_UNIFORM_MAX_LENGTH</CODE></P>
<P><A class="citerefentry" href="#glGetUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniform</A> with arguments<EM class="parameter"> <CODE>program</CODE>
</EM> and the name of a uniform variable</P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3220">See Also</A></H2>
<P><A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUniform</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetVertexAttrib"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3222">Name</A></H2>
<P>glGetVertexAttrib -- return a generic vertex attribute parameter</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3223">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetVertexAttribfv</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat *<VAR class="pdparam">params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glGetVertexAttribiv</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint *<VAR class="pdparam">params</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3224">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>index</CODE></EM></DT>
<DD>
<P>Specifies the generic vertex attribute parameter to be queried.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pname</CODE></EM></DT>
<DD>
<P>Specifies the symbolic name of the vertex attribute parameter to be
 queried. Accepted values are <CODE class="constant">
GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</CODE>, <CODE class="constant">
GL_VERTEX_ATTRIB_ARRAY_ENABLED</CODE>, <CODE class="constant">
GL_VERTEX_ATTRIB_ARRAY_SIZE</CODE>, <CODE class="constant">
GL_VERTEX_ATTRIB_ARRAY_STRIDE</CODE>, <CODE class="constant">
GL_VERTEX_ATTRIB_ARRAY_TYPE</CODE>, <CODE class="constant">
GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</CODE>, or <CODE class="constant">
GL_CURRENT_VERTEX_ATTRIB</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>params</CODE></EM></DT>
<DD>
<P>Returns the requested data.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3225">Description</A></H2>
<P><CODE class="function">glGetVertexAttrib</CODE> returns in<EM class="parameter">
 <CODE>params</CODE></EM> the value of a generic vertex attribute
 parameter. The generic vertex attribute to be queried is specified by<EM
class="parameter"> <CODE>index</CODE></EM>, and the parameter to be
 queried is specified by<EM class="parameter"> <CODE>pname</CODE></EM>.</P>
<P>The accepted parameter names are as follows:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value, the name of the buffer object currently bound to the binding
 point corresponding to generic vertex attribute array<EM class="parameter">
 <CODE>index</CODE></EM>. If no buffer object is bound, 0 is returned.
 The initial value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_ENABLED</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value that is non-zero (true) if the vertex attribute array for<EM class="parameter">
 <CODE>index</CODE></EM> is enabled and 0 (false) if it is disabled. The
 initial value is <CODE class="constant">GL_FALSE</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_SIZE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value, the size of the vertex attribute array for<EM class="parameter">
 <CODE>index</CODE></EM>. The size is the number of values for each
 element of the vertex attribute array, and it will be 1, 2, 3, or 4.
 The initial value is 4.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_STRIDE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value, the array stride for (number of bytes between successive
 elements in) the vertex attribute array for<EM class="parameter"> <CODE>
index</CODE></EM>. A value of 0 indicates that the array elements are
 stored sequentially in memory. The initial value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_TYPE</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value, a symbolic constant indicating the array type for the vertex
 attribute array for<EM class="parameter"> <CODE>index</CODE></EM>.
 Possible values are <CODE class="constant">GL_BYTE</CODE>, <CODE class="constant">
GL_UNSIGNED_BYTE</CODE>, <CODE class="constant">GL_SHORT</CODE>, <CODE class="constant">
GL_UNSIGNED_SHORT</CODE>, <CODE class="constant">GL_FIXED</CODE>, and <CODE
class="constant">GL_FLOAT</CODE>. The initial value is <CODE class="constant">
GL_FLOAT</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns a single
 value that is non-zero (true) if fixed-point data types for the vertex
 attribute array indicated by<EM class="parameter"> <CODE>index</CODE></EM>
 are normalized when they are converted to floating point, and 0 (false)
 otherwise. The initial value is <CODE class="constant">GL_FALSE</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_CURRENT_VERTEX_ATTRIB</CODE></DT>
<DD>
<P><EM class="parameter"> <CODE>params</CODE></EM> returns four values
 that represent the current value for the generic vertex attribute
 specified by index. The initial value is (0,0,0,1).</P>
</DD>
</DL>
</DIV>
<P>All of the parameters except <CODE class="constant">
GL_CURRENT_VERTEX_ATTRIB</CODE> represent client-side state.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3226">Notes</A></H2>
<P>If an error is generated, no change is made to the contents of<EM class="parameter">
 <CODE>params</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3227">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>pname</CODE></EM> is not an accepted value.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>index</CODE></EM> is greater than or equal to <CODE class="constant">
GL_MAX_VERTEX_ATTRIBS</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3228">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_VERTEX_ATTRIBS</CODE>
</P>
<P><A class="citerefentry" href="#glGetVertexAttribPointerv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttribPointerv</A> with arguments<EM class="parameter"> <CODE>
index</CODE></EM> and <CODE class="constant">
GL_VERTEX_ATTRIB_ARRAY_POINTER</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3229">See Also</A></H2>
<P><A class="citerefentry" href="#glBindAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindAttribLocation</A>, <A class="citerefentry" href="#glBindBuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>, <A class="citerefentry" href="#glEnableVertexAttribArray">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisableVertexAttribArray</A>, <A class="citerefentry" href="#glEnableVertexAttribArray">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnableVertexAttribArray</A>, <A class="citerefentry" href="#glVertexAttrib">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttrib</A>, <A class="citerefentry" href="#glVertexAttribPointer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttribPointer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glGetVertexAttribPointerv">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3231">Name</A></H2>
<P>glGetVertexAttribPointerv -- return the address of the specified
 generic vertex attribute pointer</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3232">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glGetVertexAttribPointerv</B>(</CODE></TD><TD>GLuint<VAR class="pdparam">
 index</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLvoid **<VAR class="pdparam">pointer</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3233">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>index</CODE></EM></DT>
<DD>
<P>Specifies the generic vertex attribute parameter to be returned.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pname</CODE></EM></DT>
<DD>
<P>Specifies the symbolic name of the generic vertex attribute parameter
 to be returned. Must be <CODE class="constant">
GL_VERTEX_ATTRIB_ARRAY_POINTER</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pointer</CODE></EM></DT>
<DD>
<P>Returns the pointer value.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3234">Description</A></H2>
<P><CODE class="function">glGetVertexAttribPointerv</CODE> returns
 pointer information.<EM class="parameter"> <CODE>index</CODE></EM> is
 the generic vertex attribute to be queried,<EM class="parameter"> <CODE>
pname</CODE></EM> is a symbolic constant indicating the pointer to be
 returned, and<EM class="parameter"> <CODE>params</CODE></EM> is a
 pointer to a location in which to place the returned data.</P>
<P>If a non-zero named buffer object was bound to the <CODE class="constant">
GL_ARRAY_BUFFER</CODE> target (see <A class="citerefentry" href="#glBindBuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>) when the desired pointer was previously specified, the<EM
class="parameter"> <CODE>pointer</CODE></EM> returned is a byte offset
 into the buffer object's data store.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3235">Notes</A></H2>
<P>The pointer returned is client-side state.</P>
<P>The initial value for each pointer is 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3236">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>pname</CODE></EM> is not an accepted value.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>index</CODE></EM> is greater than or equal to <CODE class="constant">
GL_MAX_VERTEX_ATTRIBS</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3237">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_VERTEX_ATTRIBS</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3238">See Also</A></H2>
<P><A class="citerefentry" href="#glGetVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttrib</A>, <A class="citerefentry" href="#glVertexAttribPointer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttribPointer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glHint"></A><DIV class="titlepage">
</DIV><DIV class="refnamediv">
<H2><A NAME="0_3240">Name</A></H2>
<P>glHint -- specify implementation-specific hints</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3241">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glHint</B>(</CODE></TD><TD>
GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> mode</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3242">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies a symbolic constant indicating the behavior to be
 controlled. <CODE class="constant">GL_GENERATE_MIPMAP_HINT</CODE> is
 accepted.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>mode</CODE></EM></DT>
<DD>
<P> Specifies a symbolic constant indicating the desired behavior. <CODE class="constant">
GL_FASTEST</CODE>, <CODE class="constant">GL_NICEST</CODE>, and <CODE class="constant">
GL_DONT_CARE</CODE> are accepted.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3243">Description</A></H2>
<P> Certain aspects of GL behavior, when there is room for
 interpretation, can be controlled with hints. A hint is specified with
 two arguments.<EM class="parameter"> <CODE>target</CODE></EM> is a
 symbolic constant indicating the behavior to be controlled, and<EM class="parameter">
 <CODE>mode</CODE></EM> is another symbolic constant indicating the
 desired behavior. The initial value for each<EM class="parameter"> <CODE>
target</CODE></EM> is <CODE class="constant">GL_DONT_CARE</CODE>.<EM class="parameter">
 <CODE>mode</CODE></EM> can be one of the following:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_FASTEST</CODE></DT>
<DD>
<P> The most efficient option should be chosen.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NICEST</CODE></DT>
<DD>
<P> The most correct, or highest quality, option should be chosen.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DONT_CARE</CODE></DT>
<DD>
<P> No preference.</P>
</DD>
</DL>
</DIV>
<P> Though the implementation aspects that can be hinted are well
 defined, the interpretation of the hints depends on the implementation.
 The hint aspects that can be specified with<EM class="parameter"> <CODE>
target</CODE></EM>, along with suggested semantics, are as follows:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_GENERATE_MIPMAP_HINT</CODE></DT>
<DD>
<P> Indicates the quality of filtering when generating mipmap images
 with <A class="citerefentry" href="#glGenerateMipmap">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenerateMipmap</A>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3244">Notes</A></H2>
<P> The interpretation of hints depends on the implementation. Some
 implementations ignore <CODE class="function">glHint</CODE> settings.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3245">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if either<EM
class="parameter"> <CODE>target</CODE></EM> or<EM class="parameter"> <CODE>
mode</CODE></EM> is not an accepted value.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3246">See Also</A></H2>
<P><A class="citerefentry" href="#glGenerateMipmap">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenerateMipmap</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glIsBuffer"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3248">Name</A></H2>
<P>glIsBuffer -- determine if a name corresponds to a buffer object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3249">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLboolean<B class="fsfunc"> glIsBuffer</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> buffer</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3250">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>buffer</CODE></EM></DT>
<DD>
<P> Specifies a value that may be the name of a buffer object.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3251">Description</A></H2>
<P> <CODE class="function">glIsBuffer</CODE> returns <CODE class="constant">
GL_TRUE</CODE> if<EM class="parameter"> <CODE>buffer</CODE></EM> is
 currently the name of a buffer object. If<EM class="parameter"> <CODE>
buffer</CODE></EM> is zero, or is a non-zero value that is not currently
 the name of a buffer object, or if an error occurs, <CODE class="function">
glIsBuffer</CODE> returns <CODE class="constant">GL_FALSE</CODE>.</P>
<P> A name returned by <A class="citerefentry" href="#glGenBuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenBuffers</A>, but not yet associated with a buffer object by calling
 <A class="citerefentry" href="#glBindBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>, is not the name of a buffer object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3252">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindBuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>, <A class="citerefentry" href="#glDeleteBuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteBuffers</A>, <A class="citerefentry" href="#glGenBuffers">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenBuffers</A>, <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glIsEnabled"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3254">Name</A></H2>
<P>glIsEnabled -- test whether a capability is enabled</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3255">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLboolean<B class="fsfunc"> glIsEnabled</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> cap</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3256">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>cap</CODE></EM></DT>
<DD>
<P> Specifies a symbolic constant indicating a GL capability.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3257">Description</A></H2>
<P> <CODE class="function">glIsEnabled</CODE> returns <CODE class="constant">
GL_TRUE</CODE> if<EM class="parameter"> <CODE>cap</CODE></EM> is an
 enabled capability and returns <CODE class="constant">GL_FALSE</CODE>
 otherwise. Initially all capabilities except <CODE class="constant">
GL_DITHER</CODE> are disabled; <CODE class="constant">GL_DITHER</CODE>
 is initially enabled.</P>
<P> The following capabilities are accepted for<EM class="parameter"> <CODE>
cap</CODE></EM>:</P>
<P></P>
<DIV class="informaltable">
<TABLE border="1"><COLGROUP><COL align="left"></COL><COL align="left"></COL>
</COLGROUP><THEAD></THEAD>
<TR><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG> Constant</STRONG></TH><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG> See</STRONG></TH></TR>
<TBODY></TBODY>
<TR><TD align="left"> <CODE class="constant">GL_BLEND</CODE></TD><TD align="left">
 <A class="citerefentry" href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A></TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_CULL_FACE</CODE></TD><TD align="left">
 <A class="citerefentry" href="#glCullFace">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCullFace</A></TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_DEPTH_TEST</CODE></TD><TD
align="left"> <A class="citerefentry" href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A>, <A class="citerefentry" href="#glDepthRangef">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthRangef</A></TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_DITHER</CODE></TD><TD align="left">
 <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A></TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_POLYGON_OFFSET_FILL</CODE>
</TD><TD align="left"> <A class="citerefentry" href="#glPolygonOffset">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPolygonOffset</A></TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_SAMPLE_ALPHA_TO_COVERAGE</CODE>
</TD><TD align="left"> <A class="citerefentry" href="#glSampleCoverage">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glSampleCoverage</A></TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_SAMPLE_COVERAGE</CODE></TD><TD
align="left"> <A class="citerefentry" href="#glSampleCoverage">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glSampleCoverage</A></TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_SCISSOR_TEST</CODE></TD><TD
align="left"> <A class="citerefentry" href="#glScissor">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glScissor</A></TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_STENCIL_TEST</CODE></TD><TD
align="left"> <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A>, <A class="citerefentry" href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A></TD></TR>
</TABLE>
</DIV>
<P></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3258">Notes</A></H2>
<P> If an error is generated, <CODE class="function">glIsEnabled</CODE>
 returns 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3259">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>cap</CODE></EM> is not an accepted value.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3260">See Also</A></H2>
<P> <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A>, <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glIsFramebuffer"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3262">Name</A></H2>
<P>glIsFramebuffer -- determine if a name corresponds to a framebuffer
 object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3263">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLboolean<B class="fsfunc">
 glIsFramebuffer</B>(</CODE></TD><TD>GLuint<VAR class="pdparam">
 framebuffer</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3264">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>framebuffer</CODE></EM></DT>
<DD>
<P> Specifies a value that may be the name of a framebuffer object.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3265">Description</A></H2>
<P> <CODE class="function">glIsFramebuffer</CODE> returns <CODE class="constant">
GL_TRUE</CODE> if<EM class="parameter"> <CODE>framebuffer</CODE></EM> is
 currently the name of a framebuffer object. If<EM class="parameter"> <CODE>
framebuffer</CODE></EM> is zero, or is a non-zero value that is not
 currently the name of a framebuffer object, or if an error occurs, <CODE
class="function">glIsFramebuffer</CODE> returns <CODE class="constant">
GL_FALSE</CODE>.</P>
<P> A name returned by <A class="citerefentry" href="#glGenFramebuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenFramebuffers</A>, but not yet associated with a framebuffer object
 by calling <A class="citerefentry" href="#glBindFramebuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindFramebuffer</A>, is not the name of a framebuffer object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3266">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindFramebuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindFramebuffer</A>, <A class="citerefentry" href="#glDeleteFramebuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteFramebuffers</A>, <A class="citerefentry" href="#glGenFramebuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenFramebuffers</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glIsProgram"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3268">Name</A></H2>
<P>glIsProgram -- determine if a name corresponds to a program object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3269">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLboolean<B class="fsfunc"> glIsProgram</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> program</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3270">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies a potential program object.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3271">Description</A></H2>
<P><CODE class="function">glIsProgram</CODE> returns <CODE class="constant">
GL_TRUE</CODE> if<EM class="parameter"> <CODE>program</CODE></EM> is the
 name of a program object previously created with <A class="citerefentry"
href="#glCreateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateProgram</A> and not yet deleted with <A class="citerefentry" href="#glDeleteProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteProgram</A>. If<EM class="parameter"> <CODE>program</CODE></EM>
 is zero or a non-zero value that is not the name of a program object,
 or if an error occurs, <CODE class="function">glIsProgram</CODE>
 returns <CODE class="constant">GL_FALSE</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3272">Notes</A></H2>
<P>No error is generated if<EM class="parameter"> <CODE>program</CODE></EM>
 is not a valid program object name.</P>
<P>A program object marked for deletion with <A class="citerefentry" href="#glDeleteProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteProgram</A> but still in use as part of current rendering state
 is still considered a program object and <CODE class="function">
glIsProgram</CODE> will return <CODE class="constant">GL_TRUE</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3273">See Also</A></H2>
<P><A class="citerefentry" href="#glCreateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateProgram</A>, <A class="citerefentry" href="#glDeleteProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteProgram</A>, <A class="citerefentry" href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glIsRenderbuffer"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3275">Name</A></H2>
<P>glIsRenderbuffer -- determine if a name corresponds to a
 renderbuffer object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3276">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLboolean<B class="fsfunc">
 glIsRenderbuffer</B>(</CODE></TD><TD>GLuint<VAR class="pdparam">
 renderbuffer</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3277">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>renderbuffer</CODE></EM></DT>
<DD>
<P> Specifies a value that may be the name of a renderbuffer object.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3278">Description</A></H2>
<P> <CODE class="function">glIsRenderbuffer</CODE> returns <CODE class="constant">
GL_TRUE</CODE> if<EM class="parameter"> <CODE>renderbuffer</CODE></EM>
 is currently the name of a renderbuffer object. If<EM class="parameter">
 <CODE>renderbuffer</CODE></EM> is zero, or is a non-zero value that is
 not currently the name of a renderbuffer object, or if an error occurs,
 <CODE class="function">glIsRenderbuffer</CODE> returns <CODE class="constant">
GL_FALSE</CODE>.</P>
<P> A name returned by <A class="citerefentry" href="#glGenRenderbuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenRenderbuffers</A>, but not yet associated with a renderbuffer
 object by calling <A class="citerefentry" href="#glBindRenderbuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindRenderbuffer</A>, is not the name of a renderbuffer object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3279">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindRenderbuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindRenderbuffer</A>, <A class="citerefentry" href="#glDeleteRenderbuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteRenderbuffers</A>, <A class="citerefentry" href="#glGenRenderbuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenRenderbuffers</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glIsShader"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3281">Name</A></H2>
<P>glIsShader -- determine if a name corresponds to a shader object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3282">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLboolean<B class="fsfunc"> glIsShader</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> shader</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3283">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shader</CODE></EM></DT>
<DD>
<P>Specifies a potential shader object.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3284">Description</A></H2>
<P><CODE class="function">glIsShader</CODE> returns <CODE class="constant">
GL_TRUE</CODE> if<EM class="parameter"> <CODE>shader</CODE></EM> is the
 name of a shader object previously created with <A class="citerefentry" href="#glCreateShader">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateShader</A> and not yet deleted with <A class="citerefentry" href="#glDeleteShader">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteShader</A>. If<EM class="parameter"> <CODE>shader</CODE></EM> is
 zero or a non-zero value that is not the name of a shader object, or if
 an error occurs, <CODE class="function">glIsShader</CODE> returns <CODE class="constant">
GL_FALSE</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3285">Notes</A></H2>
<P>No error is generated if<EM class="parameter"> <CODE>shader</CODE></EM>
 is not a valid shader object name.</P>
<P>A shader object marked for deletion with <A class="citerefentry" href="#glDeleteShader">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteShader</A> but still attached to a program object is still
 considered a shader object and <CODE class="function">glIsShader</CODE>
 will return <CODE class="constant">GL_TRUE</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3286">See Also</A></H2>
<P><A class="citerefentry" href="#glCreateShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateShader</A>, <A class="citerefentry" href="#glDeleteShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteShader</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glIsTexture"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3288">Name</A></H2>
<P>glIsTexture -- determine if a name corresponds to a texture</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3289">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">GLboolean<B class="fsfunc"> glIsTexture</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> texture</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3290">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>texture</CODE></EM></DT>
<DD>
<P> Specifies a value that may be the name of a texture.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3291">Description</A></H2>
<P> <CODE class="function">glIsTexture</CODE> returns <CODE class="constant">
GL_TRUE</CODE> if<EM class="parameter"> <CODE>texture</CODE></EM> is
 currently the name of a texture. If<EM class="parameter"> <CODE>texture</CODE>
</EM> is zero, or is a non-zero value that is not currently the name of
 a texture, or if an error occurs, <CODE class="function">glIsTexture</CODE>
 returns <CODE class="constant">GL_FALSE</CODE>.</P>
<P> A name returned by <A class="citerefentry" href="#glGenTextures">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenTextures</A>, but not yet associated with a texture by calling <A class="citerefentry"
href="#glBindTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindTexture</A>, is not the name of a texture.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3292">See Also</A></H2>
<P> <A class="citerefentry" href="#glBindTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindTexture</A>, <A class="citerefentry" href="#glCopyTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A>, <A class="citerefentry" href="#glDeleteTextures">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteTextures</A>, <A class="citerefentry" href="#glGenTextures">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenTextures</A>, <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A>, <A class="citerefentry" href="#glGetTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetTexParameter</A>, <A class="citerefentry" href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glLineWidth"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3294">Name</A></H2>
<P>glLineWidth -- specify the width of rasterized lines</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3295">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glLineWidth</B>(</CODE>
</TD><TD>GLfloat<VAR class="pdparam"> width</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3296">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>width</CODE></EM></DT>
<DD>
<P> Specifies the width of rasterized lines. The initial value is 1.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3297">Description</A></H2>
<P> <CODE class="function">glLineWidth</CODE> specifies the rasterized
 width of lines.</P>
<P> The actual width is determined by rounding the supplied width to the
 nearest integer. (If the rounding results in the value 0, it is as if
 the line width were 1.) If
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;&quot; close=&quot;&quot;-->

<!--mml:mrow-->

<!--mml:mo-->
 &Icirc;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 x
<!--mml:mo-->
 &gt;=
<!--mml:mfenced open=&quot;&quot; close=&quot;&quot;-->

<!--mml:mrow-->

<!--mml:mo-->
 &Icirc;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 y ,
<!--span class=&quot;emphasis&quot;-->
<EM> i</EM> pixels are filled in each column that is rasterized, where
<!--span class=&quot;emphasis&quot;-->
<EM> i</EM> is the rounded value of<EM class="parameter"> <CODE>width</CODE>
</EM>. Otherwise,
<!--span class=&quot;emphasis&quot;-->
<EM> i</EM> pixels are filled in each row that is rasterized.</P>
<P> There is a range of supported line widths. Only width 1 is
 guaranteed to be supported; others depend on the implementation. To
 query the range of supported widths, call <A class="citerefentry" href="#glGet">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">
GL_ALIASED_LINE_WIDTH_RANGE</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3298">Notes</A></H2>
<P> The line width specified by <CODE class="function">glLineWidth</CODE>
 is always returned when <CODE class="constant">GL_LINE_WIDTH</CODE> is
 queried. Clamping and rounding have no effect on the specified value.</P>
<P> Line width may be clamped to an implementation-dependent maximum.
 Call <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with <CODE class="constant">GL_ALIASED_LINE_WIDTH_RANGE</CODE>
 to determine the maximum width.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3299">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>width</CODE></EM> is less than or equal to 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3300">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_LINE_WIDTH</CODE></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">
GL_ALIASED_LINE_WIDTH_RANGE</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3301">See Also</A></H2>
<P> <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glLinkProgram"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3303">Name</A></H2>
<P>glLinkProgram -- link a program object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3304">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glLinkProgram</B>(</CODE>
</TD><TD>GLuint<VAR class="pdparam"> program</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3305">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the handle of the program object to be linked.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3306">Description</A></H2>
<P><CODE class="function">glLinkProgram</CODE> links the program object
 specified by<EM class="parameter"> <CODE>program</CODE></EM>. Shader
 objects of type <CODE class="constant">GL_VERTEX_SHADER</CODE> attached
 to<EM class="parameter"> <CODE>program</CODE></EM> are used to create
 an executable that will run on the programmable vertex processor.
 Shader objects of type <CODE class="constant">GL_FRAGMENT_SHADER</CODE>
 attached to<EM class="parameter"> <CODE>program</CODE></EM> are used to
 create an executable that will run on the programmable fragment
 processor.</P>
<P>The status of the link operation will be stored as part of the
 program object's state. This value will be set to <CODE class="constant">
GL_TRUE</CODE> if the program object was linked without errors and is
 ready for use, and <CODE class="constant">GL_FALSE</CODE> otherwise. It
 can be queried by calling <A class="citerefentry" href="#glGetProgramiv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with arguments<EM class="parameter"> <CODE>program</CODE>
</EM> and <CODE class="constant">GL_LINK_STATUS</CODE>.</P>
<P>As a result of a successful link operation, all active user-defined
 uniform variables belonging to<EM class="parameter"> <CODE>program</CODE>
</EM> will be initialized to 0, and each of the program object's active
 uniform variables will be assigned a location that can be queried by
 calling <A class="citerefentry" href="#glGetUniformLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniformLocation</A>. Also, any active user-defined attribute
 variables that have not been bound to a generic vertex attribute index
 will be bound to one at this time.</P>
<P>Linking of a program object can fail for a number of reasons as
 specified in the
<!--span class=&quot;emphasis&quot;-->
<EM> OpenGL ES Shading Language Specification</EM>. The following lists
 some of the conditions that will cause a link error.</P>
<DIV class="itemizedlist">
<UL type="disc">
<LI>
<P>A vertex shader and a fragment shader are not both present in the
 program object.</P>
</LI>
<LI>
<P>The number of active attribute variables supported by the
 implementation has been exceeded.</P>
</LI>
<LI>
<P>The storage limit for uniform variables has been exceeded.</P>
</LI>
<LI>
<P>The number of active uniform variables supported by the
 implementation has been exceeded.</P>
</LI>
<LI>
<P>The <CODE class="function">main</CODE> function is missing for the
 vertex shader or the fragment shader.</P>
</LI>
<LI>
<P>A varying variable actually used in the fragment shader is not
 declared in the same way (or is not declared at all) in the vertex
 shader.</P>
</LI>
<LI>
<P>A reference to a function or variable name is unresolved.</P>
</LI>
<LI>
<P>A shared global is declared with two different types or two different
 initial values.</P>
</LI>
<LI>
<P>One or more of the attached shader objects has not been successfully
 compiled (via <A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>) or loaded with a pre-compiled shader binary (via <A class="citerefentry"
href="#glShaderBinary">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderBinary</A>).</P>
</LI>
<LI>
<P>Binding a generic attribute matrix caused some rows of the matrix to
 fall outside the allowed maximum of <CODE class="constant">
GL_MAX_VERTEX_ATTRIBS</CODE>.</P>
</LI>
<LI>
<P>Not enough contiguous vertex attribute slots could be found to bind
 attribute matrices.</P>
</LI>
</UL>
</DIV>
<P>When a program object has been successfully linked, the program
 object can be made part of current state by calling <A class="citerefentry"
href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A>. Whether or not the link operation was successful, the
 program object's information log will be overwritten. The information
 log can be retrieved by calling <A class="citerefentry" href="#glGetProgramInfoLog">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramInfoLog</A>.</P>
<P><CODE class="function">glLinkProgram</CODE> will also install the
 generated executables as part of the current rendering state if the
 link operation was successful and the specified program object is
 already currently in use as a result of a previous call to <A class="citerefentry"
href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A>. If the program object currently in use is relinked
 unsuccessfully, its link status will be set to <CODE class="constant">
GL_FALSE</CODE> , but the executables and associated state will remain
 part of the current state until a subsequent call to <CODE class="function">
glUseProgram</CODE> removes it from use. After it is removed from use,
 it cannot be made part of current state until it has been successfully
 relinked.</P>
<P>The program object's information log is updated and the program is
 generated at the time of the link operation. After the link operation,
 applications are free to modify attached shader objects, compile
 attached shader objects, detach shader objects, delete shader objects,
 and attach additional shader objects. None of these operations affects
 the information log or the program that is part of the program object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3307">Notes</A></H2>
<P>If the link operation is unsuccessful, any information about a
 previous link operation on<EM class="parameter"> <CODE>program</CODE></EM>
 is lost (i.e., a failed link does not restore the old state of<EM class="parameter">
 <CODE>program</CODE></EM>). Certain information can still be retrieved
 from<EM class="parameter"> <CODE>program</CODE></EM> even after an
 unsuccessful link operation. See for instance <A class="citerefentry" href="#glGetActiveAttrib">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveAttrib</A> and <A class="citerefentry" href="#glGetActiveUniform">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveUniform</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3308">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3309">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with the argument <CODE class="constant">GL_CURRENT_PROGRAM</CODE>
</P>
<P><A class="citerefentry" href="#glGetActiveAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveAttrib</A> with argument<EM class="parameter"> <CODE>program</CODE>
</EM> and the index of an active attribute variable</P>
<P><A class="citerefentry" href="#glGetActiveUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveUniform</A> with argument<EM class="parameter"> <CODE>program</CODE>
</EM> and the index of an active uniform variable<EM class="parameter"><CODE>
</CODE></EM></P>
<P><A class="citerefentry" href="#glGetAttachedShaders">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttachedShaders</A> with argument<EM class="parameter"> <CODE>
program</CODE></EM></P>
<P><A class="citerefentry" href="#glGetAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttribLocation</A> with argument<EM class="parameter"> <CODE>
program</CODE></EM> and an attribute variable name</P>
<P><A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with arguments<EM class="parameter"> <CODE>program</CODE>
</EM> and <CODE class="constant">GL_LINK_STATUS</CODE></P>
<P><A class="citerefentry" href="#glGetProgramInfoLog">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramInfoLog</A> with argument<EM class="parameter"> <CODE>
program</CODE></EM></P>
<P><A class="citerefentry" href="#glGetUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniform</A> with argument<EM class="parameter"> <CODE>program</CODE>
</EM> and a uniform variable location</P>
<P><A class="citerefentry" href="#glGetUniformLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniformLocation</A> with argument<EM class="parameter"> <CODE>
program</CODE></EM> and a uniform variable name</P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3310">See Also</A></H2>
<P><A class="citerefentry" href="#glAttachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glAttachShader</A>, <A class="citerefentry" href="#glBindAttribLocation">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindAttribLocation</A>, <A class="citerefentry" href="#glCompileShader">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glShaderBinary">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderBinary</A>, <A class="citerefentry" href="#glCreateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateProgram</A>, <A class="citerefentry" href="#glDeleteProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteProgram</A>, <A class="citerefentry" href="#glDetachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDetachShader</A>, <A class="citerefentry" href="#glUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUniform</A>, <A class="citerefentry" href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A>, <A class="citerefentry" href="#glValidateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glValidateProgram</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glPixelStorei"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3312">Name</A></H2>
<P>glPixelStorei -- set pixel storage modes</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3313">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glPixelStorei</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> param</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3314">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pname</CODE></EM></DT>
<DD>
<P> Specifies the symbolic name of the parameter to be set. One value
 affects the packing of pixel data into memory: <CODE class="constant">
GL_PACK_ALIGNMENT</CODE>. The other affects the unpacking of pixel data
<!--span class=&quot;emphasis&quot;-->
<EM> from</EM> memory: <CODE class="constant">GL_UNPACK_ALIGNMENT</CODE>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>param</CODE></EM></DT>
<DD>
<P> Specifies the value that<EM class="parameter"> <CODE>pname</CODE></EM>
 is set to.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3315">Description</A></H2>
<P> <CODE class="function">glPixelStorei</CODE> sets pixel storage modes
 that affect the operation of subsequent <A class="citerefentry" href="#glReadPixels">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReadPixels</A> as well as the unpacking of texture patterns (see <A class="citerefentry"
href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A> and <A class="citerefentry" href="#glTexSubImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexSubImage2D</A>).</P>
<P><EM class="parameter"> <CODE>pname</CODE></EM> is a symbolic constant
 indicating the parameter to be set, and<EM class="parameter"> <CODE>
param</CODE></EM> is the new value. One storage parameter affects how
 pixel data is returned to client memory:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_PACK_ALIGNMENT</CODE></DT>
<DD>
<P> Specifies the alignment requirements for the start of each pixel row
 in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned
 to even-numbered bytes), 4 (word-alignment), and 8 (rows start on
 double-word boundaries).</P>
</DD>
</DL>
</DIV>
<P> The other storage parameter affects how pixel data is read from
 client memory:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_UNPACK_ALIGNMENT</CODE></DT>
<DD>
<P> Specifies the alignment requirements for the start of each pixel row
 in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned
 to even-numbered bytes), 4 (word-alignment), and 8 (rows start on
 double-word boundaries).</P>
</DD>
</DL>
</DIV>
<P> The following table gives the type, initial value, and range of
 valid values for each storage parameter that can be set with <CODE class="function">
glPixelStorei</CODE>.</P>
<P></P>
<DIV class="informaltable">
<TABLE border="1"><COLGROUP><COL align="left"></COL><COL align="center"></COL><COL
align="center"></COL><COL align="center"></COL></COLGROUP><THEAD></THEAD>
<TR><TH align="left">
<!--span class=&quot;bold&quot;-->
<STRONG><EM class="parameter"> <CODE>pname</CODE></EM></STRONG></TH><TH align="center">

<!--span class=&quot;bold&quot;-->
<STRONG> Type</STRONG></TH><TH align="center">
<!--span class=&quot;bold&quot;-->
<STRONG> Initial Value</STRONG></TH><TH align="center">
<!--span class=&quot;bold&quot;-->
<STRONG> Valid Range</STRONG></TH></TR>
<TBODY></TBODY>
<TR><TD align="left"> <CODE class="constant">GL_PACK_ALIGNMENT</CODE></TD><TD
align="center"> integer</TD><TD align="center"> 4</TD><TD align="center">
 1, 2, 4, or 8</TD></TR>
<TR><TD align="left"> <CODE class="constant">GL_UNPACK_ALIGNMENT</CODE></TD><TD
align="center"> integer</TD><TD align="center"> 4</TD><TD align="center">
 1, 2, 4, or 8</TD></TR>
</TABLE>
</DIV>
<P> Boolean parameters are set to false if<EM class="parameter"> <CODE>
param</CODE></EM> is 0 and true otherwise.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3316">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>pname</CODE></EM> is not an accepted value.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if
 alignment is specified as other than 1, 2, 4, or 8.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3317">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_PACK_ALIGNMENT</CODE>
 or <CODE class="constant">GL_UNPACK_ALIGNMENT</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3318">See Also</A></H2>
<P> <A class="citerefentry" href="#glReadPixels">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReadPixels</A>, <A class="citerefentry" href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glTexSubImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexSubImage2D</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glPolygonOffset"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3320">Name</A></H2>
<P>glPolygonOffset -- set the scale and units used to calculate depth
 values</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3321">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glPolygonOffset</B>
(</CODE></TD><TD>GLfloat<VAR class="pdparam"> factor</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> units</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3322">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>factor</CODE></EM></DT>
<DD>
<P> Specifies a scale factor that is used to create a variable depth
 offset for each polygon. The initial value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>units</CODE></EM></DT>
<DD>
<P> Is multiplied by an implementation-specific value to create a
 constant depth offset. The initial value is 0.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3323">Description</A></H2>
<P> When <CODE class="constant">GL_POLYGON_OFFSET_FILL</CODE> is
 enabled, each fragment's
<!--span class=&quot;emphasis&quot;-->
<EM> depth</EM> value will be offset after it is interpolated from the
<!--span class=&quot;emphasis&quot;-->
<EM> depth</EM> values of the appropriate vertices. The value of the
 offset is
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 factor
<!--mml:mo-->
 &Atilde;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 DZ
<!--mml:mo-->
 +
<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 r
<!--mml:mo-->
 &Atilde;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 units , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 DZ is a measurement of the change in depth relative to the screen area
 of the polygon, and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 r is the smallest value that is guaranteed to produce a resolvable
 offset for a given implementation. The offset is added before the depth
 test is performed and before the value is written into the depth
 buffer.</P>
<P> <CODE class="function">glPolygonOffset</CODE> is useful for
 rendering hidden-line images, for applying decals to surfaces, and for
 rendering solids with highlighted edges.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3324">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> with argument <CODE class="constant">
GL_POLYGON_OFFSET_FILL</CODE>.</P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_POLYGON_OFFSET_FACTOR</CODE>
 or <CODE class="constant">GL_POLYGON_OFFSET_UNITS</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3325">See Also</A></H2>
<P> <A class="citerefentry" href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A>, <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A>, <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A>, <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glReadPixels"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3327">Name</A></H2>
<P>glReadPixels -- read a block of pixels from the frame buffer</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3328">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glReadPixels</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> x</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> y</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> width</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> height</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> format</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> type</VAR>,</TD></TR>
<TR><TD></TD><TD>GLvoid *<VAR class="pdparam"> data</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3329">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>x</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>y</CODE></EM></DT>
<DD>
<P> Specify the window coordinates of the first pixel that is read from
 the frame buffer. This location is the lower left corner of a
 rectangular block of pixels.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>width</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>height</CODE></EM></DT>
<DD>
<P> Specify the dimensions of the pixel rectangle.<EM class="parameter">
 <CODE>width</CODE></EM> and<EM class="parameter"> <CODE>height</CODE></EM>
 of one correspond to a single pixel.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>format</CODE></EM></DT>
<DD>
<P> Specifies the format of the pixel data. The following symbolic
 values are accepted: <CODE class="constant">GL_ALPHA</CODE>, <CODE class="constant">
GL_RGB</CODE>, and <CODE class="constant">GL_RGBA</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>type</CODE></EM></DT>
<DD>
<P> Specifies the data type of the pixel data. Must be one of <CODE class="constant">
GL_UNSIGNED_BYTE</CODE>, <CODE class="constant">GL_UNSIGNED_SHORT_5_6_5</CODE>
, <CODE class="constant">GL_UNSIGNED_SHORT_4_4_4_4</CODE>, or <CODE class="constant">
GL_UNSIGNED_SHORT_5_5_5_1</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>data</CODE></EM></DT>
<DD>
<P> Returns the pixel data.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3330">Description</A></H2>
<P> <CODE class="function">glReadPixels</CODE> returns pixel data from
 the frame buffer, starting with the pixel whose lower left corner is at
 location (<EM class="parameter"><CODE>x</CODE></EM>,<EM class="parameter">
 <CODE>y</CODE></EM>), into client memory starting at location<EM class="parameter">
 <CODE>data</CODE></EM>. The <CODE class="constant">GL_PACK_ALIGNMENT</CODE>
 parameter, set with the <A class="citerefentry" href="#glPixelStorei">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPixelStorei</A> command, affects the processing of the pixel data
 before it is placed into client memory.</P>
<P> <CODE class="function">glReadPixels</CODE> returns values from each
 pixel with lower left corner at
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 x
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 i
<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 y
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 j for
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 0
<!--mml:mo-->
 &lt;=
<!--mml:mi mathvariant=&quot;italic&quot;-->
 i
<!--mml:mo-->
 &lt;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 width and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 0
<!--mml:mo-->
 &lt;=
<!--mml:mi mathvariant=&quot;italic&quot;-->
 j
<!--mml:mo-->
 &lt;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 height . This pixel is said to be the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 ith pixel in the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 jth row. Pixels are returned in row order from the lowest to the
 highest row, left to right in each row.</P>
<P><EM class="parameter"> <CODE>format</CODE></EM> specifies the format
 for the returned pixel values; accepted values are:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ALPHA</CODE></DT>
<DD></DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RGB</CODE></DT>
<DD></DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RGBA</CODE></DT>
<DD></DD>
</DL>
</DIV>
<P> RGBA color components are read from the color buffer. Each color
 component is converted to floating point such that zero intensity maps
 to 0.0 and full intensity maps to 1.0.</P>
<P> Unneeded data is then discarded. For example, <CODE class="constant">
GL_ALPHA</CODE> discards the red, green, and blue components, while <CODE
class="constant">GL_RGB</CODE> discards only the alpha component. The
 final values are clamped to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 .</P>
<P> Finally, the components are converted to the proper format, as
 specified by<EM class="parameter"> <CODE>type</CODE></EM>. When<EM class="parameter">
 <CODE>type</CODE></EM> is <CODE class="constant">GL_UNSIGNED_BYTE</CODE>
, each component is multiplied by
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mn-->
 8
<!--mml:mo-->
 -
<!--mml:mn-->
 1 . When<EM class="parameter"> <CODE>type</CODE></EM> is <CODE class="constant">
GL_UNSIGNED_SHORT_5_6_5</CODE>, <CODE class="constant">
GL_UNSIGNED_SHORT_4_4_4_4</CODE>, or <CODE class="constant">
GL_UNSIGNED_SHORT_5_5_5_1</CODE>, each component is multiplied by
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi-->
 N
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 N is the number of bits in the bitfield.</P>
<P> Return values are placed in memory as follows. If<EM class="parameter">
 <CODE>format</CODE></EM> is <CODE class="constant">GL_ALPHA</CODE>, a
 single value is returned and the data for the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 ith pixel in the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 jth row is placed in location
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 j
<!--mml:mo-->
 &acirc;&cent;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 width
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 i . <CODE class="constant">GL_RGB</CODE> returns three values and <CODE class="constant">
GL_RGBA</CODE> returns four values for each pixel, with all values
 corresponding to a single pixel occupying contiguous space in<EM class="parameter">
 <CODE>data</CODE></EM>. Storage parameter <CODE class="constant">
GL_PACK_ALIGNMENT</CODE>, set by <A class="citerefentry" href="#glPixelStorei">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPixelStorei</A>, affects the way that data is written into memory. See
 <A class="citerefentry" href="#glPixelStorei">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPixelStorei</A> for a description.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3331">Notes</A></H2>
<P> If the currently bound framebuffer is not the default framebuffer
 object, color components are read from the color image attached to the <CODE
class="constant">GL_COLOR_ATTACHMENT0</CODE> attachment point.</P>
<P> Only two<EM class="parameter"> <CODE>format</CODE></EM>/<EM class="parameter">
<CODE>type</CODE></EM> parameter pairs are accepted. <CODE class="constant">
GL_RGBA</CODE>/<CODE class="constant">GL_UNSIGNED_BYTE</CODE> is always
 accepted, and the other acceptable pair can be discovered by querying <CODE
class="constant">GL_IMPLEMENTATION_COLOR_READ_FORMAT</CODE> and <CODE class="constant">
GL_IMPLEMENTATION_COLOR_READ_TYPE</CODE>.</P>
<P> Values for pixels that lie outside the window connected to the
 current GL context are undefined.</P>
<P> If an error is generated, no change is made to the contents of<EM class="parameter">
 <CODE>data</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3332">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>format</CODE></EM> or<EM class="parameter"> <CODE>type</CODE></EM>
 is not an accepted value.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if
 either<EM class="parameter"> <CODE>width</CODE></EM> or<EM class="parameter">
 <CODE>height</CODE></EM> is negative.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM
class="parameter"> <CODE>type</CODE></EM> is <CODE class="constant">
GL_UNSIGNED_SHORT_5_6_5</CODE> and<EM class="parameter"> <CODE>format</CODE>
</EM> is not <CODE class="constant">GL_RGB</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM
class="parameter"> <CODE>type</CODE></EM> is <CODE class="constant">
GL_UNSIGNED_SHORT_4_4_4_4</CODE> or <CODE class="constant">
GL_UNSIGNED_SHORT_5_5_5_1</CODE> and<EM class="parameter"> <CODE>format</CODE>
</EM> is not <CODE class="constant">GL_RGBA</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM
class="parameter"> <CODE>format</CODE></EM> and<EM class="parameter"> <CODE>
type</CODE></EM> are neither <CODE class="constant">GL_RGBA</CODE> and <CODE
class="constant">GL_UNSIGNED_BYTE</CODE>, respectively, nor the
 format/type pair returned by querying <CODE class="constant">
GL_IMPLEMENTATION_COLOR_READ_FORMAT</CODE> and <CODE class="constant">
GL_IMPLEMENTATION_COLOR_READ_TYPE</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_FRAMEBUFFER_OPERATION</CODE> is
 generated if the currently bound framebuffer is not framebuffer
 complete (i.e. the return value from <A class="citerefentry" href="#glCheckFramebufferStatus">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A> is not <CODE class="constant">
GL_FRAMEBUFFER_COMPLETE</CODE>).</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3333">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">
GL_IMPLEMENTATION_COLOR_READ_FORMAT</CODE> or <CODE class="constant">
GL_IMPLEMENTATION_COLOR_READ_TYPE</CODE></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_PACK_ALIGNMENT</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3334">See Also</A></H2>
<P> <A class="citerefentry" href="#glCheckFramebufferStatus">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCheckFramebufferStatus</A>, <A class="citerefentry" href="#glPixelStorei">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPixelStorei</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glReleaseShaderCompiler">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3336">Name</A></H2>
<P>glReleaseShaderCompiler -- release resources allocated by the shader
 compiler</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3337">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glReleaseShaderCompiler</B>(</CODE></TD><TD><VAR class="pdparam"> void</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="description"></A>
<H2><A NAME="0_3338">Description</A></H2>
<P>For implementations that support a shader compiler, <CODE class="function">
glReleaseShaderCompiler</CODE> frees resources allocated by the shader
 compiler. This is a hint from the application that additional shader
 compilations are unlikely to occur, at least for some period of time,
 and that the resources consumed by the shader compiler may be released
 and put to better use elsewhere.</P>
<P>However, if a call to <A class="citerefentry" href="#glCompileShader">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A> is made after a call to <CODE class="function">
glReleaseShaderCompiler</CODE>, the shader compiler must be restored to
 service the compilation request as if <CODE class="function">
glReleaseShaderCompiler</CODE> had never been called.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3339">Notes</A></H2>
<P>Shader compiler support is optional, and thus must be queried before
 use by calling <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SHADER_COMPILER</CODE>
. <A class="citerefentry" href="#glShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A>, <A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glGetShaderPrecisionFormat">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderPrecisionFormat</A>, and <CODE class="function">
glReleaseShaderCompiler</CODE> will each generate <CODE class="constant">
GL_INVALID_OPERATION</CODE> on implementations that do not support a
 shader compiler. Such implementations instead offer the <A class="citerefentry"
href="#glShaderBinary">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderBinary</A> alternative for supplying a pre-compiled shader
 binary.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3340">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if a
 shader compiler is not supported.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3341">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SHADER_COMPILER</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3342">See Also</A></H2>
<P><A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glRenderbufferStorage">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3344">Name</A></H2>
<P>glRenderbufferStorage -- create and initialize a renderbuffer
 object's data store</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3345">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glRenderbufferStorage</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> internalformat</VAR>,</TD>
</TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> width</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> height</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3346">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P>Specifies the renderbuffer target. The symbolic constant must be <CODE
class="constant">GL_RENDERBUFFER</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>internalformat</CODE></EM></DT>
<DD>
<P>Specifies the color-renderable, depth-renderable, or
 stencil-renderable format of the renderbuffer. Must be one of the
 following symbolic constants: <CODE class="constant">GL_RGBA4</CODE>, <CODE
class="constant">GL_RGB565</CODE>, <CODE class="constant">GL_RGB5_A1</CODE>
, <CODE class="constant">GL_DEPTH_COMPONENT16</CODE>, or <CODE class="constant">
GL_STENCIL_INDEX8</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>width</CODE></EM></DT>
<DD>
<P>Specifies the width of the renderbuffer in pixels.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>height</CODE></EM></DT>
<DD>
<P>Specifies the height of the renderbuffer in pixels.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3347">Description</A></H2>
<P><CODE class="function">glRenderbufferStorage</CODE> establishes the
 data storage, format, and dimensions of a renderbuffer object's image.
 Any existing data store for the renderbuffer is deleted and the
 contents of the new data store are undefined.</P>
<P>An implementation may vary its allocation of internal component
 resolution based on any <CODE class="function">glRenderbufferStorage</CODE>
 parameter (except<EM class="parameter"> <CODE>target</CODE></EM>), but
 the allocation and chosen internal format must not be a function of any
 other state and cannot be changed once they are established. The actual
 resolution in bits of each component of the allocated image can be
 queried with <A class="citerefentry" href="#glGetRenderbufferParameteriv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetRenderbufferParameteriv</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3348">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_RENDERBUFFER</CODE>
.</P>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>internalformat</CODE></EM> is not an accepted format.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>width</CODE></EM> or<EM class="parameter"> <CODE>height</CODE></EM>
 is less than zero or greater than <CODE class="constant">
GL_MAX_RENDERBUFFER_SIZE</CODE>.</P>
<P><CODE class="constant">GL_OUT_OF_MEMORY</CODE> is generated if the
 implementation is unable to create a data store with the requested<EM class="parameter">
 <CODE>width</CODE></EM> and<EM class="parameter"> <CODE>height</CODE></EM>
.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the reserved renderbuffer object name 0 is bound.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3349">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetRenderbufferParameteriv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetRenderbufferParameteriv</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3350">See Also</A></H2>
<P><A class="citerefentry" href="#glBindRenderbuffer">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindRenderbuffer</A>, <A class="citerefentry" href="#glDeleteRenderbuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteRenderbuffers</A>, <A class="citerefentry" href="#glFramebufferRenderbuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glFramebufferRenderbuffer</A>, <A class="citerefentry" href="#glGenRenderbuffers">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGenRenderbuffers</A>, <A class="citerefentry" href="#glGetRenderbufferParameteriv">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetRenderbufferParameteriv</A>, <A class="citerefentry" href="#glIsRenderbuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsRenderbuffer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glSampleCoverage"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3352">Name</A></H2>
<P>glSampleCoverage -- specify multisample coverage parameters</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3353">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glSampleCoverage</B>
(</CODE></TD><TD>GLclampf<VAR class="pdparam"> value</VAR>,</TD></TR>
<TR><TD></TD><TD>GLboolean<VAR class="pdparam"> invert</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3354">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>value</CODE></EM></DT>
<DD>
<P> Specify a single floating-point sample coverage value. The value is
 clamped to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mn-->
 1 . The initial value is 1.0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>invert</CODE></EM></DT>
<DD>
<P> Specify a single boolean value representing if the coverage masks
 should be inverted. <CODE class="constant">GL_TRUE</CODE> and <CODE class="constant">
GL_FALSE</CODE> are accepted. The initial value is <CODE class="constant">
GL_FALSE</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3355">Description</A></H2>
<P> Multisampling samples a pixel multiple times at various
 implementation-dependent subpixel locations to generate antialiasing
 effects. Multisampling transparently antialiases points, lines, and
 polygons if it is enabled.</P>
<P><EM class="parameter"> <CODE>value</CODE></EM> is used in
 constructing a temporary mask used in determining which samples will be
 used in resolving the final fragment color. This mask is bitwise-anded
 with the coverage mask generated from the multisampling computation. If
 the<EM class="parameter"> <CODE>invert</CODE></EM> flag is set, the
 temporary mask is inverted (all bits flipped) and then the bitwise-and
 is computed.</P>
<P> If an implementation does not have any multisample buffers
 available, or multisampling is disabled, rasterization occurs with only
 a single sample computing a pixel's final RGB color.</P>
<P> Provided an implementation supports multisample buffers, and
 multisampling is enabled, then a pixel's final color is generated by
 combining several samples per pixel. Each sample contains color, depth,
 and stencil information, allowing those operations to be performed on
 each sample.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3356">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SAMPLE_COVERAGE_VALUE</CODE>
</P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SAMPLE_COVERAGE_INVERT</CODE>
</P>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> with argument <CODE class="constant">
GL_SAMPLE_ALPHA_TO_COVERAGE</CODE></P>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> with argument <CODE class="constant">GL_SAMPLE_COVERAGE</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3357">See Also</A></H2>
<P> <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glScissor"></A><DIV class="titlepage">
</DIV><DIV class="refnamediv">
<H2><A NAME="0_3359">Name</A></H2>
<P>glScissor -- define the scissor box</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3360">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glScissor</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> x</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> y</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> width</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> height</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3361">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>x</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>y</CODE></EM></DT>
<DD>
<P> Specify the lower left corner of the scissor box. Initially (0, 0).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>width</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>height</CODE></EM></DT>
<DD>
<P> Specify the width and height of the scissor box. When a GL context
 is first attached to a window,<EM class="parameter"> <CODE>width</CODE></EM>
 and<EM class="parameter"> <CODE>height</CODE></EM> are set to the
 dimensions of that window.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3362">Description</A></H2>
<P> <CODE class="function">glScissor</CODE> defines a rectangle, called
 the scissor box, in window coordinates. The first two arguments,<EM class="parameter">
 <CODE>x</CODE></EM> and<EM class="parameter"> <CODE>y</CODE></EM>,
 specify the lower left corner of the box.<EM class="parameter"> <CODE>
width</CODE></EM> and<EM class="parameter"> <CODE>height</CODE></EM>
 specify the width and height of the box.</P>
<P> To enable and disable the scissor test, call <A class="citerefentry" href="#glEnable">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A> and <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisable</A> with argument <CODE class="constant">GL_SCISSOR_TEST</CODE>
. The test is initially disabled. While the test is enabled, only pixels
 that lie within the scissor box can be modified by drawing commands.
 Window coordinates have integer values at the shared corners of frame
 buffer pixels. <CODE class="code">glScissor(0,0,1,1)</CODE> allows
 modification of only the lower left pixel in the window, and <CODE class="code">
glScissor(0,0,0,0)</CODE> doesn't allow modification of any pixels in
 the window.</P>
<P> When the scissor test is disabled, it is as though the scissor box
 includes the entire window.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3363">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if
 either<EM class="parameter"> <CODE>width</CODE></EM> or<EM class="parameter">
 <CODE>height</CODE></EM> is negative.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3364">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SCISSOR_BOX</CODE></P>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> with argument <CODE class="constant">GL_SCISSOR_TEST</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3365">See Also</A></H2>
<P> <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A>, <A class="citerefentry" href="#glViewport">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glViewport</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glShaderBinary"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3367">Name</A></H2>
<P>glShaderBinary -- load a precompiled shader binary</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3368">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glShaderBinary</B>(</CODE>
</TD><TD>GLsizei<VAR class="pdparam"> n</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLuint *<VAR class="pdparam">shaders</VAR>,</TD>
</TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> binaryformat</VAR>,</TD></TR>
<TR><TD></TD><TD>const void *<VAR class="pdparam">binary</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> length</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3369">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>n</CODE></EM></DT>
<DD>
<P>Specifies the number of shader object handles present in<EM class="parameter">
 <CODE>shaders</CODE></EM>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shaders</CODE></EM></DT>
<DD>
<P>Specifies a pointer to an array of shader object handles into which
 the shader binary will be loaded.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>binaryformat</CODE></EM></DT>
<DD>
<P>Specifies the shader binary format.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>binary</CODE></EM></DT>
<DD>
<P>Specifies a pointer to the shader binary data in client memory.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>length</CODE></EM></DT>
<DD>
<P>Specifies the length of the shader binary data in bytes.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3370">Description</A></H2>
<P>For implementations that support them, <CODE class="function">
glShaderBinary</CODE> loads precompiled shader binaries.<EM class="parameter">
 <CODE>shaders</CODE></EM> contains a list of<EM class="parameter"> <CODE>
n</CODE></EM> shader object handles. Each handle refers to a unique
 shader type (vertex shader or fragment shader).<EM class="parameter"> <CODE>
binary</CODE></EM> points to precompiled binary shader code in client
 memory, and<EM class="parameter"> <CODE>binaryformat</CODE></EM>
 denotes the format of the pre-compiled code.</P>
<P>The binary image is decoded according to the extension specification
 defining the specified<EM class="parameter"> <CODE>binaryformat</CODE></EM>
. OpenGL ES defines no specific binary formats, but does provide a
 mechanism to obtain symbolic constants for such formats provided by
 extensions. The number of shader binary formats supported can be
 obtained by querying the value of <CODE class="constant">
GL_NUM_SHADER_BINARY_FORMATS</CODE>. The list of specific binary formats
 supported can be obtained by querying the value of <CODE class="constant">
GL_SHADER_BINARY_FORMATS</CODE>.</P>
<P>Depending on the types of the shader objects in<EM class="parameter">
 <CODE>shaders</CODE></EM>, <CODE class="function">glShaderBinary</CODE>
 will individually load binary vertex or fragment shaders, or load an
 executable binary that contains an optimized pair of vertex and
 fragment shaders stored in the same binary.</P>
<P>If <CODE class="function">glShaderBinary</CODE> fails, the old state
 of shader objects for which the binary was being loaded will not be
 restored.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3371">Notes</A></H2>
<P>Shader binary support is optional and thus must be queried before use
 by calling <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with arguments <CODE class="constant">
GL_NUM_SHADER_BINARY_FORMATS</CODE> and <CODE class="constant">
GL_SHADER_BINARY_FORMATS</CODE>. <CODE class="function">glShaderBinary</CODE>
 generates <CODE class="constant">GL_INVALID_OPERATION</CODE> on
 implementations that do not support any shader binary formats. Such
 implementations instead offer the <A class="citerefentry" href="#glShaderSource">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderSource</A> alternative for supplying OpenGL ES Shading Language
 shader source for compilation.</P>
<P>If shader binary formats are supported, then an implementation may
 require that an optimized pair of vertex and fragment shader binaries
 that were compiled together to be specified to <A class="citerefentry" href="#glLinkProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>. Not specifying an optimized pair my cause <A class="citerefentry"
href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A> to fail. Such a restriction, if it exists, will be
 documented in the extension specification defining<EM class="parameter">
 <CODE>binaryformat</CODE></EM>.</P>
<P>OpenGL copies the shader binary data when <CODE class="function">
glShaderBinary</CODE> is called, so an application may free its copy of
 the data immediately after the function returns.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3372">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>binaryformat</CODE></EM> is not a supported format returned in <CODE
class="constant">GL_SHADER_BINARY_FORMATS</CODE>.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if any
 value in<EM class="parameter"> <CODE>shaders</CODE></EM> is not a vlue
 generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if the
 format of the data pointed to by<EM class="parameter"> <CODE>binary</CODE>
</EM> does not match<EM class="parameter"> <CODE>binaryformat</CODE></EM>
.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>n</CODE></EM> or<EM class="parameter"> <CODE>length</CODE></EM>
 is negative.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 any value in<EM class="parameter"> <CODE>shaders</CODE></EM> is not a
 shader object, or if there is more than one vertex shader object handle
 or more than one fragment shader object handle in<EM class="parameter">
 <CODE>shaders</CODE></EM>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3373">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with arguments <CODE class="constant">
GL_NUM_SHADER_BINARY_FORMATS</CODE> and <CODE class="constant">
GL_SHADER_BINARY_FORMATS</CODE></P>
<P><A class="citerefentry" href="#glIsShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsShader</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3374">See Also</A></H2>
<P><A class="citerefentry" href="#glCreateShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateShader</A>, <A class="citerefentry" href="#glDeleteShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteShader</A>, <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glShaderSource"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3376">Name</A></H2>
<P>glShaderSource -- replace the source code in a shader object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3377">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glShaderSource</B>(</CODE>
</TD><TD>GLuint<VAR class="pdparam"> shader</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLchar **<VAR class="pdparam">string</VAR>,</TD>
</TR>
<TR><TD></TD><TD>const GLint *<VAR class="pdparam">length</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3378">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>shader</CODE></EM></DT>
<DD>
<P>Specifies the handle of the shader object whose source code is to be
 replaced.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>count</CODE></EM></DT>
<DD>
<P>Specifies the number of elements in the<EM class="parameter"> <CODE>
string</CODE></EM> and<EM class="parameter"> <CODE>length</CODE></EM>
 arrays.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>string</CODE></EM></DT>
<DD>
<P>Specifies an array of pointers to strings containing the source code
 to be loaded into the shader.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>length</CODE></EM></DT>
<DD>
<P>Specifies an array of string lengths.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3379">Description</A></H2>
<P>For implementations that support a shader compiler, <CODE class="function">
glShaderSource</CODE> sets the source code in<EM class="parameter"> <CODE>
shader</CODE></EM> to the source code in the array of strings specified
 by<EM class="parameter"> <CODE>string</CODE></EM>. Any source code
 previously stored in the shader object is completely replaced. The
 number of strings in the array is specified by<EM class="parameter"> <CODE>
count</CODE></EM>. If<EM class="parameter"> <CODE>length</CODE></EM> is <CODE
class="constant">NULL</CODE>, each string is assumed to be null
 terminated. If<EM class="parameter"> <CODE>length</CODE></EM> is a
 value other than <CODE class="constant">NULL</CODE>, it points to an
 array containing a string length for each of the corresponding elements
 of<EM class="parameter"> <CODE>string</CODE></EM>. Each element in the<EM
class="parameter"> <CODE>length</CODE></EM> array may contain the length
 of the corresponding string (the null character is not counted as part
 of the string length) or a value less than 0 to indicate that the
 string is null terminated. The source code strings are not scanned or
 parsed at this time; they are simply copied into the specified shader
 object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3380">Notes</A></H2>
<P>Shader compiler support is optional, and thus must be queried before
 use by calling <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SHADER_COMPILER</CODE>
. <CODE class="function">glShaderSource</CODE>, <A class="citerefentry" href="#glCompileShader">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glGetShaderPrecisionFormat">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderPrecisionFormat</A>, and <A class="citerefentry" href="#glReleaseShaderCompiler">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glReleaseShaderCompiler</A> will each generate <CODE class="constant">
GL_INVALID_OPERATION</CODE> on implementations that do not support a
 shader compiler. Such implementations instead offer the <A class="citerefentry"
href="#glShaderBinary">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glShaderBinary</A> alternative for supplying a pre-compiled shader
 binary.</P>
<P>OpenGL copies the shader source code strings when <CODE class="function">
glShaderSource</CODE> is called, so an application may free its copy of
 the source code strings immediately after the function returns.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3381">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if a
 shader compiler is not supported.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>shader</CODE></EM> is not a shader object.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>count</CODE></EM> is less than 0.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3382">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_SHADER_COMPILER</CODE></P>
<P><A class="citerefentry" href="#glGetShaderiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderiv</A> with arguments<EM class="parameter"> <CODE>shader</CODE>
</EM> and <CODE class="constant">GL_SHADER_SOURCE_LENGTH</CODE></P>
<P><A class="citerefentry" href="#glGetShaderSource">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderSource</A> with argument<EM class="parameter"> <CODE>shader</CODE>
</EM></P>
<P><A class="citerefentry" href="#glIsShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsShader</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3383">See Also</A></H2>
<P><A class="citerefentry" href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glGetShaderPrecisionFormat">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetShaderPrecisionFormat</A>, <A class="citerefentry" href="#glCreateShader">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateShader</A>, <A class="citerefentry" href="#glDeleteShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteShader</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glStencilFunc"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3385">Name</A></H2>
<P>glStencilFunc -- set front and back function and reference value for
 stencil testing</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3386">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glStencilFunc</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> func</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> ref</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> mask</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3387">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>func</CODE></EM></DT>
<DD>
<P> Specifies the test function. Eight symbolic constants are valid: <CODE
class="constant">GL_NEVER</CODE>, <CODE class="constant">GL_LESS</CODE>,
 <CODE class="constant">GL_LEQUAL</CODE>, <CODE class="constant">
GL_GREATER</CODE>, <CODE class="constant">GL_GEQUAL</CODE>, <CODE class="constant">
GL_EQUAL</CODE>, <CODE class="constant">GL_NOTEQUAL</CODE>, and <CODE class="constant">
GL_ALWAYS</CODE>. The initial value is <CODE class="constant">GL_ALWAYS</CODE>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>ref</CODE></EM></DT>
<DD>
<P> Specifies the reference value for the stencil test.<EM class="parameter">
 <CODE>ref</CODE></EM> is clamped to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
 n
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 n is the number of bitplanes in the stencil buffer. The initial value
 is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>mask</CODE></EM></DT>
<DD>
<P> Specifies a mask that is ANDed with both the reference value and the
 stored stencil value when the test is done. The initial value is all
 1's.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3388">Description</A></H2>
<P> Stenciling, like depth-buffering, enables and disables drawing on a
 per-pixel basis. Stencil planes are first drawn into using GL drawing
 primitives, then geometry and images are rendered using the stencil
 planes to mask out portions of the screen. Stenciling is typically used
 in multipass rendering algorithms to achieve special effects, such as
 decals, outlining, and constructive solid geometry rendering.</P>
<P> The stencil test conditionally eliminates a pixel based on the
 outcome of a comparison between the reference value and the value in
 the stencil buffer. To enable and disable the test, call <A class="citerefentry"
href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A> and <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisable</A> with argument <CODE class="constant">GL_STENCIL_TEST</CODE>
. To specify actions based on the outcome of the stencil test, call <A class="citerefentry"
href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A> or <A class="citerefentry" href="#glStencilOpSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A>.</P>
<P> There can be two separate sets of<EM class="parameter"> <CODE>func</CODE>
</EM>,<EM class="parameter"> <CODE>ref</CODE></EM>, and<EM class="parameter">
 <CODE>mask</CODE></EM> parameters; one affects back-facing polygons,
 and the other affects front-facing polygons as well as other
 non-polygon primitives. <A class="citerefentry" href="#glStencilFunc">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A> sets both front and back stencil state to the same
 values. Use <A class="citerefentry" href="#glStencilFuncSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A> to set front and back stencil state to
 different values.</P>
<P><EM class="parameter"> <CODE>func</CODE></EM> is a symbolic constant
 that determines the stencil comparison function. It accepts one of
 eight values, shown in the following list.<EM class="parameter"> <CODE>
ref</CODE></EM> is an integer reference value that is used in the
 stencil comparison. It is clamped to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
 n
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 n is the number of bitplanes in the stencil buffer.<EM class="parameter">
 <CODE>mask</CODE></EM> is bitwise ANDed with both the reference value
 and the stored stencil value, with the ANDed values participating in
 the comparison.</P>
<P> If
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> represents the value stored in the corresponding
 stencil buffer location, the following list shows the effect of each
 comparison function that can be specified by<EM class="parameter"> <CODE>
func</CODE></EM>. Only if the comparison succeeds is the pixel passed
 through to the next stage in the rasterization process (see <A class="citerefentry"
href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A>). All tests treat
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> values as unsigned integers in the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
 n
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 n is the number of bitplanes in the stencil buffer.</P>
<P> The following values are accepted by<EM class="parameter"> <CODE>
func</CODE></EM>:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NEVER</CODE></DT>
<DD>
<P> Always fails.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LESS</CODE></DT>
<DD>
<P> Passes if (<EM class="parameter"> <CODE>ref</CODE></EM> &amp;<EM class="parameter">
 <CODE>mask</CODE></EM> ) &lt; (
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> &amp;<EM class="parameter"> <CODE>mask</CODE></EM> ).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LEQUAL</CODE></DT>
<DD>
<P> Passes if (<EM class="parameter"> <CODE>ref</CODE></EM> &amp;<EM class="parameter">
 <CODE>mask</CODE></EM> ) &lt;= (
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> &amp;<EM class="parameter"> <CODE>mask</CODE></EM> ).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_GREATER</CODE></DT>
<DD>
<P> Passes if (<EM class="parameter"> <CODE>ref</CODE></EM> &amp;<EM class="parameter">
 <CODE>mask</CODE></EM> ) &gt; (
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> &amp;<EM class="parameter"> <CODE>mask</CODE></EM> ).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_GEQUAL</CODE></DT>
<DD>
<P> Passes if (<EM class="parameter"> <CODE>ref</CODE></EM> &amp;<EM class="parameter">
 <CODE>mask</CODE></EM> ) &gt;= (
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> &amp;<EM class="parameter"> <CODE>mask</CODE></EM> ).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_EQUAL</CODE></DT>
<DD>
<P> Passes if (<EM class="parameter"> <CODE>ref</CODE></EM> &amp;<EM class="parameter">
 <CODE>mask</CODE></EM> ) = (
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> &amp;<EM class="parameter"> <CODE>mask</CODE></EM> ).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NOTEQUAL</CODE></DT>
<DD>
<P> Passes if (<EM class="parameter"> <CODE>ref</CODE></EM> &amp;<EM class="parameter">
 <CODE>mask</CODE></EM> ) != (
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> &amp;<EM class="parameter"> <CODE>mask</CODE></EM> ).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ALWAYS</CODE></DT>
<DD>
<P> Always passes.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3389">Notes</A></H2>
<P> Initially, the stencil test is disabled. If there is no stencil
 buffer, no stencil modification can occur and it is as if the stencil
 test always passes.</P>
<P> <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A> is the same as calling <A class="citerefentry" href="#glStencilFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A> with<EM class="parameter"> <CODE>face</CODE></EM>
 set to <CODE class="constant">GL_FRONT_AND_BACK</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3390">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>func</CODE></EM> is not one of the eight accepted values.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3391">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_STENCIL_FUNC</CODE>, <CODE
class="constant">GL_STENCIL_VALUE_MASK</CODE>, <CODE class="constant">
GL_STENCIL_REF</CODE>, <CODE class="constant">GL_STENCIL_BACK_FUNC</CODE>
, <CODE class="constant">GL_STENCIL_BACK_VALUE_MASK</CODE>, <CODE class="constant">
GL_STENCIL_BACK_REF</CODE>, or <CODE class="constant">GL_STENCIL_BITS</CODE>
</P>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> with argument <CODE class="constant">GL_STENCIL_TEST</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3392">See Also</A></H2>
<P> <A class="citerefentry" href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A>, <A class="citerefentry" href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A>, <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A>, <A class="citerefentry" href="#glStencilFuncSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>, <A class="citerefentry" href="#glStencilMask">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A>, <A class="citerefentry" href="#glStencilMaskSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMaskSeparate</A>, <A class="citerefentry" href="#glStencilOp">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A>, <A class="citerefentry" href="#glStencilOpSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glStencilFuncSeparate">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3394">Name</A></H2>
<P>glStencilFuncSeparate -- set front and/or back function and
 reference value for stencil testing</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3395">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glStencilFuncSeparate</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 face</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> func</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> ref</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> mask</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3396">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>face</CODE></EM></DT>
<DD>
<P> Specifies whether front and/or back stencil state is updated. Three
 symbolic constants are valid: <CODE class="constant">GL_FRONT</CODE>, <CODE
class="constant">GL_BACK</CODE>, and <CODE class="constant">
GL_FRONT_AND_BACK</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>func</CODE></EM></DT>
<DD>
<P> Specifies the test function. Eight symbolic constants are valid: <CODE
class="constant">GL_NEVER</CODE>, <CODE class="constant">GL_LESS</CODE>,
 <CODE class="constant">GL_LEQUAL</CODE>, <CODE class="constant">
GL_GREATER</CODE>, <CODE class="constant">GL_GEQUAL</CODE>, <CODE class="constant">
GL_EQUAL</CODE>, <CODE class="constant">GL_NOTEQUAL</CODE>, and <CODE class="constant">
GL_ALWAYS</CODE>. The initial value is <CODE class="constant">GL_ALWAYS</CODE>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>ref</CODE></EM></DT>
<DD>
<P> Specifies the reference value for the stencil test.<EM class="parameter">
 <CODE>ref</CODE></EM> is clamped to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
 n
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 n is the number of bitplanes in the stencil buffer. The initial value
 is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>mask</CODE></EM></DT>
<DD>
<P> Specifies a mask that is ANDed with both the reference value and the
 stored stencil value when the test is done. The initial value is all
 1's.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3397">Description</A></H2>
<P> Stenciling, like depth-buffering, enables and disables drawing on a
 per-pixel basis. You draw into the stencil planes using GL drawing
 primitives, then render geometry and images, using the stencil planes
 to mask out portions of the screen. Stenciling is typically used in
 multipass rendering algorithms to achieve special effects, such as
 decals, outlining, and constructive solid geometry rendering.</P>
<P> The stencil test conditionally eliminates a pixel based on the
 outcome of a comparison between the reference value and the value in
 the stencil buffer. To enable and disable the test, call <A class="citerefentry"
href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A> and <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisable</A> with argument <CODE class="constant">GL_STENCIL_TEST</CODE>
. To specify actions based on the outcome of the stencil test, call <A class="citerefentry"
href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A> or <A class="citerefentry" href="#glStencilOpSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A>.</P>
<P> There can be two separate sets of<EM class="parameter"> <CODE>func</CODE>
</EM>,<EM class="parameter"> <CODE>ref</CODE></EM>, and<EM class="parameter">
 <CODE>mask</CODE></EM> parameters; one affects back-facing polygons,
 and the other affects front-facing polygons as well as other
 non-polygon primitives. <A class="citerefentry" href="#glStencilFunc">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A> sets both front and back stencil state to the same
 values, as if <A class="citerefentry" href="#glStencilFuncSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A> were called with<EM class="parameter"> <CODE>
face</CODE></EM> set to <CODE class="constant">GL_FRONT_AND_BACK</CODE>.</P>
<P><EM class="parameter"> <CODE>func</CODE></EM> is a symbolic constant
 that determines the stencil comparison function. It accepts one of
 eight values, shown in the following list.<EM class="parameter"> <CODE>
ref</CODE></EM> is an integer reference value that is used in the
 stencil comparison. It is clamped to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
 n
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 n is the number of bitplanes in the stencil buffer.<EM class="parameter">
 <CODE>mask</CODE></EM> is bitwise ANDed with both the reference value
 and the stored stencil value, with the ANDed values participating in
 the comparison.</P>
<P> If
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> represents the value stored in the corresponding
 stencil buffer location, the following list shows the effect of each
 comparison function that can be specified by<EM class="parameter"> <CODE>
func</CODE></EM>. Only if the comparison succeeds is the pixel passed
 through to the next stage in the rasterization process (see <A class="citerefentry"
href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A>). All tests treat
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> values as unsigned integers in the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mn-->
 0
<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
 n
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 n is the number of bitplanes in the stencil buffer.</P>
<P> The following values are accepted by<EM class="parameter"> <CODE>
func</CODE></EM>:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NEVER</CODE></DT>
<DD>
<P> Always fails.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LESS</CODE></DT>
<DD>
<P> Passes if (<EM class="parameter"> <CODE>ref</CODE></EM> &amp;<EM class="parameter">
 <CODE>mask</CODE></EM> ) &lt; (
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> &amp;<EM class="parameter"> <CODE>mask</CODE></EM> ).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LEQUAL</CODE></DT>
<DD>
<P> Passes if (<EM class="parameter"> <CODE>ref</CODE></EM> &amp;<EM class="parameter">
 <CODE>mask</CODE></EM> ) &lt;= (
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> &amp;<EM class="parameter"> <CODE>mask</CODE></EM> ).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_GREATER</CODE></DT>
<DD>
<P> Passes if (<EM class="parameter"> <CODE>ref</CODE></EM> &amp;<EM class="parameter">
 <CODE>mask</CODE></EM> ) &gt; (
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> &amp;<EM class="parameter"> <CODE>mask</CODE></EM> ).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_GEQUAL</CODE></DT>
<DD>
<P> Passes if (<EM class="parameter"> <CODE>ref</CODE></EM> &amp;<EM class="parameter">
 <CODE>mask</CODE></EM> ) &gt;= (
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> &amp;<EM class="parameter"> <CODE>mask</CODE></EM> ).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_EQUAL</CODE></DT>
<DD>
<P> Passes if (<EM class="parameter"> <CODE>ref</CODE></EM> &amp;<EM class="parameter">
 <CODE>mask</CODE></EM> ) = (
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> &amp;<EM class="parameter"> <CODE>mask</CODE></EM> ).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NOTEQUAL</CODE></DT>
<DD>
<P> Passes if (<EM class="parameter"> <CODE>ref</CODE></EM> &amp;<EM class="parameter">
 <CODE>mask</CODE></EM> ) != (
<!--span class=&quot;emphasis&quot;-->
<EM> stencil</EM> &amp;<EM class="parameter"> <CODE>mask</CODE></EM> ).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ALWAYS</CODE></DT>
<DD>
<P> Always passes.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3398">Notes</A></H2>
<P> Initially, the stencil test is disabled. If there is no stencil
 buffer, no stencil modification can occur and it is as if the stencil
 test always passes.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3399">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>face</CODE></EM> is not <CODE class="constant">GL_FRONT</CODE>, <CODE
class="constant">GL_BACK</CODE>, or <CODE class="constant">
GL_FRONT_AND_BACK</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>func</CODE></EM> is not one of the eight accepted values.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3400">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_STENCIL_FUNC</CODE>, <CODE
class="constant">GL_STENCIL_VALUE_MASK</CODE>, <CODE class="constant">
GL_STENCIL_REF</CODE>, <CODE class="constant">GL_STENCIL_BACK_FUNC</CODE>
, <CODE class="constant">GL_STENCIL_BACK_VALUE_MASK</CODE>, <CODE class="constant">
GL_STENCIL_BACK_REF</CODE>, or <CODE class="constant">GL_STENCIL_BITS</CODE>
</P>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> with argument <CODE class="constant">GL_STENCIL_TEST</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3401">See Also</A></H2>
<P> <A class="citerefentry" href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A>, <A class="citerefentry" href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A>, <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A>, <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A>, <A class="citerefentry" href="#glStencilMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A>, <A class="citerefentry" href="#glStencilMaskSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMaskSeparate</A>, <A class="citerefentry" href="#glStencilOp">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A>, <A class="citerefentry" href="#glStencilOpSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glStencilMask"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3403">Name</A></H2>
<P>glStencilMask -- control the front and back writing of individual
 bits in the stencil planes</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3404">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glStencilMask</B>(</CODE>
</TD><TD>GLuint<VAR class="pdparam"> mask</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3405">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>mask</CODE></EM></DT>
<DD>
<P> Specifies a bit mask to enable and disable writing of individual
 bits in the stencil planes. Initially, the mask is all 1's.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3406">Description</A></H2>
<P> <CODE class="function">glStencilMask</CODE> controls the writing of
 individual bits in the stencil planes. The least significant
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 n bits of<EM class="parameter"> <CODE>mask</CODE></EM>, where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 n is the number of bits in the stencil buffer, specify a mask. Where a
 1 appears in the mask, it's possible to write to the corresponding bit
 in the stencil buffer. Where a 0 appears, the corresponding bit is
 write-protected. Initially, all bits are enabled for writing.</P>
<P> There can be two separate<EM class="parameter"> <CODE>mask</CODE></EM>
 writemasks; one affects back-facing polygons, and the other affects
 front-facing polygons as well as other non-polygon primitives. <A class="citerefentry"
href="#glStencilMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A> sets both front and back stencil writemasks to the
 same values. Use <A class="citerefentry" href="#glStencilMaskSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMaskSeparate</A> to set front and back stencil writemasks to
 different values.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3407">Notes</A></H2>
<P> <A class="citerefentry" href="#glStencilMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A> is the same as calling <A class="citerefentry" href="#glStencilMaskSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMaskSeparate</A> with<EM class="parameter"> <CODE>face</CODE></EM>
 set to <CODE class="constant">GL_FRONT_AND_BACK</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3408">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_STENCIL_WRITEMASK</CODE>
, <CODE class="constant">GL_STENCIL_BACK_WRITEMASK</CODE>, or <CODE class="constant">
GL_STENCIL_BITS</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3409">See Also</A></H2>
<P> <A class="citerefentry" href="#glColorMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glColorMask</A>, <A class="citerefentry" href="#glDepthMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthMask</A>, <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A>, <A class="citerefentry" href="#glStencilFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>, <A class="citerefentry" href="#glStencilMaskSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMaskSeparate</A>, <A class="citerefentry" href="#glStencilOp">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A>, <A class="citerefentry" href="#glStencilOpSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glStencilMaskSeparate">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3411">Name</A></H2>
<P>glStencilMaskSeparate -- control the front and/or back writing of
 individual bits in the stencil planes</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3412">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glStencilMaskSeparate</B>(</CODE></TD><TD>GLenum<VAR class="pdparam">
 face</VAR>,</TD></TR>
<TR><TD></TD><TD>GLuint<VAR class="pdparam"> mask</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3413">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>face</CODE></EM></DT>
<DD>
<P> Specifies whether the front and/or back stencil writemask is
 updated. Three symbolic constants are valid: <CODE class="constant">
GL_FRONT</CODE>, <CODE class="constant">GL_BACK</CODE>, and <CODE class="constant">
GL_FRONT_AND_BACK</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>mask</CODE></EM></DT>
<DD>
<P> Specifies a bit mask to enable and disable writing of individual
 bits in the stencil planes. Initially, the mask is all 1's.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3414">Description</A></H2>
<P> <CODE class="function">glStencilMaskSeparate</CODE> controls the
 writing of individual bits in the stencil planes. The least significant
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 n bits of<EM class="parameter"> <CODE>mask</CODE></EM>, where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 n is the number of bits in the stencil buffer, specify a mask. Where a
 1 appears in the mask, it's possible to write to the corresponding bit
 in the stencil buffer. Where a 0 appears, the corresponding bit is
 write-protected. Initially, all bits are enabled for writing.</P>
<P> There can be two separate<EM class="parameter"> <CODE>mask</CODE></EM>
 writemasks; one affects back-facing polygons, and the other affects
 front-facing polygons as well as other non-polygon primitives. <A class="citerefentry"
href="#glStencilMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A> sets both front and back stencil writemasks to the
 same values, as if <A class="citerefentry" href="#glStencilMaskSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMaskSeparate</A> were called with<EM class="parameter"> <CODE>
face</CODE></EM> set to <CODE class="constant">GL_FRONT_AND_BACK</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3415">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>face</CODE></EM> is not <CODE class="constant">GL_FRONT</CODE>, <CODE
class="constant">GL_BACK</CODE>, or <CODE class="constant">
GL_FRONT_AND_BACK</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3416">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_STENCIL_WRITEMASK</CODE>
, <CODE class="constant">GL_STENCIL_BACK_WRITEMASK</CODE>, or <CODE class="constant">
GL_STENCIL_BITS</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3417">See Also</A></H2>
<P> <A class="citerefentry" href="#glColorMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glColorMask</A>, <A class="citerefentry" href="#glDepthMask">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthMask</A>, <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A>, <A class="citerefentry" href="#glStencilFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>, <A class="citerefentry" href="#glStencilMask">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A>, <A class="citerefentry" href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A>, <A class="citerefentry" href="#glStencilOpSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glStencilOp"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3419">Name</A></H2>
<P>glStencilOp -- set front and back stencil test actions</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3420">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glStencilOp</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> sfail</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> dpfail</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> dppass</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3421">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>sfail</CODE></EM></DT>
<DD>
<P> Specifies the action to take when the stencil test fails. Eight
 symbolic constants are accepted: <CODE class="constant">GL_KEEP</CODE>,
 <CODE class="constant">GL_ZERO</CODE>, <CODE class="constant">
GL_REPLACE</CODE>, <CODE class="constant">GL_INCR</CODE>, <CODE class="constant">
GL_INCR_WRAP</CODE>, <CODE class="constant">GL_DECR</CODE>, <CODE class="constant">
GL_DECR_WRAP</CODE>, and <CODE class="constant">GL_INVERT</CODE>. The
 initial value is <CODE class="constant">GL_KEEP</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>dpfail</CODE></EM></DT>
<DD>
<P> Specifies the stencil action when the stencil test passes, but the
 depth test fails.<EM class="parameter"> <CODE>dpfail</CODE></EM>
 accepts the same symbolic constants as<EM class="parameter"> <CODE>
sfail</CODE></EM>. The initial value is <CODE class="constant">GL_KEEP</CODE>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>dppass</CODE></EM></DT>
<DD>
<P> Specifies the stencil action when both the stencil test and the
 depth test pass, or when the stencil test passes and either there is no
 depth buffer or depth testing is not enabled.<EM class="parameter"> <CODE>
dppass</CODE></EM> accepts the same symbolic constants as<EM class="parameter">
 <CODE>sfail</CODE></EM>. The initial value is <CODE class="constant">
GL_KEEP</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3422">Description</A></H2>
<P> Stenciling, like depth-buffering, enables and disables drawing on a
 per-pixel basis. You draw into the stencil planes using GL drawing
 primitives, then render geometry and images, using the stencil planes
 to mask out portions of the screen. Stenciling is typically used in
 multipass rendering algorithms to achieve special effects, such as
 decals, outlining, and constructive solid geometry rendering.</P>
<P> The stencil test conditionally eliminates a pixel based on the
 outcome of a comparison between the value in the stencil buffer and a
 reference value. To enable and disable the test, call <A class="citerefentry"
href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A> and <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisable</A> with argument <CODE class="constant">GL_STENCIL_TEST</CODE>
; to control it, call <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A> or <A class="citerefentry" href="#glStencilFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>.</P>
<P> There can be two separate sets of<EM class="parameter"> <CODE>sfail</CODE>
</EM>,<EM class="parameter"> <CODE>dpfail</CODE></EM>, and<EM class="parameter">
 <CODE>dppass</CODE></EM> parameters; one affects back-facing polygons,
 and the other affects front-facing polygons as well as other
 non-polygon primitives. <A class="citerefentry" href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A> sets both front and back stencil state to the same
 values. Use <A class="citerefentry" href="#glStencilOpSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A> to set front and back stencil state to different
 values.</P>
<P> <CODE class="function">glStencilOp</CODE> takes three arguments that
 indicate what happens to the stored stencil value while stenciling is
 enabled. If the stencil test fails, no change is made to the pixel's
 color or depth buffers, and<EM class="parameter"> <CODE>sfail</CODE></EM>
 specifies what happens to the stencil buffer contents. The following
 eight actions are possible.</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_KEEP</CODE></DT>
<DD>
<P> Keeps the current value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ZERO</CODE></DT>
<DD>
<P> Sets the stencil buffer value to 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_REPLACE</CODE></DT>
<DD>
<P> Sets the stencil buffer value to
<!--span class=&quot;emphasis&quot;-->
<EM> ref</EM>, as specified by <A class="citerefentry" href="#glStencilFunc">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_INCR</CODE></DT>
<DD>
<P> Increments the current stencil buffer value. Clamps to the maximum
 representable unsigned value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_INCR_WRAP</CODE></DT>
<DD>
<P> Increments the current stencil buffer value. Wraps stencil buffer
 value to zero when incrementing the maximum representable unsigned
 value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DECR</CODE></DT>
<DD>
<P> Decrements the current stencil buffer value. Clamps to 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DECR_WRAP</CODE></DT>
<DD>
<P> Decrements the current stencil buffer value. Wraps stencil buffer
 value to the maximum representable unsigned value when decrementing a
 stencil buffer value of zero.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_INVERT</CODE></DT>
<DD>
<P> Bitwise inverts the current stencil buffer value.</P>
</DD>
</DL>
</DIV>
<P> Stencil buffer values are treated as unsigned integers. When
 incremented and decremented, values are clamped to 0 and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
 n
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 n is the value returned by querying <CODE class="constant">
GL_STENCIL_BITS</CODE>.</P>
<P> The other two arguments to <CODE class="function">glStencilOp</CODE>
 specify stencil buffer actions that depend on whether subsequent depth
 buffer tests succeed (<EM class="parameter"><CODE>dppass</CODE></EM>)
 or fail (<EM class="parameter"><CODE>dpfail</CODE></EM>) (see <A class="citerefentry"
href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A>). The actions are specified using the same eight
 symbolic constants as<EM class="parameter"> <CODE>sfail</CODE></EM>.
 Note that<EM class="parameter"> <CODE>dpfail</CODE></EM> is ignored
 when there is no depth buffer, or when the depth buffer is not enabled.
 In these cases,<EM class="parameter"> <CODE>sfail</CODE></EM> and<EM class="parameter">
 <CODE>dppass</CODE></EM> specify stencil action when the stencil test
 fails and passes, respectively.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3423">Notes</A></H2>
<P> Initially the stencil test is disabled. If there is no stencil
 buffer, no stencil modification can occur and it is as if the stencil
 tests always pass, regardless of any call to <CODE class="function">
glStencilOp</CODE>.</P>
<P> <A class="citerefentry" href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A> is the same as calling <A class="citerefentry" href="#glStencilOpSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A> with<EM class="parameter"> <CODE>face</CODE></EM>
 set to <CODE class="constant">GL_FRONT_AND_BACK</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3424">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>sfail</CODE></EM>,<EM class="parameter"> <CODE>dpfail</CODE></EM>
, or<EM class="parameter"> <CODE>dppass</CODE></EM> is any value other
 than the eight defined symbolic constant values.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3425">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_STENCIL_FAIL</CODE>, <CODE
class="constant">GL_STENCIL_PASS_DEPTH_PASS</CODE>, <CODE class="constant">
GL_STENCIL_PASS_DEPTH_FAIL</CODE>, <CODE class="constant">
GL_STENCIL_BACK_FAIL</CODE>, <CODE class="constant">
GL_STENCIL_BACK_PASS_DEPTH_PASS</CODE>, <CODE class="constant">
GL_STENCIL_BACK_PASS_DEPTH_FAIL</CODE>, or <CODE class="constant">
GL_STENCIL_BITS</CODE></P>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> with argument <CODE class="constant">GL_STENCIL_TEST</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3426">See Also</A></H2>
<P> <A class="citerefentry" href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A>, <A class="citerefentry" href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A>, <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A>, <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A>, <A class="citerefentry" href="#glStencilFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>, <A class="citerefentry" href="#glStencilMask">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A>, <A class="citerefentry" href="#glStencilMaskSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMaskSeparate</A>, <A class="citerefentry" href="#glStencilOpSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glStencilOpSeparate">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3428">Name</A></H2>
<P>glStencilOpSeparate -- set front and/or back stencil test actions</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3429">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glStencilOpSeparate</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> face</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> sfail</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> dpfail</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> dppass</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3430">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>face</CODE></EM></DT>
<DD>
<P> Specifies whether front and/or back stencil state is updated. Three
 symbolic constants are valid: <CODE class="constant">GL_FRONT</CODE>, <CODE
class="constant">GL_BACK</CODE>, and <CODE class="constant">
GL_FRONT_AND_BACK</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>sfail</CODE></EM></DT>
<DD>
<P> Specifies the action to take when the stencil test fails. Eight
 symbolic constants are accepted: <CODE class="constant">GL_KEEP</CODE>,
 <CODE class="constant">GL_ZERO</CODE>, <CODE class="constant">
GL_REPLACE</CODE>, <CODE class="constant">GL_INCR</CODE>, <CODE class="constant">
GL_INCR_WRAP</CODE>, <CODE class="constant">GL_DECR</CODE>, <CODE class="constant">
GL_DECR_WRAP</CODE>, and <CODE class="constant">GL_INVERT</CODE>. The
 initial value is <CODE class="constant">GL_KEEP</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>dpfail</CODE></EM></DT>
<DD>
<P> Specifies the stencil action when the stencil test passes, but the
 depth test fails.<EM class="parameter"> <CODE>dpfail</CODE></EM>
 accepts the same symbolic constants as<EM class="parameter"> <CODE>
sfail</CODE></EM>. The initial value is <CODE class="constant">GL_KEEP</CODE>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>dppass</CODE></EM></DT>
<DD>
<P> Specifies the stencil action when both the stencil test and the
 depth test pass, or when the stencil test passes and either there is no
 depth buffer or depth testing is not enabled.<EM class="parameter"> <CODE>
dppass</CODE></EM> accepts the same symbolic constants as<EM class="parameter">
 <CODE>sfail</CODE></EM>. The initial value is <CODE class="constant">
GL_KEEP</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3431">Description</A></H2>
<P> Stenciling, like depth-buffering, enables and disables drawing on a
 per-pixel basis. You draw into the stencil planes using GL drawing
 primitives, then render geometry and images, using the stencil planes
 to mask out portions of the screen. Stenciling is typically used in
 multipass rendering algorithms to achieve special effects, such as
 decals, outlining, and constructive solid geometry rendering.</P>
<P> The stencil test conditionally eliminates a pixel based on the
 outcome of a comparison between the value in the stencil buffer and a
 reference value. To enable and disable the test, call <A class="citerefentry"
href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A> and <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisable</A> with argument <CODE class="constant">GL_STENCIL_TEST</CODE>
; to control it, call <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A> or <A class="citerefentry" href="#glStencilFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>.</P>
<P> There can be two separate sets of<EM class="parameter"> <CODE>sfail</CODE>
</EM>,<EM class="parameter"> <CODE>dpfail</CODE></EM>, and<EM class="parameter">
 <CODE>dppass</CODE></EM> parameters; one affects back-facing polygons,
 and the other affects front-facing polygons as well as other
 non-polygon primitives. <A class="citerefentry" href="#glStencilOp">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A> sets both front and back stencil state to the same
 values, as if <A class="citerefentry" href="#glStencilOpSeparate">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOpSeparate</A> were called with<EM class="parameter"> <CODE>
face</CODE></EM> set to <CODE class="constant">GL_FRONT_AND_BACK</CODE>.</P>
<P> <CODE class="function">glStencilOpSeparate</CODE> takes three
 arguments that indicate what happens to the stored stencil value while
 stenciling is enabled. If the stencil test fails, no change is made to
 the pixel's color or depth buffers, and<EM class="parameter"> <CODE>
sfail</CODE></EM> specifies what happens to the stencil buffer contents.
 The following eight actions are possible.</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_KEEP</CODE></DT>
<DD>
<P> Keeps the current value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ZERO</CODE></DT>
<DD>
<P> Sets the stencil buffer value to 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_REPLACE</CODE></DT>
<DD>
<P> Sets the stencil buffer value to
<!--span class=&quot;emphasis&quot;-->
<EM> ref</EM>, as specified by <A class="citerefentry" href="#glStencilFunc">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_INCR</CODE></DT>
<DD>
<P> Increments the current stencil buffer value. Clamps to the maximum
 representable unsigned value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_INCR_WRAP</CODE></DT>
<DD>
<P> Increments the current stencil buffer value. Wraps stencil buffer
 value to zero when incrementing the maximum representable unsigned
 value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DECR</CODE></DT>
<DD>
<P> Decrements the current stencil buffer value. Clamps to 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_DECR_WRAP</CODE></DT>
<DD>
<P> Decrements the current stencil buffer value. Wraps stencil buffer
 value to the maximum representable unsigned value when decrementing a
 stencil buffer value of zero.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_INVERT</CODE></DT>
<DD>
<P> Bitwise inverts the current stencil buffer value.</P>
</DD>
</DL>
</DIV>
<P> Stencil buffer values are treated as unsigned integers. When
 incremented and decremented, values are clamped to 0 and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
 n
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 n is the value returned by querying <CODE class="constant">
GL_STENCIL_BITS</CODE>.</P>
<P> The other two arguments to <CODE class="function">
glStencilOpSeparate</CODE> specify stencil buffer actions that depend on
 whether subsequent depth buffer tests succeed (<EM class="parameter"><CODE>
dppass</CODE></EM>) or fail (<EM class="parameter"><CODE>dpfail</CODE></EM>
) (see <A class="citerefentry" href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A>). The actions are specified using the same eight
 symbolic constants as<EM class="parameter"> <CODE>sfail</CODE></EM>.
 Note that<EM class="parameter"> <CODE>dpfail</CODE></EM> is ignored
 when there is no depth buffer, or when the depth buffer is not enabled.
 In these cases,<EM class="parameter"> <CODE>sfail</CODE></EM> and<EM class="parameter">
 <CODE>dppass</CODE></EM> specify stencil action when the stencil test
 fails and passes, respectively.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3432">Notes</A></H2>
<P> Initially the stencil test is disabled. If there is no stencil
 buffer, no stencil modification can occur and it is as if the stencil
 test always passes.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3433">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>face</CODE></EM> is any value other than <CODE class="constant">
GL_FRONT</CODE>, <CODE class="constant">GL_BACK</CODE>, or <CODE class="constant">
GL_FRONT_AND_BACK</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>sfail</CODE></EM>,<EM class="parameter"> <CODE>dpfail</CODE></EM>
, or<EM class="parameter"> <CODE>dppass</CODE></EM> is any value other
 than the eight defined symbolic constant values.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3434">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_STENCIL_FAIL</CODE>, <CODE
class="constant">GL_STENCIL_PASS_DEPTH_PASS</CODE>, <CODE class="constant">
GL_STENCIL_PASS_DEPTH_FAIL</CODE>, <CODE class="constant">
GL_STENCIL_BACK_FAIL</CODE>, <CODE class="constant">
GL_STENCIL_BACK_PASS_DEPTH_PASS</CODE>, <CODE class="constant">
GL_STENCIL_BACK_PASS_DEPTH_FAIL</CODE>, or <CODE class="constant">
GL_STENCIL_BITS</CODE></P>
<P> <A class="citerefentry" href="#glIsEnabled">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsEnabled</A> with argument <CODE class="constant">GL_STENCIL_TEST</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3435">See Also</A></H2>
<P> <A class="citerefentry" href="#glBlendFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBlendFunc</A>, <A class="citerefentry" href="#glDepthFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthFunc</A>, <A class="citerefentry" href="#glEnable">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnable</A>, <A class="citerefentry" href="#glStencilFunc">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFunc</A>, <A class="citerefentry" href="#glStencilFuncSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilFuncSeparate</A>, <A class="citerefentry" href="#glStencilMask">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMask</A>, <A class="citerefentry" href="#glStencilMaskSeparate">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilMaskSeparate</A>, <A class="citerefentry" href="#glStencilOp">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glStencilOp</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glTexImage2D"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3437">Name</A></H2>
<P>glTexImage2D -- specify a two-dimensional texture image</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3438">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glTexImage2D</B>(</CODE>
</TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> level</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> internalformat</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> width</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> height</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> border</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> format</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> type</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLvoid *<VAR class="pdparam"> data</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV>
<P></P>
<DIV class="refsect1"  lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3439">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target texture of the active texture unit. Must be <CODE
class="constant">GL_TEXTURE_2D</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>level</CODE></EM></DT>
<DD>
<P> Specifies the level-of-detail number. Level 0 is the base image
 level. Level
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM> is the
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM>th mipmap reduction image.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>internalformat</CODE></EM></DT>
<DD>
<P> Specifies the internal format of the texture. Must be one of the
 following symbolic constants: <CODE class="constant">GL_ALPHA</CODE>, <CODE
class="constant">GL_LUMINANCE</CODE>, <CODE class="constant">
GL_LUMINANCE_ALPHA</CODE>, <CODE class="constant">GL_RGB</CODE>, <CODE class="constant">
GL_RGBA</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>width</CODE></EM></DT>
<DD>
<P> Specifies the width of the texture image. All implementations
 support 2D texture images that are at least 64 texels wide and
 cube-mapped texture images that are at least 16 texels wide.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>height</CODE></EM></DT>
<DD>
<P> Specifies the height of the texture image All implementations
 support 2D texture images that are at least 64 texels high and
 cube-mapped texture images that are at least 16 texels high.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>border</CODE></EM></DT>
<DD>
<P> Specifies the width of the border. Must be 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>format</CODE></EM></DT>
<DD>
<P> Specifies the format of the texel data. Must match<EM class="parameter">
 <CODE>internalformat</CODE></EM>. The following symbolic values are
 accepted: <CODE class="constant">GL_ALPHA</CODE>, <CODE class="constant">
GL_RGB</CODE>, <CODE class="constant">GL_RGBA</CODE>, <CODE class="constant">
GL_LUMINANCE</CODE>, and <CODE class="constant">GL_LUMINANCE_ALPHA</CODE>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>type</CODE></EM></DT>
<DD>
<P> Specifies the data type of the texel data. The following symbolic
 values are accepted: <CODE class="constant">GL_UNSIGNED_BYTE</CODE>, <CODE
class="constant">GL_UNSIGNED_SHORT_5_6_5</CODE>, <CODE class="constant">
GL_UNSIGNED_SHORT_4_4_4_4</CODE>, and <CODE class="constant">
GL_UNSIGNED_SHORT_5_5_5_1</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>data</CODE></EM></DT>
<DD>
<P> Specifies a pointer to the image data in memory.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3440">Description</A></H2>
<P> Texturing maps a portion of a specified texture image onto each
 graphical primitive for which texturing is active. Texturing is active
 when the current fragment shader or vertex shader makes use of built-in
 texture lookup functions.</P>
<P> To define texture images, call <CODE class="function">glTexImage2D</CODE>
. The arguments describe the parameters of the texture image, such as
 height, width, level-of-detail number (see <A class="citerefentry" href="#glTexParameter">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A>), and format. The last three arguments describe how
 the image is represented in memory.</P>
<P> Data is read from<EM class="parameter"> <CODE>data</CODE></EM> as a
 sequence of unsigned bytes or shorts, depending on<EM class="parameter">
 <CODE>type</CODE></EM>. When<EM class="parameter"> <CODE>type</CODE></EM>
 is <CODE class="constant">GL_UNSIGNED_BYTE</CODE>, each of the bytes is
 interpreted as one color component. When<EM class="parameter"> <CODE>
type</CODE></EM> is one of <CODE class="constant">
GL_UNSIGNED_SHORT_5_6_5</CODE>, <CODE class="constant">
GL_UNSIGNED_SHORT_4_4_4_4</CODE>, or <CODE class="constant">
GL_UNSIGNED_SHORT_5_5_5_1</CODE>, each unsigned short value is
 interpreted as containing all the components for a single texel, with
 the color components arranged according to<EM class="parameter"> <CODE>
format</CODE></EM>. Color components are treated as groups of one, two,
 three, or four values, again based on<EM class="parameter"> <CODE>
format</CODE></EM>. Groups of components are referred to as texels.</P>
<P>
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 width
<!--mml:mo-->
 &Atilde;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 height texels are read from memory, starting at location<EM class="parameter">
 <CODE>data</CODE></EM>. By default, these texels are taken from
 adjacent memory locations, except that after all<EM class="parameter"> <CODE>
width</CODE></EM> texels are read, the read pointer is advanced to the
 next four-byte boundary. The four-byte row alignment is specified by <A class="citerefentry"
href="#glPixelStorei">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPixelStorei</A> with argument <CODE class="constant">
GL_UNPACK_ALIGNMENT</CODE>, and it can be set to one, two, four, or
 eight bytes.</P>
<P> The first element corresponds to the lower left corner of the
 texture image. Subsequent elements progress left-to-right through the
 remaining texels in the lowest row of the texture image, and then in
 successively higher rows of the texture image. The final element
 corresponds to the upper right corner of the texture image.</P>
<P><EM class="parameter"> <CODE>format</CODE></EM> determines the
 composition of each element in<EM class="parameter"> <CODE>data</CODE></EM>
. It can assume one of these symbolic values:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_ALPHA</CODE></DT>
<DD>
<P> Each element is a single alpha component. The GL converts it to
 floating point and assembles it into an RGBA element by attaching 0 for
 red, green, and blue. Each component is then clamped to the range
 [0,1].</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RGB</CODE></DT>
<DD>
<P> Each element is an RGB triple. The GL converts it to floating point
 and assembles it into an RGBA element by attaching 1 for alpha. Each
 component is then clamped to the range [0,1].</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_RGBA</CODE></DT>
<DD>
<P> Each element contains all four components. The GL converts it to
 floating point, then each component is clamped to the range [0,1].</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LUMINANCE</CODE></DT>
<DD>
<P> Each element is a single luminance value. The GL converts it to
 floating point, then assembles it into an RGBA element by replicating
 the luminance value three times for red, green, and blue and attaching
 1 for alpha. Each component is then clamped to the range [0,1].</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LUMINANCE_ALPHA</CODE></DT>
<DD>
<P> Each element is a luminance/alpha pair. The GL converts it to
 floating point, then assembles it into an RGBA element by replicating
 the luminance value three times for red, green, and blue. Each
 component is then clamped to the range [0,1].</P>
</DD>
</DL>
</DIV>
<P> Color components are converted to floating point based on the<EM class="parameter">
 <CODE>type</CODE></EM>. When<EM class="parameter"> <CODE>type</CODE></EM>
 is <CODE class="constant">GL_UNSIGNED_BYTE</CODE>, each component is
 divided by
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mn-->
 8
<!--mml:mo-->
 -
<!--mml:mn-->
 1 . When<EM class="parameter"> <CODE>type</CODE></EM> is <CODE class="constant">
GL_UNSIGNED_SHORT_5_6_5</CODE>, <CODE class="constant">
GL_UNSIGNED_SHORT_4_4_4_4</CODE>, or <CODE class="constant">
GL_UNSIGNED_SHORT_5_5_5_1</CODE>, each component is divided by
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi-->
 N
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 N is the number of bits in the bitfield.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3441">Notes</A></H2>
<P><EM class="parameter"> <CODE>internalformat</CODE></EM> must match<EM class="parameter">
 <CODE>format</CODE></EM>. No conversion between formats is supported
 during texture image processing.<EM class="parameter"> <CODE>type</CODE>
</EM> may be used as a hint to specify how much precision is desired,
 but a GL implementation may choose to store the texture array at any
 internal resolution it chooses.</P>
<P><EM class="parameter"> <CODE>data</CODE></EM> may be a null pointer.
 In this case, texture memory is allocated to accommodate a texture of
 width<EM class="parameter"> <CODE>width</CODE></EM> and height<EM class="parameter">
 <CODE>height</CODE></EM>. You can then download subtextures to
 initialize this texture memory. The image is undefined if the user
 tries to apply an uninitialized portion of the texture image to a
 primitive.</P>
<P> <CODE class="function">glTexImage2D</CODE> specifies a
 two-dimensional or cube-map texture for the current texture unit,
 specified with <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3442">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>
, <CODE class="constant">GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>format</CODE></EM> or<EM class="parameter"> <CODE>type</CODE></EM>
 is not an accepted value.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is one of the six cube map 2D image targets
 and the width and height parameters are not equal.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>level</CODE></EM> is less than 0.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> may be generated if<EM
class="parameter"> <CODE>level</CODE></EM> is greater than
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 max , where
<!--span class=&quot;emphasis&quot;-->
<EM> max</EM> is the returned value of <CODE class="constant">
GL_MAX_TEXTURE_SIZE</CODE> when<EM class="parameter"> <CODE>target</CODE>
</EM> is <CODE class="constant">GL_TEXTURE_2D</CODE> or <CODE class="constant">
GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE> when<EM class="parameter"> <CODE>
target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>internalformat</CODE></EM> is not an accepted format.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>width</CODE></EM> or<EM class="parameter"> <CODE>height</CODE></EM>
 is less than 0 or greater than <CODE class="constant">
GL_MAX_TEXTURE_SIZE</CODE> when<EM class="parameter"> <CODE>target</CODE>
</EM> is <CODE class="constant">GL_TEXTURE_2D</CODE> or <CODE class="constant">
GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE> when<EM class="parameter"> <CODE>
target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>border</CODE></EM> is not 0.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM
class="parameter"> <CODE>format</CODE></EM> does not match<EM class="parameter">
 <CODE>internalformat</CODE></EM>.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM
class="parameter"> <CODE>type</CODE></EM> is <CODE class="constant">
GL_UNSIGNED_SHORT_5_6_5</CODE> and<EM class="parameter"> <CODE>format</CODE>
</EM> is not <CODE class="constant">GL_RGB</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM
class="parameter"> <CODE>type</CODE></EM> is <CODE class="constant">
GL_UNSIGNED_SHORT_4_4_4_4</CODE> or <CODE class="constant">
GL_UNSIGNED_SHORT_5_5_5_1</CODE> and<EM class="parameter"> <CODE>format</CODE>
</EM> is not <CODE class="constant">GL_RGBA</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3443">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_TEXTURE_SIZE</CODE>
 or <CODE class="constant">GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3444">See Also</A></H2>
<P> <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>, <A class="citerefentry" href="#glCompressedTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexImage2D</A>, <A class="citerefentry" href="#glCompressedTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexSubImage2D</A>, <A class="citerefentry" href="#glCopyTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A>, <A class="citerefentry" href="#glCopyTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexSubImage2D</A>, <A class="citerefentry" href="#glPixelStorei">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPixelStorei</A>, <A class="citerefentry" href="#glTexSubImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexSubImage2D</A>, <A class="citerefentry" href="#glTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" title="glTexParameter"><A id="glTexParameter"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3446">Name</A></H2>
<P>glTexParameter -- set texture parameters</P>
</DIV><DIV class="refsynopsisdiv" title="C Specification">
<H2><A NAME="0_3447">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glTexParameterf</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> param</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV><DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glTexParameteri</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> param</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
title="Parameters"><A id="parameters"></A>
<H2><A NAME="0_3448">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target texture of the active texture unit, which must
 be either <CODE class="constant">GL_TEXTURE_2D</CODE> or <CODE class="constant">
GL_TEXTURE_CUBE_MAP</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pname</CODE></EM></DT>
<DD>
<P> Specifies the symbolic name of a single-valued texture parameter.<EM class="parameter">
 <CODE>pname</CODE></EM> can be one of the following: <CODE class="constant">
GL_TEXTURE_MIN_FILTER</CODE>, <CODE class="constant">
GL_TEXTURE_MAG_FILTER</CODE>, <CODE class="constant">GL_TEXTURE_WRAP_S</CODE>
, or <CODE class="constant">GL_TEXTURE_WRAP_T</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>param</CODE></EM></DT>
<DD>
<P> Specifies the value of<EM class="parameter"> <CODE>pname</CODE></EM>
.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsynopsisdiv" title="C Specification">
<H2><A NAME="0_3449">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glTexParameterfv</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLfloat *<VAR class="pdparam"> params</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV><DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glTexParameteriv</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> pname</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLint *<VAR class="pdparam"> params</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
title="Parameters"><A id="parameters2"></A>
<H2><A NAME="0_3450">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target texture of the active texture unit, which must
 be either <CODE class="constant">GL_TEXTURE_2D</CODE> or <CODE class="constant">
GL_TEXTURE_CUBE_MAP</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pname</CODE></EM></DT>
<DD>
<P> Specifies the symbolic name of a texture parameter.<EM class="parameter">
 <CODE>pname</CODE></EM> can be one of the following: <CODE class="constant">
GL_TEXTURE_MIN_FILTER</CODE>, <CODE class="constant">
GL_TEXTURE_MAG_FILTER</CODE>, <CODE class="constant">GL_TEXTURE_WRAP_S</CODE>
, or <CODE class="constant">GL_TEXTURE_WRAP_T</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>params</CODE></EM></DT>
<DD>
<P> Specifies a pointer to an array where the value of<EM class="parameter">
 <CODE>pname</CODE></EM> is stored.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  title="Description"><A id="description">
</A>
<H2><A NAME="0_3451">Description</A></H2>
<P> Texture mapping is a technique that applies an image onto an
 object's surface as if the image were a decal or cellophane
 shrink-wrap. The image is created in texture space, with an (
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
s,
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 t) coordinate system. A texture is a two-dimensional or cube-mapped
 image and a set of parameters that determine how samples are derived
 from the image.</P>
<P> <CODE class="function">glTexParameter</CODE> assigns the value or
 values in<EM class="parameter"> <CODE>params</CODE></EM> to the texture
 parameter specified as<EM class="parameter"> <CODE>pname</CODE></EM>.<EM
class="parameter"> <CODE>target</CODE></EM> defines the target texture
 of the active texture unit, either <CODE class="constant">GL_TEXTURE_2D</CODE>
 or <CODE class="constant">GL_TEXTURE_CUBE_MAP</CODE>. The following
 symbols are accepted in<EM class="parameter"> <CODE>pname</CODE></EM>:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_TEXTURE_MIN_FILTER</CODE></DT>
<DD>
<P> The texture minifying function is used whenever the pixel being
 textured maps to an area greater than one texture element. There are
 six defined minifying functions. Two of them use the nearest one or
 nearest four texture elements to compute the texture value. The other
 four use mipmaps.</P>
<P> A mipmap is an ordered set of arrays representing the same image at
 progressively lower resolutions. If the texture has dimensions
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 w
<!--mml:mo-->
 &Atilde;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 h , there are
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 floor
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 max
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 w
<!--mml:mi mathvariant=&quot;italic&quot;-->
 h
<!--mml:mo-->
 +
<!--mml:mn-->
 1 mipmap levels. The first mipmap level is the original texture, with
 dimensions
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 w
<!--mml:mo-->
 &Atilde;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 h . Each subsequent mipmap level has dimensions
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 max
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 floor
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 w
<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
 i
<!--mml:mo-->
 &Atilde;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 max
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mn-->
 1
<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 floor
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 h
<!--mml:msup-->

<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
 i , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 i is the mipmap level, until the final mipmap is reached, which has
 dimension
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 1
<!--mml:mo-->
 &Atilde;
<!--mml:mn-->
 1 .</P>
<P> To define the mipmap levels, call <A class="citerefentry" href="#glTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glCompressedTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexImage2D</A>, or <A class="citerefentry" href="#glCopyTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A> with the
<!--span class=&quot;emphasis&quot;-->
<EM> level</EM> argument indicating the order of the mipmaps. Level 0 is
 the original texture; level
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 floor
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 max
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 w
<!--mml:mi mathvariant=&quot;italic&quot;-->
 h is the final
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 1
<!--mml:mo-->
 &Atilde;
<!--mml:mn-->
 1 mipmap.</P>
<P><EM class="parameter"> <CODE>params</CODE></EM> supplies a function
 for minifying the texture as one of the following:</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NEAREST</CODE></DT>
<DD>
<P> Returns the value of the texture element that is nearest (in
 Manhattan distance) to the center of the pixel being textured.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LINEAR</CODE></DT>
<DD>
<P> Returns the weighted average of the four texture elements that are
 closest to the center of the pixel being textured.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NEAREST_MIPMAP_NEAREST</CODE></DT>
<DD>
<P> Chooses the mipmap that most closely matches the size of the pixel
 being textured and uses the <CODE class="constant">GL_NEAREST</CODE>
 criterion (the texture element nearest to the center of the pixel) to
 produce a texture value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LINEAR_MIPMAP_NEAREST</CODE></DT>
<DD>
<P> Chooses the mipmap that most closely matches the size of the pixel
 being textured and uses the <CODE class="constant">GL_LINEAR</CODE>
 criterion (a weighted average of the four texture elements that are
 closest to the center of the pixel) to produce a texture value.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NEAREST_MIPMAP_LINEAR</CODE></DT>
<DD>
<P> Chooses the two mipmaps that most closely match the size of the
 pixel being textured and uses the <CODE class="constant">GL_NEAREST</CODE>
 criterion (the texture element nearest to the center of the pixel) to
 produce a texture value from each mipmap. The final texture value is a
 weighted average of those two values.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LINEAR_MIPMAP_LINEAR</CODE></DT>
<DD>
<P> Chooses the two mipmaps that most closely match the size of the
 pixel being textured and uses the <CODE class="constant">GL_LINEAR</CODE>
 criterion (a weighted average of the four texture elements that are
 closest to the center of the pixel) to produce a texture value from
 each mipmap. The final texture value is a weighted average of those two
 values.</P>
</DD>
</DL>
</DIV>
<P></P>
<P> As more texture elements are sampled in the minification process,
 fewer aliasing artifacts will be apparent. While the <CODE class="constant">
GL_NEAREST</CODE> and <CODE class="constant">GL_LINEAR</CODE>
 minification functions can be faster than the other four, they sample
 only one or four texture elements to determine the texture value of the
 pixel being rendered and can produce moire patterns or ragged
 transitions. The initial value of <CODE class="constant">
GL_TEXTURE_MIN_FILTER</CODE> is <CODE class="constant">
GL_NEAREST_MIPMAP_LINEAR</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_TEXTURE_MAG_FILTER</CODE></DT>
<DD>
<P> The texture magnification function is used when the pixel being
 textured maps to an area less than or equal to one texture element. It
 sets the texture magnification function to either <CODE class="constant">
GL_NEAREST</CODE> or <CODE class="constant">GL_LINEAR</CODE> (see
 below). <CODE class="constant">GL_NEAREST</CODE> is generally faster
 than <CODE class="constant">GL_LINEAR</CODE>, but it can produce
 textured images with sharper edges because the transition between
 texture elements is not as smooth. The initial value of <CODE class="constant">
GL_TEXTURE_MAG_FILTER</CODE> is <CODE class="constant">GL_LINEAR</CODE>.</P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_NEAREST</CODE></DT>
<DD>
<P> Returns the value of the texture element that is nearest (in
 Manhattan distance) to the center of the pixel being textured.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_LINEAR</CODE></DT>
<DD>
<P> Returns the weighted average of the four texture elements that are
 closest to the center of the pixel being textured.</P>
</DD>
</DL>
</DIV>
<P></P>
<P></P>
<P></P>
</DD>
</DL>
</DIV>
<P></P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_TEXTURE_WRAP_S</CODE></DT>
<DD>
<P> Sets the wrap parameter for texture coordinate
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s to either <CODE class="constant">GL_CLAMP_TO_EDGE</CODE>, <CODE class="constant">
GL_MIRRORED_REPEAT</CODE>, or <CODE class="constant">GL_REPEAT</CODE>. <CODE
class="constant">GL_CLAMP_TO_EDGE</CODE> causes
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s coordinates to be clamped to the range
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;[&quot; close=&quot;]&quot;-->

<!--mml:mfenced open=&quot;&quot; close=&quot;&quot;-->

<!--mml:mrow-->

<!--mml:mfrac-->

<!--mml:mn-->
 1
<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
N
<!--mml:mrow-->

<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mfenced open=&quot;&quot; close=&quot;&quot;-->

<!--mml:mrow-->

<!--mml:mfrac-->

<!--mml:mn-->
 1
<!--mml:mn-->
 2
<!--mml:mi mathvariant=&quot;italic&quot;-->
N , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 N is the size of the texture in the direction of clamping. <CODE class="constant">
GL_REPEAT</CODE> causes the integer part of the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s coordinate to be ignored; the GL uses only the fractional part,
 thereby creating a repeating pattern. <CODE class="constant">
GL_MIRRORED_REPEAT</CODE> causes the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s coordinate to be set to the fractional part of the texture coordinate
 if the integer part of
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s is even; if the integer part of
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s is odd, then the
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s texture coordinate is set to
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mn-->
 1
<!--mml:mo-->
 -
<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 frac
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 frac
<!--mml:mo-->
 &acirc;&iexcl;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s represents the fractional part of
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 s. Initially, <CODE class="constant">GL_TEXTURE_WRAP_S</CODE> is set to
 <CODE class="constant">GL_REPEAT</CODE>.</P>
</DD>
</DL>
</DIV>
<P></P>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<CODE class="constant">GL_TEXTURE_WRAP_T</CODE></DT>
<DD>
<P> Sets the wrap parameter for texture coordinate
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 t to either <CODE class="constant">GL_CLAMP_TO_EDGE</CODE>, <CODE class="constant">
GL_MIRRORED_REPEAT</CODE>, or <CODE class="constant">GL_REPEAT</CODE>.
 See the discussion under <CODE class="constant">GL_TEXTURE_WRAP_S</CODE>
. Initially, <CODE class="constant">GL_TEXTURE_WRAP_T</CODE> is set to <CODE
class="constant">GL_REPEAT</CODE>.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  title="Notes"><A id="notes"></A>
<H2><A NAME="0_3452">Notes</A></H2>
<P> Suppose that a texture is accessed from a fragment shader or vertex
 shader and has set <CODE class="constant">GL_TEXTURE_MIN_FILTER</CODE>
 to one of the functions that requires mipmaps. If either the dimensions
 of the texture images currently defined (with previous calls to <A class="citerefentry"
href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glCompressedTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexImage2D</A>, or <A class="citerefentry" href="#glCopyTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A>) do not follow the proper sequence for mipmaps
 (described above), or there are fewer texture images defined than are
 needed, or the set of texture images were defined with different
 formats or types, then the texture image unit will return (R, G, B, A)
 = (0, 0, 0, 1).</P>
<P> Similarly, if the width or height of a texture image are not powers
 of two and either the <CODE class="constant">GL_TEXTURE_MIN_FILTER</CODE>
 is set to one of the functions that requires mipmaps or the <CODE class="constant">
GL_TEXTURE_WRAP_S</CODE> or <CODE class="constant">GL_TEXTURE_WRAP_T</CODE>
 is not set to <CODE class="constant">GL_CLAMP_TO_EDGE</CODE>, then the
 texture image unit will return (R, G, B, A) = (0, 0, 0, 1).</P>
<P> <CODE class="function">glTexParameter</CODE> specifies the texture
 parameters for the texture bound to the active texture unit, specified
 by calling <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>.</P>
</DIV><DIV class="refsect1"  title="Errors"><A id="errors"></A>
<H2><A NAME="0_3453">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> or<EM class="parameter"> <CODE>pname</CODE></EM>
 is not one of the accepted defined values.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>params</CODE></EM> should have a defined symbolic constant value
 (based on the value of<EM class="parameter"> <CODE>pname</CODE></EM>)
 and does not.</P>
</DIV><DIV class="refsect1"  title="Associated Gets"><A id="associatedgets">
</A>
<H2><A NAME="0_3454">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGetTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetTexParameter</A></P>
</DIV><DIV class="refsect1"  title="See Also"><A id="seealso"></A>
<H2><A NAME="0_3455">See Also</A></H2>
<P> <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>, <A class="citerefentry" href="#glBindTexture">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindTexture</A>, <A class="citerefentry" href="#glCopyTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A>, <A class="citerefentry" href="#glCopyTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexSubImage2D</A>, <A class="citerefentry" href="#glPixelStorei">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPixelStorei</A>, <A class="citerefentry" href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glTexSubImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexSubImage2D</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glTexSubImage2D"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3457">Name</A></H2>
<P>glTexSubImage2D -- specify a two-dimensional texture subimage</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3458">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glTexSubImage2D</B>
(</CODE></TD><TD>GLenum<VAR class="pdparam"> target</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> level</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> xoffset</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> yoffset</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> width</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> height</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> format</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> type</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLvoid *<VAR class="pdparam"> data</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV>
<P></P>
<DIV class="refsect1"  lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3459">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>target</CODE></EM></DT>
<DD>
<P> Specifies the target texture of the active texture unit. Must be <CODE
class="constant">GL_TEXTURE_2D</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>level</CODE></EM></DT>
<DD>
<P> Specifies the level-of-detail number. Level 0 is the base image
 level. Level
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM> is the
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM>th mipmap reduction image.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>xoffset</CODE></EM></DT>
<DD>
<P> Specifies a texel offset in the x direction within the texture
 array.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>yoffset</CODE></EM></DT>
<DD>
<P> Specifies a texel offset in the y direction within the texture
 array.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>width</CODE></EM></DT>
<DD>
<P> Specifies the width of the texture subimage.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>height</CODE></EM></DT>
<DD>
<P> Specifies the height of the texture subimage.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>format</CODE></EM></DT>
<DD>
<P> Specifies the format of the pixel data. The following symbolic
 values are accepted: <CODE class="constant">GL_ALPHA</CODE>, <CODE class="constant">
GL_RGB</CODE>, <CODE class="constant">GL_RGBA</CODE>, <CODE class="constant">
GL_LUMINANCE</CODE>, and <CODE class="constant">GL_LUMINANCE_ALPHA</CODE>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>type</CODE></EM></DT>
<DD>
<P> Specifies the data type of the pixel data. The following symbolic
 values are accepted: <CODE class="constant">GL_UNSIGNED_BYTE</CODE>, <CODE
class="constant">GL_UNSIGNED_SHORT_5_6_5</CODE>, <CODE class="constant">
GL_UNSIGNED_SHORT_4_4_4_4</CODE>, and <CODE class="constant">
GL_UNSIGNED_SHORT_5_5_5_1</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>data</CODE></EM></DT>
<DD>
<P> Specifies a pointer to the image data in memory.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3460">Description</A></H2>
<P> Texturing maps a portion of a specified texture image onto each
 graphical primitive for which texturing is active. Texturing is active
 when the current fragment shader or vertex shader makes use of built-in
 texture lookup functions.</P>
<P> <CODE class="function">glTexSubImage2D</CODE> redefines a contiguous
 subregion of an existing two-dimensional texture image. The texels
 referenced by<EM class="parameter"> <CODE>data</CODE></EM> replace the
 portion of the existing texture array with x indices<EM class="parameter">
 <CODE>xoffset</CODE></EM> and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 xoffset
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 width
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , inclusive, and y indices<EM class="parameter"> <CODE>yoffset</CODE></EM>
 and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 yoffset
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 height
<!--mml:mo-->
 -
<!--mml:mn-->
 1 , inclusive. This region may not include any texels outside the range
 of the texture array as it was originally specified. It is not an error
 to specify a subtexture with zero width or height, but such a
 specification has no effect.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3461">Notes</A></H2>
<P> Storage parameter <CODE class="constant">GL_UNPACK_ALIGNMENT</CODE>,
 set by <A class="citerefentry" href="#glPixelStorei">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPixelStorei</A>, affects the way that data is read out of client
 memory. See <A class="citerefentry" href="#glPixelStorei">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPixelStorei</A> for a description.</P>
<P> <CODE class="function">glTexSubImage2D</CODE> specifies a
 two-dimensional or cube-map subtexture for the current texture unit,
 specified with <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3462">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>target</CODE></EM> is not <CODE class="constant">GL_TEXTURE_2D</CODE>
, <CODE class="constant">GL_TEXTURE_CUBE_MAP_POSITIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</CODE>, <CODE class="constant">
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</CODE>, or <CODE class="constant">
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>format</CODE></EM> or<EM class="parameter"> <CODE>type</CODE></EM>
 is not an accepted value.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>level</CODE></EM> is less than 0.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> may be generated if<EM
class="parameter"> <CODE>level</CODE></EM> is greater than
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 log
<!--mml:mn-->
 2
<!--span class=&quot;emphasis&quot;-->
<EM> max</EM>, where
<!--span class=&quot;emphasis&quot;-->
<EM> max</EM> is the returned value of <CODE class="constant">
GL_MAX_TEXTURE_SIZE</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 xoffset
<!--mml:mo-->
 &lt; 0 ,
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 xoffset
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 width
<!--mml:mo-->
 &gt;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 w ,
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 yoffset
<!--mml:mo-->
 &lt; 0 , or
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 yoffset
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 height
<!--mml:mo-->
 &gt;
<!--mml:mi mathvariant=&quot;italic&quot;-->
 h , where
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 w is the width and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 h is the height of the texture image being modified.</P>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>width</CODE></EM> or<EM class="parameter"> <CODE>height</CODE></EM>
 is less than 0.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the texture array has not been defined by a previous <A class="citerefentry"
href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A> or <A class="citerefentry" href="#glCopyTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A> operation whose<EM class="parameter"> <CODE>
internalformat</CODE></EM> matches the<EM class="parameter"> <CODE>
format</CODE></EM> of <CODE class="function">glTexSubImage2D</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM
class="parameter"> <CODE>type</CODE></EM> is <CODE class="constant">
GL_UNSIGNED_SHORT_5_6_5</CODE> and<EM class="parameter"> <CODE>format</CODE>
</EM> is not <CODE class="constant">GL_RGB</CODE>.</P>
<P> <CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM
class="parameter"> <CODE>type</CODE></EM> is <CODE class="constant">
GL_UNSIGNED_SHORT_4_4_4_4</CODE> or <CODE class="constant">
GL_UNSIGNED_SHORT_5_5_5_1</CODE> and<EM class="parameter"> <CODE>format</CODE>
</EM> is not <CODE class="constant">GL_RGBA</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3463">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_TEXTURE_SIZE</CODE>
 or <CODE class="constant">GL_MAX_CUBE_MAP_TEXTURE_SIZE</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3464">See Also</A></H2>
<P> <A class="citerefentry" href="#0_2644">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glActiveTexture</A>, <A class="citerefentry" href="#glCompressedTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexImage2D</A>, <A class="citerefentry" href="#glCompressedTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompressedTexSubImage2D</A>, <A class="citerefentry" href="#glCopyTexImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexImage2D</A>, <A class="citerefentry" href="#glCopyTexSubImage2D">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCopyTexSubImage2D</A>, <A class="citerefentry" href="#glPixelStorei">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glPixelStorei</A>, <A class="citerefentry" href="#glTexImage2D">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexImage2D</A>, <A class="citerefentry" href="#glTexParameter">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glTexParameter</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glUniform"></A><DIV class="titlepage">
</DIV><DIV class="refnamediv">
<H2><A NAME="0_3466">Name</A></H2>
<P>glUniform -- specify the value of a uniform variable for the current
 program object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3467">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform1f</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v0</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform2f</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v0</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v1</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform3f</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v0</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v1</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v2</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform4f</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v0</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v1</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v2</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v3</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform1i</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> v0</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform2i</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> v0</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> v1</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform3i</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> v0</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> v1</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> v2</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform4i</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> v0</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> v1</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> v2</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> v3</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3468">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>location</CODE></EM></DT>
<DD>
<P>Specifies the location of the uniform variable to be modified.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>v0</CODE></EM>,<EM class="parameter"> <CODE>
v1</CODE></EM>,<EM class="parameter"> <CODE>v2</CODE></EM>,<EM class="parameter">
 <CODE>v3</CODE></EM></DT>
<DD>
<P>Specifies the new values to be used for the specified uniform
 variable.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3469">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform1fv</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLfloat *<VAR class="pdparam">value</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform2fv</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLfloat *<VAR class="pdparam">value</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform3fv</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLfloat *<VAR class="pdparam">value</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform4fv</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLfloat *<VAR class="pdparam">value</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform1iv</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLint *<VAR class="pdparam">value</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform2iv</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLint *<VAR class="pdparam">value</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform3iv</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLint *<VAR class="pdparam">value</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniform4iv</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLint *<VAR class="pdparam">value</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters2"></A>
<H2><A NAME="0_3470">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>location</CODE></EM></DT>
<DD>
<P>Specifies the location of the uniform value to be modified.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>count</CODE></EM></DT>
<DD>
<P>Specifies the number of elements that are to be modified. This should
 be 1 if the targeted uniform variable is not an array, and 1 or more if
 it is an array.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>value</CODE></EM></DT>
<DD>
<P>Specifies a pointer to an array of<EM class="parameter"> <CODE>count</CODE>
</EM> values that will be used to update the specified uniform variable.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3471">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniformMatrix2fv</B>
(</CODE></TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>GLboolean<VAR class="pdparam"> transpose</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLfloat *<VAR class="pdparam">value</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniformMatrix3fv</B>
(</CODE></TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>GLboolean<VAR class="pdparam"> transpose</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLfloat *<VAR class="pdparam">value</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUniformMatrix4fv</B>
(</CODE></TD><TD>GLint<VAR class="pdparam"> location</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> count</VAR>,</TD></TR>
<TR><TD></TD><TD>GLboolean<VAR class="pdparam"> transpose</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLfloat *<VAR class="pdparam">value</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters3"></A>
<H2><A NAME="0_3472">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>location</CODE></EM></DT>
<DD>
<P>Specifies the location of the uniform value to be modified.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>count</CODE></EM></DT>
<DD>
<P>Specifies the number of matrices that are to be modified. This should
 be 1 if the targeted uniform variable is not an array of matrices, and
 1 or more if it is an array of matrices.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>transpose</CODE></EM></DT>
<DD>
<P>Specifies whether to transpose the matrix as the values are loaded
 into the uniform variable. Must be <CODE class="constant">GL_FALSE</CODE>
.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>value</CODE></EM></DT>
<DD>
<P>Specifies a pointer to an array of<EM class="parameter"> <CODE>count</CODE>
</EM> values that will be used to update the specified uniform variable.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3473">Description</A></H2>
<P><CODE class="function">glUniform</CODE> modifies the value of a
 uniform variable or a uniform variable array. The location of the
 uniform variable to be modified is specified by<EM class="parameter"> <CODE>
location</CODE></EM>, which should be a value returned by <A class="citerefentry"
href="#glGetUniformLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniformLocation</A>. <CODE class="function">glUniform</CODE>
 operates on the program object that was made part of current state by
 calling <A class="citerefentry" href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A>.</P>
<P>The commands <CODE class="function">glUniform{1|2|3|4}{f|i}</CODE>
 are used to change the value of the uniform variable specified by<EM class="parameter">
 <CODE>location</CODE></EM> using the values passed as arguments. The
 number specified in the command should match the number of components
 in the data type of the specified uniform variable (e.g., <CODE class="function">
1</CODE> for float, int, bool; <CODE class="function">2</CODE> for vec2,
 ivec2, bvec2, etc.). The suffix <CODE class="function">f</CODE>
 indicates that floating-point values are being passed; the suffix <CODE class="function">
i</CODE> indicates that integer values are being passed, and this type
 should also match the data type of the specified uniform variable. The <CODE
class="function">i</CODE> variants of this function should be used to
 provide values for uniform variables defined as int, ivec2, ivec3,
 ivec4, or arrays of these. The <CODE class="function">f</CODE> variants
 should be used to provide values for uniform variables of type float,
 vec2, vec3, vec4, or arrays of these. Either the <CODE class="function">
i</CODE> or the <CODE class="function">f</CODE> variants may be used to
 provide values for uniform variables of type bool, bvec2, bvec3, bvec4,
 or arrays of these. The uniform variable will be set to false if the
 input value is 0 or 0.0f, and it will be set to true otherwise.</P>
<P>All active uniform variables defined in a program object are
 initialized to 0 when the program object is linked successfully. They
 retain the values assigned to them by a call to <CODE class="function">
glUniform</CODE> until the next successful link operation occurs on the
 program object, when they are once again initialized to 0.</P>
<P>The commands <CODE class="function">glUniform{1|2|3|4}{f|i}v</CODE>
 can be used to modify a single uniform variable or a uniform variable
 array. These commands pass a count and a pointer to the values to be
 loaded into a uniform variable or a uniform variable array. A count of
 1 should be used if modifying the value of a single uniform variable,
 and a count of 1 or greater can be used to modify an entire array or
 part of an array. When loading
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM> elements starting at an arbitrary position
<!--span class=&quot;emphasis&quot;-->
<EM> m</EM> in a uniform variable array, elements
<!--span class=&quot;emphasis&quot;-->
<EM> m</EM> +
<!--span class=&quot;emphasis&quot;-->
<EM> n</EM> - 1 in the array will be replaced with the new values. If<EM class="parameter">
 <CODE>m</CODE></EM> +<EM class="parameter"> <CODE>n</CODE></EM> - 1 is
 larger than the size of the uniform variable array, values for all
 array elements beyond the end of the array will be ignored. The number
 specified in the name of the command indicates the number of components
 for each element in<EM class="parameter"> <CODE>value</CODE></EM>, and
 it should match the number of components in the data type of the
 specified uniform variable (e.g., <CODE class="function">1</CODE> for
 float, int, bool; <CODE class="function">2</CODE> for vec2, ivec2,
 bvec2, etc.). The data type specified in the name of the command must
 match the data type for the specified uniform variable as described
 previously for <CODE class="function">glUniform{1|2|3|4}{f|i}</CODE>.</P>
<P>For uniform variable arrays, each element of the array is considered
 to be of the type indicated in the name of the command (e.g., <CODE class="function">
glUniform3f</CODE> or <CODE class="function">glUniform3fv</CODE> can be
 used to load a uniform variable array of type vec3). The number of
 elements of the uniform variable array to be modified is specified by<EM
class="parameter"> <CODE>count</CODE></EM></P>
<P>The commands <CODE class="function">glUniformMatrix{2|3|4}fv</CODE>
 are used to modify a matrix or an array of matrices. The numbers in the
 command name are interpreted as the dimensionality of the matrix. The
 number <CODE class="function">2</CODE> indicates a 2 &Atilde; 2 matrix (i.e.,
 4 values), the number <CODE class="function">3</CODE> indicates a 3 &Atilde;
 3 matrix (i.e., 9 values), and the number <CODE class="function">4</CODE>
 indicates a 4 &Atilde; 4 matrix (i.e., 16 values). Each matrix is assumed to
 be supplied in column major order. The<EM class="parameter"> <CODE>
count</CODE></EM> argument indicates the number of matrices to be
 passed. A count of 1 should be used if modifying the value of a single
 matrix, and a count greater than 1 can be used to modify an array of
 matrices.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3474">Notes</A></H2>
<P><CODE class="function">glUniform1i</CODE> and <CODE class="function">
glUniform1iv</CODE> are the only two functions that may be used to load
 uniform variables defined as sampler types. Loading samplers with any
 other function will result in a <CODE class="constant">
GL_INVALID_OPERATION</CODE> error.</P>
<P>If<EM class="parameter"> <CODE>count</CODE></EM> is greater than 1
 and the indicated uniform variable is not an array, a <CODE class="constant">
GL_INVALID_OPERATION</CODE> error is generated and the specified uniform
 variable will remain unchanged.</P>
<P>Other than the preceding exceptions, if the type and size of the
 uniform variable as defined in the shader do not match the type and
 size specified in the name of the command used to load its value, a <CODE
class="constant">GL_INVALID_OPERATION</CODE> error will be generated and
 the specified uniform variable will remain unchanged.</P>
<P>If<EM class="parameter"> <CODE>location</CODE></EM> is a value other
 than -1 and it does not represent a valid uniform variable location in
 the current program object, an error will be generated, and no changes
 will be made to the uniform variable storage of the current program
 object. If<EM class="parameter"> <CODE>location</CODE></EM> is equal to
 -1, the data passed in will be silently ignored and the specified
 uniform variable will not be changed.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3475">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 there is no current program object.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 the size of the uniform variable declared in the shader does not match
 the size indicated by the <CODE class="function">glUniform</CODE>
 command.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if
 one of the integer variants of this function is used to load a uniform
 variable of type float, vec2, vec3, vec4, or an array of these, or if
 one of the floating-point variants of this function is used to load a
 uniform variable of type int, ivec2, ivec3, or ivec4, or an array of
 these.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>location</CODE></EM> is an invalid uniform location for the
 current program object and<EM class="parameter"> <CODE>location</CODE></EM>
 is not equal to -1.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>count</CODE></EM> is less than 0.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>transpose</CODE></EM> is not <CODE class="constant">GL_FALSE</CODE>
.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>count</CODE></EM> is greater than 1 and the indicated uniform
 variable is not an array variable.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if a
 sampler is loaded using a command other than <CODE class="function">
glUniform1i</CODE> and <CODE class="function">glUniform1iv</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3476">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with the argument <CODE class="constant">GL_CURRENT_PROGRAM</CODE>
</P>
<P><A class="citerefentry" href="#glGetActiveUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveUniform</A> with the handle of a program object and the index
 of an active uniform variable</P>
<P><A class="citerefentry" href="#glGetUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniform</A> with the handle of a program object and the location of
 a uniform variable</P>
<P><A class="citerefentry" href="#glGetUniformLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniformLocation</A> with the handle of a program object and the
 name of a uniform variable</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3477">See Also</A></H2>
<P><A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glUseProgram"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3479">Name</A></H2>
<P>glUseProgram -- install a program object as part of current
 rendering state</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3480">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glUseProgram</B>(</CODE>
</TD><TD>GLuint<VAR class="pdparam"> program</VAR><CODE>)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3481">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the handle of the program object whose executables are to
 be used as part of current rendering state.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3482">Description</A></H2>
<P><CODE class="function">glUseProgram</CODE> installs the program
 object specified by<EM class="parameter"> <CODE>program</CODE></EM> as
 part of current rendering state. One or more executables are created in
 a program object by successfully attaching shader objects to it with <A class="citerefentry"
href="#glAttachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glAttachShader</A>, successfully compiling the shader objects with <A class="citerefentry"
href="#glCompileShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, and successfully linking the program object with <A class="citerefentry"
href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>.</P>
<P>A program object will contain executables that will run on the vertex
 and fragment processors if it contains one or more shader objects of
 type <CODE class="constant">GL_VERTEX_SHADER</CODE> and one or more
 shader objects of type <CODE class="constant">GL_FRAGMENT_SHADER</CODE>
 that have all been successfully compiled and linked.</P>
<P>While a program object is in use, applications are free to modify
 attached shader objects, compile attached shader objects, attach
 additional shader objects, and detach or delete shader objects. None of
 these operations will affect the executables that are part of the
 current state. However, relinking the program object that is currently
 in use will install the program object as part of the current rendering
 state if the link operation was successful (see <A class="citerefentry" href="#glLinkProgram">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A> ). If the program object currently in use is relinked
 unsuccessfully, its link status will be set to <CODE class="constant">
GL_FALSE</CODE>, but the executables and associated state will remain
 part of the current state until a subsequent call to <CODE class="function">
glUseProgram</CODE> removes it from use. After it is removed from use,
 it cannot be made part of current state until it has been successfully
 relinked.</P>
<P>If<EM class="parameter"> <CODE>program</CODE></EM> is 0, then the
 current rendering state refers to an invalid program object, and the
 results of vertex and fragment shader execution due to any <A class="citerefentry"
href="#glDrawArrays">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawArrays</A> or <A class="citerefentry" href="#glDrawElements">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawElements</A> commands are undefined.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3483">Notes</A></H2>
<P>Like texture objects and buffer objects, the name space for program
 objects may be shared across a set of contexts, as long as the server
 sides of the contexts share the same address space. If the name space
 is shared across contexts, any attached objects and the data associated
 with those attached objects are shared as well.</P>
<P>Applications are responsible for providing the synchronization across
 API calls when objects are accessed from different execution threads.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3484">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is neither 0 nor a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> could not be made part of current state.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3485">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with the argument <CODE class="constant">GL_CURRENT_PROGRAM</CODE>
</P>
<P><A class="citerefentry" href="#glGetActiveAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveAttrib</A> with a valid program object and the index of an
 active attribute variable</P>
<P><A class="citerefentry" href="#glGetActiveUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveUniform</A> with a valid program object and the index of an
 active uniform variable</P>
<P><A class="citerefentry" href="#glGetAttachedShaders">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttachedShaders</A> with a valid program object</P>
<P><A class="citerefentry" href="#glGetAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttribLocation</A> with a valid program object and the name of an
 attribute variable</P>
<P><A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with a valid program object and the parameter to be
 queried</P>
<P><A class="citerefentry" href="#glGetProgramInfoLog">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramInfoLog</A> with a valid program object</P>
<P><A class="citerefentry" href="#glGetUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniform</A> with a valid program object and the location of a
 uniform variable</P>
<P><A class="citerefentry" href="#glGetUniformLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetUniformLocation</A> with a valid program object and the name of a
 uniform variable</P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3486">See Also</A></H2>
<P><A class="citerefentry" href="#glAttachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glAttachShader</A>, <A class="citerefentry" href="#glBindAttribLocation">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindAttribLocation</A>, <A class="citerefentry" href="#glCompileShader">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCompileShader</A>, <A class="citerefentry" href="#glCreateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glCreateProgram</A>, <A class="citerefentry" href="#glDeleteProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDeleteProgram</A>, <A class="citerefentry" href="#glDetachShader">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDetachShader</A>, <A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glUniform">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUniform</A>, <A class="citerefentry" href="#glValidateProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glValidateProgram</A>, <A class="citerefentry" href="#glVertexAttrib">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttrib</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glValidateProgram"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3488">Name</A></H2>
<P>glValidateProgram -- validate a program object</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3489">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glValidateProgram</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> program</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3490">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>program</CODE></EM></DT>
<DD>
<P>Specifies the handle of the program object to be validated.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3491">Description</A></H2>
<P><CODE class="function">glValidateProgram</CODE> checks to see whether
 the executables contained in<EM class="parameter"> <CODE>program</CODE></EM>
 can execute given the current OpenGL state. The information generated
 by the validation process will be stored in<EM class="parameter"> <CODE>
program</CODE></EM>'s information log. The validation information may
 consist of an empty string, or it may be a string containing
 information about how the current program object interacts with the
 rest of current OpenGL state. This provides a way for OpenGL
 implementers to convey more information about why the current program
 is inefficient, suboptimal, failing to execute, and so on.</P>
<P>The status of the validation operation will be stored as part of the
 program object's state. This value will be set to <CODE class="constant">
GL_TRUE</CODE> if the validation succeeded, and <CODE class="constant">
GL_FALSE</CODE> otherwise. It can be queried by calling <A class="citerefentry"
href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with arguments<EM class="parameter"> <CODE>program</CODE>
</EM> and <CODE class="constant">GL_VALIDATE_STATUS</CODE>. If
 validation is successful,<EM class="parameter"> <CODE>program</CODE></EM>
 is guaranteed to execute given the current state. Otherwise,<EM class="parameter">
 <CODE>program</CODE></EM> is guaranteed to not execute.</P>
<P>This function is typically useful only during application
 development. The informational string stored in the information log is
 completely implementation dependent; therefore, an application should
 not expect different OpenGL implementations to produce identical
 information strings.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3492">Notes</A></H2>
<P>This function mimics the validation operation that OpenGL
 implementations must perform when rendering commands are issued while
 programmable shaders are part of current state. The error <CODE class="constant">
GL_INVALID_OPERATION</CODE> will be generated by <A class="citerefentry" href="#glDrawArrays">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawArrays</A> or <A class="citerefentry" href="#glDrawElements">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawElements</A> if any two active samplers in the current program
 object are of different types, but refer to the same texture image
 unit.</P>
<P>It may be difficult or cause a performance degradation for
 applications to catch these errors when rendering commands are issued.
 Therefore, applications are advised to make calls to <CODE class="function">
glValidateProgram</CODE> to detect these issues during application
 development.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3493">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a value generated by OpenGL.</P>
<P><CODE class="constant">GL_INVALID_OPERATION</CODE> is generated if<EM class="parameter">
 <CODE>program</CODE></EM> is not a program object.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3494">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGetProgramiv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramiv</A> with arguments<EM class="parameter"> <CODE>program</CODE>
</EM> and <CODE class="constant">GL_VALIDATE_STATUS</CODE></P>
<P><A class="citerefentry" href="#glGetProgramInfoLog">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetProgramInfoLog</A> with argument<EM class="parameter"> <CODE>
program</CODE></EM></P>
<P><A class="citerefentry" href="#glIsProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glIsProgram</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3495">See Also</A></H2>
<P><A class="citerefentry" href="#glLinkProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glLinkProgram</A>, <A class="citerefentry" href="#glUseProgram">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glUseProgram</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glVertexAttrib"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3497">Name</A></H2>
<P>glVertexAttrib -- specify the value of a generic vertex attribute</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3498">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glVertexAttrib1f</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v0</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glVertexAttrib2f</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v0</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v1</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glVertexAttrib3f</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v0</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v1</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v2</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glVertexAttrib4f</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v0</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v1</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v2</VAR>,</TD></TR>
<TR><TD></TD><TD>GLfloat<VAR class="pdparam"> v3</VAR><CODE>)</CODE>;</TD>
</TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3499">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>index</CODE></EM></DT>
<DD>
<P>Specifies the index of the generic vertex attribute to be modified.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>v0</CODE></EM>,<EM class="parameter"> <CODE>
v1</CODE></EM>,<EM class="parameter"> <CODE>v2</CODE></EM>,<EM class="parameter">
 <CODE>v3</CODE></EM></DT>
<DD>
<P>Specifies the new values to be used for the specified vertex
 attribute.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3500">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glVertexAttrib1fv</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLfloat *<VAR class="pdparam">v</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glVertexAttrib2fv</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLfloat *<VAR class="pdparam">v</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glVertexAttrib3fv</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLfloat *<VAR class="pdparam">v</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV>
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glVertexAttrib4fv</B>
(</CODE></TD><TD>GLuint<VAR class="pdparam"> index</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLfloat *<VAR class="pdparam">v</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters2"></A>
<H2><A NAME="0_3501">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>index</CODE></EM></DT>
<DD>
<P>Specifies the index of the generic vertex attribute to be modified.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>v</CODE></EM></DT>
<DD>
<P>Specifies a pointer to an array of values to be used for the generic
 vertex attribute.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3502">Description</A></H2>
<P>The <CODE class="function">glVertexAttrib</CODE> family of entry
 points allows an application to pass generic vertex attributes in
 numbered locations.</P>
<P>Generic attributes are defined as four-component values that are
 organized into an array. The first entry of this array is numbered 0,
 and the size of the array is specified by the implementation-dependent
 symbolic constant <CODE class="constant">GL_MAX_VERTEX_ATTRIBS</CODE>.
 Individual elements of this array can be modified with a <CODE class="function">
glVertexAttrib</CODE> call that specifies the index of the element to be
 modified and a value for that element.</P>
<P>These commands can be used to specify one, two, three, or all four
 components of the generic vertex attribute specified by<EM class="parameter">
 <CODE>index</CODE></EM>. A <CODE class="function">1</CODE> in the name
 of the command indicates that only one value is passed, and it will be
 used to modify the first component of the generic vertex attribute. The
 second and third components will be set to 0, and the fourth component
 will be set to 1. Similarly, a <CODE class="function">2</CODE> in the
 name of the command indicates that values are provided for the first
 two components, the third component will be set to 0, and the fourth
 component will be set to 1. A <CODE class="function">3</CODE> in the
 name of the command indicates that values are provided for the first
 three components and the fourth component will be set to 1, whereas a <CODE
class="function">4</CODE> in the name indicates that values are provided
 for all four components.</P>
<P>The letter <CODE class="function">f</CODE> indicates that the
 arguments are of type float. When <CODE class="function">v</CODE> is
 appended to the name, the commands can take a pointer to an array of
 floats.</P>
<P>OpenGL ES Shading Language attribute variables are allowed to be of
 type mat2, mat3, or mat4. Attributes of these types may be loaded using
 the <CODE class="function">glVertexAttrib</CODE> entry points. Matrices
 must be loaded into successive generic attribute slots in column major
 order, with one column of the matrix in each generic attribute slot.</P>
<P>A user-defined attribute variable declared in a vertex shader can be
 bound to a generic attribute index by calling <A class="citerefentry" href="#glBindAttribLocation">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindAttribLocation</A>. This allows an application to use descriptive
 variable names in a vertex shader. A subsequent change to the specified
 generic vertex attribute will be immediately reflected as a change to
 the corresponding attribute variable in the vertex shader.</P>
<P>The binding between a generic vertex attribute index and a
 user-defined attribute variable in a vertex shader is part of the state
 of a program object, but the current value of the generic vertex
 attribute is not. The value of each generic vertex attribute is part of
 current state and it is maintained even if a different program object
 is used.</P>
<P>An application may freely modify generic vertex attributes that are
 not bound to a named vertex shader attribute variable. These values are
 simply maintained as part of current state and will not be accessed by
 the vertex shader. If a generic vertex attribute bound to an attribute
 variable in a vertex shader is not updated while the vertex shader is
 executing, the vertex shader will repeatedly use the current value for
 the generic vertex attribute.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3503">Notes</A></H2>
<P>It is possible for an application to bind more than one attribute
 name to the same generic vertex attribute index. This is referred to as
 aliasing, and it is allowed only if just one of the aliased attribute
 variables is active in the vertex shader, or if no path through the
 vertex shader consumes more than one of the attributes aliased to the
 same location. OpenGL implementations are not required to do error
 checking to detect aliasing, they are allowed to assume that aliasing
 will not occur, and they are allowed to employ optimizations that work
 only in the absence of aliasing.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3504">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>index</CODE></EM> is greater than or equal to <CODE class="constant">
GL_MAX_VERTEX_ATTRIBS</CODE>.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3505">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with the argument <CODE class="constant">GL_CURRENT_PROGRAM</CODE>
</P>
<P><A class="citerefentry" href="#glGetActiveAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetActiveAttrib</A> with argument<EM class="parameter"> <CODE>program</CODE>
</EM> and the index of an active attribute variable</P>
<P><A class="citerefentry" href="#glGetAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetAttribLocation</A> with argument<EM class="parameter"> <CODE>
program</CODE></EM> and an attribute variable name</P>
<P><A class="citerefentry" href="#glGetVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttrib</A> with arguments <CODE class="constant">
GL_CURRENT_VERTEX_ATTRIB</CODE> and<EM class="parameter"> <CODE>index</CODE>
</EM></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3506">See Also</A></H2>
<P><A class="citerefentry" href="#glBindAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindAttribLocation</A>, <A class="citerefentry" href="#glVertexAttribPointer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttribPointer</A></P>
</DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glVertexAttribPointer">
</A><DIV class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3508">Name</A></H2>
<P>glVertexAttribPointer -- define an array of generic vertex attribute
 data</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3509">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc">
 glVertexAttribPointer</B>(</CODE></TD><TD>GLuint<VAR class="pdparam">
 index</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> size</VAR>,</TD></TR>
<TR><TD></TD><TD>GLenum<VAR class="pdparam"> type</VAR>,</TD></TR>
<TR><TD></TD><TD>GLboolean<VAR class="pdparam"> normalized</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> stride</VAR>,</TD></TR>
<TR><TD></TD><TD>const GLvoid *<VAR class="pdparam"> pointer</VAR><CODE>
)</CODE>;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3510">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>index</CODE></EM></DT>
<DD>
<P>Specifies the index of the generic vertex attribute to be modified.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>size</CODE></EM></DT>
<DD>
<P>Specifies the number of components per generic vertex attribute. Must
 be 1, 2, 3, or 4. The initial value is 4.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>type</CODE></EM></DT>
<DD>
<P>Specifies the data type of each component in the array. Symbolic
 constants <CODE class="constant">GL_BYTE</CODE>, <CODE class="constant">
GL_UNSIGNED_BYTE</CODE>, <CODE class="constant">GL_SHORT</CODE>, <CODE class="constant">
GL_UNSIGNED_SHORT</CODE>, <CODE class="constant">GL_FIXED</CODE>, or <CODE
class="constant">GL_FLOAT</CODE> are accepted. The initial value is <CODE
class="constant">GL_FLOAT</CODE>.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>normalized</CODE></EM></DT>
<DD>
<P>Specifies whether fixed-point data values should be normalized (<CODE class="constant">
GL_TRUE</CODE>) or converted directly as fixed-point values (<CODE class="constant">
GL_FALSE</CODE>) when they are accessed.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>stride</CODE></EM></DT>
<DD>
<P>Specifies the byte offset between consecutive generic vertex
 attributes. If<EM class="parameter"> <CODE>stride</CODE></EM> is 0, the
 generic vertex attributes are understood to be tightly packed in the
 array. The initial value is 0.</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>pointer</CODE></EM></DT>
<DD>
<P>Specifies a pointer to the first component of the first generic
 vertex attribute in the array. The initial value is 0.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3511">Description</A></H2>
<P><CODE class="function">glVertexAttribPointer</CODE> specifies the
 location and data format of the array of generic vertex attributes at
 index<EM class="parameter"> <CODE>index</CODE></EM> to use when
 rendering.<EM class="parameter"> <CODE>size</CODE></EM> specifies the
 number of components per attribute and must be 1, 2, 3, or 4.<EM class="parameter">
 <CODE>type</CODE></EM> specifies the data type of each component, and<EM
class="parameter"> <CODE>stride</CODE></EM> specifies the byte stride
 from one attribute to the next, allowing vertices and attributes to be
 packed into a single array or stored in separate arrays. If set to <CODE
class="constant">GL_TRUE</CODE>,<EM class="parameter"> <CODE>normalized</CODE>
</EM> indicates that values stored in an integer format are to be mapped
 to the range [-1,1] (for signed values) or [0,1] (for unsigned values)
 when they are accessed and converted to floating point. Otherwise,
 values will be converted to floats directly without normalization.</P>
<P>If a non-zero named buffer object is bound to the <CODE class="constant">
GL_ARRAY_BUFFER</CODE> target (see <A class="citerefentry" href="#glBindBuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>) while a generic vertex attribute array is specified,<EM
class="parameter"> <CODE>pointer</CODE></EM> is treated as a byte offset
 into the buffer object's data store. Also, the buffer object binding (<CODE
class="constant">GL_ARRAY_BUFFER_BINDING</CODE>) is saved as generic
 vertex attribute array client-side state (<CODE class="constant">
GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</CODE>) for index<EM class="parameter">
 <CODE>index</CODE></EM>.</P>
<P>When a generic vertex attribute array is specified,<EM class="parameter">
 <CODE>size</CODE></EM>,<EM class="parameter"> <CODE>type</CODE></EM>,<EM
class="parameter"> <CODE>normalized</CODE></EM>,<EM class="parameter"> <CODE>
stride</CODE></EM>, and<EM class="parameter"> <CODE>pointer</CODE></EM>
 are saved as client-side state, in addition to the current vertex array
 buffer object binding.</P>
<P>To enable and disable a generic vertex attribute array, call <A class="citerefentry"
href="#glEnableVertexAttribArray">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnableVertexAttribArray</A> and <A class="citerefentry" href="#glEnableVertexAttribArray">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisableVertexAttribArray</A> with<EM class="parameter"> <CODE>index</CODE>
</EM>. If enabled, the generic vertex attribute array is used when <A class="citerefentry"
href="#glDrawArrays">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawArrays</A> or <A class="citerefentry" href="#glDrawElements">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawElements</A> is called.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="notes"></A>
<H2><A NAME="0_3512">Notes</A></H2>
<P>Each generic vertex attribute array is initially disabled and isn't
 accessed when <A class="citerefentry" href="#glDrawElements">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawElements</A> or <A class="citerefentry" href="#glDrawArrays">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawArrays</A> is called.</P>
<P><CODE class="function">glVertexAttribPointer</CODE> is typically
 implemented on the client side.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3513">Errors</A></H2>
<P><CODE class="constant">GL_INVALID_ENUM</CODE> is generated if<EM class="parameter">
 <CODE>type</CODE></EM> is not an accepted value.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>index</CODE></EM> is greater than or equal to <CODE class="constant">
GL_MAX_VERTEX_ATTRIBS</CODE>.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>size</CODE></EM> is not 1, 2, 3, or 4.</P>
<P><CODE class="constant">GL_INVALID_VALUE</CODE> is generated if<EM class="parameter">
 <CODE>stride</CODE></EM> is negative.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3514">Associated Gets</A></H2>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_VERTEX_ATTRIBS</CODE>
</P>
<P><A class="citerefentry" href="#glGetVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttrib</A> with arguments<EM class="parameter"> <CODE>index</CODE>
</EM> and <CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_ENABLED</CODE></P>
<P><A class="citerefentry" href="#glGetVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttrib</A> with arguments<EM class="parameter"> <CODE>index</CODE>
</EM> and <CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_SIZE</CODE></P>
<P><A class="citerefentry" href="#glGetVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttrib</A> with arguments<EM class="parameter"> <CODE>index</CODE>
</EM> and <CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_TYPE</CODE></P>
<P><A class="citerefentry" href="#glGetVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttrib</A> with arguments<EM class="parameter"> <CODE>index</CODE>
</EM> and <CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</CODE>
</P>
<P><A class="citerefentry" href="#glGetVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttrib</A> with arguments<EM class="parameter"> <CODE>index</CODE>
</EM> and <CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_STRIDE</CODE></P>
<P><A class="citerefentry" href="#glGetVertexAttrib">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttrib</A> with arguments<EM class="parameter"> <CODE>index</CODE>
</EM> and <CODE class="constant">GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</CODE>
</P>
<P><A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_ARRAY_BUFFER_BINDING</CODE>
</P>
<P><A class="citerefentry" href="#glGetVertexAttribPointerv">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGetVertexAttribPointerv</A> with arguments<EM class="parameter"> <CODE>
index</CODE></EM> and <CODE class="constant">
GL_VERTEX_ATTRIB_ARRAY_POINTER</CODE></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3515">See Also</A></H2>
<A class="citerefentry" href="#glBindAttribLocation">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindAttribLocation</A>, <A class="citerefentry" href="#glBindBuffer">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glBindBuffer</A>, <A class="citerefentry" href="#glEnableVertexAttribArray">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDisableVertexAttribArray</A>, <A class="citerefentry" href="#glDrawArrays">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawArrays</A>, <A class="citerefentry" href="#glDrawElements">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDrawElements</A>, <A class="citerefentry" href="#glEnableVertexAttribArray">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glEnableVertexAttribArray</A>, <A class="citerefentry" href="#glVertexAttrib">

<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glVertexAttrib</A></DIV></DIV><HR NOSHADE>

<!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?-->

<!-- saved from url=(0013)about:internet -->

<!--?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mathml.xsl&quot;?-->
<DIV class="refentry" lang="en" xml:lang="en"><A id="glViewport"></A><DIV
class="titlepage"></DIV><DIV class="refnamediv">
<H2><A NAME="0_3517">Name</A></H2>
<P>glViewport -- set the viewport</P>
</DIV><DIV class="refsynopsisdiv">
<H2><A NAME="0_3518">C Specification</A></H2>
<DIV class="funcsynopsis">
<TABLE border="0" cellpadding="0" cellspacing="0" class="funcprototype-table"
summary="Function synopsis">
<TR><TD><CODE class="funcdef">void<B class="fsfunc"> glViewport</B>(</CODE>
</TD><TD>GLint<VAR class="pdparam"> x</VAR>,</TD></TR>
<TR><TD></TD><TD>GLint<VAR class="pdparam"> y</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> width</VAR>,</TD></TR>
<TR><TD></TD><TD>GLsizei<VAR class="pdparam"> height</VAR><CODE>)</CODE>
;</TD></TR>
</TABLE>
<DIV class="funcprototype-spacer"></DIV></DIV></DIV><DIV class="refsect1"
lang="en" xml:lang="en"><A id="parameters"></A>
<H2><A NAME="0_3519">Parameters</A></H2>
<DIV class="variablelist">
<DL>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>x</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>y</CODE></EM></DT>
<DD>
<P> Specify the lower left corner of the viewport rectangle, in pixels.
 The initial value is (0,0).</P>
</DD>
<DT>
<!--span class=&quot;term&quot;-->
<EM class="parameter"><CODE>width</CODE></EM>,
<!--span class=&quot;term&quot;-->
<EM class="parameter"> <CODE>height</CODE></EM></DT>
<DD>
<P> Specify the width and height of the viewport. When a GL context is
 first attached to a window,<EM class="parameter"> <CODE>width</CODE></EM>
 and<EM class="parameter"> <CODE>height</CODE></EM> are set to the
 dimensions of that window.</P>
</DD>
</DL>
</DIV></DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="description">
</A>
<H2><A NAME="0_3520">Description</A></H2>
<P> <CODE class="function">glViewport</CODE> specifies the affine
 transformation of
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 x and
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 y from normalized device coordinates to window coordinates. Let
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 x
<!--mml:mi mathvariant=&quot;italic&quot;-->
 nd
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 y
<!--mml:mi mathvariant=&quot;italic&quot;-->
 nd be normalized device coordinates. Then the window coordinates
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 x
<!--mml:mi mathvariant=&quot;italic&quot;-->
 w
<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 y
<!--mml:mi mathvariant=&quot;italic&quot;-->
 w are computed as follows:</P>
<P></P>
<DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 x
<!--mml:mi mathvariant=&quot;italic&quot;-->
 w
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 x
<!--mml:mi mathvariant=&quot;italic&quot;-->
 nd
<!--mml:mo-->
 +
<!--mml:mn-->
 1
<!--mml:mo-->
 &acirc;&cent;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 width
<!--mml:mn-->
 2
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 x</DIV>
<P></P>
<P></P>
<DIV class="informalequation">
<!--mml:math xmlns:mml=&quot;http://www.w3.org/1998/Math/MathML&quot; overflow=&quot;scroll&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 y
<!--mml:mi mathvariant=&quot;italic&quot;-->
 w
<!--mml:mo-->
 =
<!--mml:mrow-->

<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mrow-->

<!--mml:msub-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 y
<!--mml:mi mathvariant=&quot;italic&quot;-->
 nd
<!--mml:mo-->
 +
<!--mml:mn-->
 1
<!--mml:mo-->
 &acirc;&cent;
<!--mml:mfenced open=&quot;(&quot; close=&quot;)&quot;-->

<!--mml:mfrac-->

<!--mml:mi mathvariant=&quot;italic&quot;-->
 height
<!--mml:mn-->
 2
<!--mml:mo-->
 +
<!--mml:mi mathvariant=&quot;italic&quot;-->
 y</DIV>
<P></P>
<P> Viewport width and height are silently clamped to a range that
 depends on the implementation. To query this range, call <A class="citerefentry"
href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_VIEWPORT_DIMS</CODE>
.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="errors"></A>
<H2><A NAME="0_3521">Errors</A></H2>
<P> <CODE class="constant">GL_INVALID_VALUE</CODE> is generated if
 either<EM class="parameter"> <CODE>width</CODE></EM> or<EM class="parameter">
 <CODE>height</CODE></EM> is negative.</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="associatedgets">
</A>
<H2><A NAME="0_3522">Associated Gets</A></H2>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_VIEWPORT</CODE></P>
<P> <A class="citerefentry" href="#glGet">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glGet</A> with argument <CODE class="constant">GL_MAX_VIEWPORT_DIMS</CODE>
</P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="seealso"></A>
<H2><A NAME="0_3523">See Also</A></H2>
<P> <A class="citerefentry" href="#glDepthRangef">
<!--span class=&quot;citerefentry&quot;-->

<!--span class=&quot;refentrytitle&quot;-->
glDepthRangef</A></P>
</DIV><DIV class="refsect1"  lang="en" xml:lang="en"><A id="copyright"></A>
<H2><A NAME="0_3221">Copyright</A></H2>
<P> Copyright
<!--span class=&quot;trademark&quot;-->
 Copyright 2003-2005 3Dlabs Inc. Ltd. 
 Copyright 2005 Addison-Wesley. 
 Copyright 1991-2006 Silicon Graphics, Inc. 
 Copyright 2008 Khronos Group. 
<A href="http://opencontent.org/openpub/">http://opencontent.org/openpub/</A> 
<A href="http://oss.sgi.com/projects/FreeB/">http://oss.sgi.com/projects/FreeB/</A></P>
<p>this document is a colation into a single document of the GLES 2.0 man pages 
oiginally avialable as individual pages on <A href="http://www.khronos.org/opengles/sdk/docs/man/">http://www.khronos.org/opengles/sdk/docs/man/</A>
no textual modifications were made
</p>
</DIV></DIV></BODY>
</HTML>
